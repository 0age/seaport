{
  "address": "0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "legacyProxyRegistry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "legacyTokenTransferProxy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "requiredProxyImplementation",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "BadContractSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BadFraction",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "BadReturnValueFromERC20OnTransfer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        }
      ],
      "name": "BadSignatureV",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ConsiderationCriteriaResolverOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "orderIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "considerationIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shortfallAmount",
          "type": "uint256"
        }
      ],
      "name": "ConsiderationNotMet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CriteriaNotEnabledForItem",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "identifiers",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "ERC1155BatchTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EtherTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FulfilledOrderIndexOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InexactFraction",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientEtherSupplied",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBasicOrderParameterEncoding",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCanceller",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidERC721TransferAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFulfillmentComponentData",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "InvalidMsgValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidProof",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidProxyImplementation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "InvalidRestrictedOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSigner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTime",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MismatchedFulfillmentOfferAndConsiderationComponents",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "enum Side",
          "name": "side",
          "type": "uint8"
        }
      ],
      "name": "MissingFulfillmentComponentOnAggregation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MissingItemAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MissingOriginalConsiderationItems",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NoContract",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoReentrantCalls",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoSpecifiedOrdersAvailable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OfferAndConsiderationRequiredOnFulfillment",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OfferCriteriaResolverOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "OrderAlreadyFilled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OrderCriteriaResolverOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "OrderIsCancelled",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "OrderPartiallyFilled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PartialFillsNotEnabledForOrder",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "identifier",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TokenTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnresolvedConsiderationCriteria",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnresolvedOfferCriteria",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newNonce",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        }
      ],
      "name": "NonceIncremented",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "zone",
          "type": "address"
        }
      ],
      "name": "OrderCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "zone",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "fulfiller",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "enum ItemType",
              "name": "itemType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct SpentItem[]",
          "name": "offer",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "enum ItemType",
              "name": "itemType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            }
          ],
          "indexed": false,
          "internalType": "struct ReceivedItem[]",
          "name": "consideration",
          "type": "tuple[]"
        }
      ],
      "name": "OrderFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "zone",
          "type": "address"
        }
      ],
      "name": "OrderValidated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DOMAIN_SEPARATOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "zone",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OfferItem[]",
              "name": "offer",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ConsiderationItem[]",
              "name": "consideration",
              "type": "tuple[]"
            },
            {
              "internalType": "enum OrderType",
              "name": "orderType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "zoneHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            }
          ],
          "internalType": "struct OrderComponents[]",
          "name": "orders",
          "type": "tuple[]"
        }
      ],
      "name": "cancel",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "conduit",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "uint120",
              "name": "numerator",
              "type": "uint120"
            },
            {
              "internalType": "uint120",
              "name": "denominator",
              "type": "uint120"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct AdvancedOrder",
          "name": "advancedOrder",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "enum Side",
              "name": "side",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "criteriaProof",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct CriteriaResolver[]",
          "name": "criteriaResolvers",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "fulfillerConduit",
          "type": "address"
        }
      ],
      "name": "fulfillAdvancedOrder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "conduit",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "uint120",
              "name": "numerator",
              "type": "uint120"
            },
            {
              "internalType": "uint120",
              "name": "denominator",
              "type": "uint120"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct AdvancedOrder[]",
          "name": "advancedOrders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "enum Side",
              "name": "side",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "criteriaProof",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct CriteriaResolver[]",
          "name": "criteriaResolvers",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "itemIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct FulfillmentComponent[][]",
          "name": "offerFulfillments",
          "type": "tuple[][]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "itemIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct FulfillmentComponent[][]",
          "name": "considerationFulfillments",
          "type": "tuple[][]"
        },
        {
          "internalType": "address",
          "name": "fulfillerConduit",
          "type": "address"
        }
      ],
      "name": "fulfillAvailableAdvancedOrders",
      "outputs": [
        {
          "internalType": "bool[]",
          "name": "availableOrders",
          "type": "bool[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "standardExecutions",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            }
          ],
          "internalType": "struct BatchExecution[]",
          "name": "batchExecutions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "considerationToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "considerationIdentifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "considerationAmount",
              "type": "uint256"
            },
            {
              "internalType": "address payable",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "zone",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "offerToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offerIdentifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "offerAmount",
              "type": "uint256"
            },
            {
              "internalType": "enum BasicOrderType",
              "name": "basicOrderType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "zoneHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "offererConduit",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "fulfillerConduit",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalOriginalAdditionalRecipients",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct AdditionalRecipient[]",
              "name": "additionalRecipients",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct BasicOrderParameters",
          "name": "parameters",
          "type": "tuple"
        }
      ],
      "name": "fulfillBasicOrder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "conduit",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "fulfillerConduit",
          "type": "address"
        }
      ],
      "name": "fulfillOrder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        }
      ],
      "name": "getNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "zone",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OfferItem[]",
              "name": "offer",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ConsiderationItem[]",
              "name": "consideration",
              "type": "tuple[]"
            },
            {
              "internalType": "enum OrderType",
              "name": "orderType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "zoneHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            }
          ],
          "internalType": "struct OrderComponents",
          "name": "order",
          "type": "tuple"
        }
      ],
      "name": "getOrderHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "getOrderStatus",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValidated",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isCancelled",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "totalFilled",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalSize",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "incrementNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newNonce",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "conduit",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "uint120",
              "name": "numerator",
              "type": "uint120"
            },
            {
              "internalType": "uint120",
              "name": "denominator",
              "type": "uint120"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct AdvancedOrder[]",
          "name": "advancedOrders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "enum Side",
              "name": "side",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "criteriaProof",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct CriteriaResolver[]",
          "name": "criteriaResolvers",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "offerComponents",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "considerationComponents",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Fulfillment[]",
          "name": "fulfillments",
          "type": "tuple[]"
        }
      ],
      "name": "matchAdvancedOrders",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "standardExecutions",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            }
          ],
          "internalType": "struct BatchExecution[]",
          "name": "batchExecutions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "conduit",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order[]",
          "name": "orders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "offerComponents",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "considerationComponents",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Fulfillment[]",
          "name": "fulfillments",
          "type": "tuple[]"
        }
      ],
      "name": "matchOrders",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "standardExecutions",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            },
            {
              "internalType": "address",
              "name": "conduit",
              "type": "address"
            }
          ],
          "internalType": "struct BatchExecution[]",
          "name": "batchExecutions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "conduit",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order[]",
          "name": "orders",
          "type": "tuple[]"
        }
      ],
      "name": "validate",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xee85867c15cfb089f4eba4ba6826caf303dd5eeaaca27f87501b2e9deb052845",
  "receipt": {
    "to": null,
    "from": "0x627306090abaB3A6e1400e9345bC60c78a8BEf57",
    "contractAddress": "0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4",
    "transactionIndex": 0,
    "gasUsed": "5304996",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x99b54293b66d10689af7c4064773171ed3516e6166c19a4511c8e7e121ac14bf",
    "transactionHash": "0xee85867c15cfb089f4eba4ba6826caf303dd5eeaaca27f87501b2e9deb052845",
    "logs": [],
    "blockNumber": 7,
    "cumulativeGasUsed": "5304996",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF",
    "0x8f0483125FCb9aaAEFA9209D8E9d7b9C8B9Fb90F",
    "0x9FBDa871d559710256a2502A2517b794B482Db40"
  ],
  "numDeployments": 1,
  "solcInputHash": "ccc4e07d484517a8c380a55b06c0e1e8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"legacyProxyRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"legacyTokenTransferProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"requiredProxyImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BadSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CriteriaNotEnabledForItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FulfilledOrderIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InexactFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEtherSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCanceller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFulfillmentComponentData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProxyImplementation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidRestrictedOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedFulfillmentOfferAndConsiderationComponents\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"MissingFulfillmentComponentOnAggregation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferAndConsiderationRequiredOnFulfillment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnresolvedConsiderationCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnresolvedOfferCriteria\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newNonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"NonceIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fulfiller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"advancedOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"fulfillerConduit\",\"type\":\"address\"}],\"name\":\"fulfillAdvancedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"offerFulfillments\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"considerationFulfillments\",\"type\":\"tuple[][]\"},{\"internalType\":\"address\",\"name\":\"fulfillerConduit\",\"type\":\"address\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"availableOrders\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"internalType\":\"struct Execution[]\",\"name\":\"standardExecutions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"internalType\":\"struct BatchExecution[]\",\"name\":\"batchExecutions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offererConduit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fulfillerConduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"fulfillerConduit\",\"type\":\"address\"}],\"name\":\"fulfillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"fulfillments\",\"type\":\"tuple[]\"}],\"name\":\"matchAdvancedOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"internalType\":\"struct Execution[]\",\"name\":\"standardExecutions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"internalType\":\"struct BatchExecution[]\",\"name\":\"batchExecutions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"fulfillments\",\"type\":\"tuple[]\"}],\"name\":\"matchOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"internalType\":\"struct Execution[]\",\"name\":\"standardExecutions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"internalType\":\"struct BatchExecution[]\",\"name\":\"batchExecutions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"0age\",\"custom:coauthor\":\"d1ll0ntransmissions11\",\"custom:version\":\"rc-1\",\"errors\":{\"BadContractSignature()\":[{\"details\":\"Revert with an error when an EIP-1271 call to an account fails.\"}],\"BadFraction()\":[{\"details\":\"Revert with an error when supplying a fraction with a value of zero      for the numerator or denominator, or one where the numerator exceeds      the denominator.\"}],\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\":[{\"details\":\"Revert with an error when an ERC20 token transfer returns a falsey      value.\",\"params\":{\"amount\":\"The amount for the attempted ERC20 transfer.\",\"from\":\"The source of the attempted ERC20 transfer.\",\"to\":\"The recipient of the attempted ERC20 transfer.\",\"token\":\"The token for which the ERC20 transfer was attempted.\"}}],\"BadSignatureV(uint8)\":[{\"details\":\"Revert with an error when a signature that does not contain a v      value of 27 or 28 has been supplied.\",\"params\":{\"v\":\"The invalid v value.\"}}],\"ConsiderationCriteriaResolverOutOfRange()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order with a consideration item that has not been supplied.\"}],\"ConsiderationNotMet(uint256,uint256,uint256)\":[{\"details\":\"Revert with an error if a consideration amount has not been fully      zeroed out after applying all fulfillments.\",\"params\":{\"considerationIndex\":\"The index of the consideration item on the                           order.\",\"orderIndex\":\"The index of the order with the consideration                           item with a shortfall.\",\"shortfallAmount\":\"The unfulfilled consideration amount.\"}}],\"CriteriaNotEnabledForItem()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order with an item that does not expect a criteria to be      resolved.\"}],\"ERC1155BatchTransferGenericFailure(address,address,address,uint256[],uint256[])\":[{\"details\":\"Revert with an error when a batch ERC1155 token transfer reverts.\",\"params\":{\"amounts\":\"The amounts for the attempted transfer.\",\"from\":\"The source of the attempted transfer.\",\"identifiers\":\"The identifiers for the attempted transfer.\",\"to\":\"The recipient of the attempted transfer.\",\"token\":\"The token for which the transfer was attempted.\"}}],\"EtherTransferGenericFailure(address,uint256)\":[{\"details\":\"Revert with an error when an ether transfer reverts.\"}],\"FulfilledOrderIndexOutOfRange()\":[{\"details\":\"Revert with an error when a fulfillment is provided with an index      that references an order or item that has not been supplied.\"}],\"InexactFraction()\":[{\"details\":\"Revert with an error when attempting to apply a fraction as part of      a partial fill that does not divide the target amount cleanly.\"}],\"InsufficientEtherSupplied()\":[{\"details\":\"Revert with an error when insufficient ether is supplied as part of      msg.value when fulfilling orders.\"}],\"InvalidBasicOrderParameterEncoding()\":[{\"details\":\"Revert with an error when attempting to fill a basic order using      calldata not produced by default ABI encoding.\"}],\"InvalidCanceller()\":[{\"details\":\"Revert with an error when attempting to cancel an order as a caller      other than the indicated offerer or zone.\"}],\"InvalidERC721TransferAmount()\":[{\"details\":\"Revert with an error when an ERC721 transfer with amount other than      one is attempted.\"}],\"InvalidFulfillmentComponentData()\":[{\"details\":\"Revert with an error when an order or item index are out of range      or a fulfillment component does not match the type, token,      identifier, or conduit preference of the initial consideration item.\"}],\"InvalidMsgValue(uint256)\":[{\"details\":\"Revert with an error when a caller attempts to supply callvalue to a      non-payable basic order route or does not supply any callvalue to a      payable basic order route.\"}],\"InvalidProof()\":[{\"details\":\"Revert with an error when providing a criteria resolver that      contains an invalid proof with respect to the given item and      chosen identifier.\"}],\"InvalidProxyImplementation()\":[{\"details\":\"Revert with an error when the implementation of the respective      legacy user proxy does not match the expected proxy implementation.\"}],\"InvalidRestrictedOrder(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill an order that specifies      a restricted submitter as its order type when not submitted by      either the offerrer or the order's zone or approved as valid by the      zone in question via a staticcall to `isValidOrder`.\",\"params\":{\"orderHash\":\"The order hash for the invalid restricted order.\"}}],\"InvalidSignature()\":[{\"details\":\"Revert with an error when a signer cannot be recovered from the      supplied signature.\"}],\"InvalidSigner()\":[{\"details\":\"Revert with an error when the signer recovered by the supplied      signature does not match the offerer or an allowed EIP-1271 signer      as specified by the offerer in the event they are a contract.\"}],\"InvalidTime()\":[{\"details\":\"Revert with an error when attempting to fill an order outside the      specified start time and end time .\"}],\"MismatchedFulfillmentOfferAndConsiderationComponents()\":[{\"details\":\"Revert with an error when the initial offer item named by a      fulfillment component does not match the type, token, identifier,      or conduit preference of the initial consideration item.\"}],\"MissingFulfillmentComponentOnAggregation(uint8)\":[{\"details\":\"Revert with an error when a fulfillment is provided as part of an      call to fulfill available orders that does not declare at least one      component.\"}],\"MissingItemAmount()\":[{\"details\":\"Revert with an error when attempting to fulfill an order where an      item has an amount of zero.\"}],\"MissingOriginalConsiderationItems()\":[{\"details\":\"Revert with an error when an order is supplied for fulfillment with      a consideration array that is shorter than the original array.\"}],\"NoContract(address)\":[{\"details\":\"Revert with an error when an account being called as an assumed      contract does not have code and returns no data.\",\"params\":{\"account\":\"The account that should contain code.\"}}],\"NoReentrantCalls()\":[{\"details\":\"Revert with an error when a caller attempts to reenter a protected      function.\"}],\"NoSpecifiedOrdersAvailable()\":[{\"details\":\"Revert with an error when attempting to fulfill any number of      available orders when none are fulfillable.\"}],\"OfferAndConsiderationRequiredOnFulfillment()\":[{\"details\":\"Revert with an error when a fulfillment is provided that does not      declare at least one offer component and at least one consideration      component.\"}],\"OfferCriteriaResolverOutOfRange()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order with an offer item that has not been supplied.\"}],\"OrderAlreadyFilled(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill an order that has      already been fully filled.\",\"params\":{\"orderHash\":\"The order hash on which a fill was attempted.\"}}],\"OrderCriteriaResolverOutOfRange()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order that has not been supplied.\"}],\"OrderIsCancelled(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill an order that has been      cancelled.\",\"params\":{\"orderHash\":\"The hash of the cancelled order.\"}}],\"OrderPartiallyFilled(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill a basic order that has      been partially filled.\",\"params\":{\"orderHash\":\"The hash of the partially used order.\"}}],\"PartialFillsNotEnabledForOrder()\":[{\"details\":\"Revert with an error when a partial fill is attempted on an order      that does not specify partial fill support in its order type.\"}],\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\":[{\"details\":\"Revert with an error when an ERC20, ERC721, or ERC1155 token      transfer reverts.\",\"params\":{\"amount\":\"The amount for the attempted transfer.\",\"from\":\"The source of the attempted transfer.\",\"identifier\":\"The identifier for the attempted transfer.\",\"to\":\"The recipient of the attempted transfer.\",\"token\":\"The token for which the transfer was attempted.\"}}],\"UnresolvedConsiderationCriteria()\":[{\"details\":\"Revert with an error if a consideration item still has unresolved      criteria after applying all criteria resolvers.\"}],\"UnresolvedOfferCriteria()\":[{\"details\":\"Revert with an error if an offer item still has unresolved criteria      after applying all criteria resolvers.\"}]},\"kind\":\"dev\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"returns\":{\"_0\":\"The domain separator.\"}},\"cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256)[])\":{\"params\":{\"orders\":\"The orders to cancel.\"},\"returns\":{\"_0\":\"A boolean indicating whether the supplied orders were         successfully cancelled.\"}},\"constructor\":{\"params\":{\"legacyProxyRegistry\":\"A proxy registry that stores per-user                                    proxies that may optionally be used to                                    transfer approved ERC721+1155 tokens.\",\"legacyTokenTransferProxy\":\"A shared proxy contract that may                                    optionally be used to transfer                                    approved ERC20 tokens.\",\"requiredProxyImplementation\":\"The implementation that must be set on                                    each proxy in order to utilize it.\"}},\"fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],address)\":{\"params\":{\"advancedOrder\":\"The order to fulfill along with the fraction of                          the order to attempt to fill. Note that both the                          offerer and the fulfiller must first approve                          this contract (or their proxy if indicated by                          the order) to transfer any relevant tokens on                          their behalf and that contracts must implement                          `onERC1155Received` in order to receive ERC1155                          tokens as consideration. Also note that all                          offer and consideration components must have no                          remainder after multiplication of the respective                          amount with the supplied fraction in order for                          the partial fill to be considered valid.\",\"criteriaResolvers\":\"An array where each element contains a reference                          to a specific offer or consideration, a token                          identifier, and a proof that the supplied token                          identifier is contained in the merkle root held                          by the item in question's criteria element. Note                          that an empty criteria indicates that any                          (transferrable) token identifier on the token in                          question is valid and that no associated proof                          needs to be supplied.\",\"fulfillerConduit\":\"An address indicating what conduit, if any, to                          source the fulfiller's token approvals from. The                          null address signifies that no conduit should be                          used (and direct approvals set on Consideration)                          and `address(1)` signifies to utilize the legacy                          user proxy for the fulfiller.\"},\"returns\":{\"_0\":\"A boolean indicating whether the order has been fulfilled.\"}},\"fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],address)\":{\"params\":{\"advancedOrders\":\"The orders to fulfill along with the                                  fraction of those orders to attempt to                                  fill. Note that both the offerer and the                                  fulfiller must first approve this                                  contract (or their proxy if indicated by                                  the order) to transfer any relevant                                  tokens on their behalf and that                                  contracts must implement                                  `onERC1155Received` in order to receive                                  ERC1155 tokens as consideration. Also                                  note that all offer and consideration                                  components must have no remainder after                                  multiplication of the respective amount                                  with the supplied fraction for an                                  order's partial fill amount to be                                  considered valid.\",\"considerationFulfillments\":\"An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.\",\"criteriaResolvers\":\"An array where each element contains a                                  reference to a specific offer or                                  consideration, a token identifier, and a                                  proof that the supplied token identifier                                  is contained in the merkle root held by                                  the item in question's criteria element.                                  Note that an empty criteria indicates                                  that any (transferrable) token                                  identifier on the token in question is                                  valid and that no associated proof needs                                  to be supplied.\",\"fulfillerConduit\":\"An address indicating what conduit, if                                  any, to source the fulfiller's token                                  approvals from. The null address                                  signifies that no conduit should be used                                  (with direct token approvals set on                                  Consideration) and `address(1)`                                  signifies to utilize the legacy user                                  proxy for the fulfiller.\",\"offerFulfillments\":\"An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.\"},\"returns\":{\"availableOrders\":\"   An array of booleans indicating if each order                            with an index corresponding to the index of                            the returned boolean was fulfillable or not.\",\"batchExecutions\":\"   An array of elements indicating the sequence                            of batch transfers performed as part of                            matching the given orders.\",\"standardExecutions\":\"An array of elements indicating the sequence                            of non-batch transfers performed as part of                            matching the given orders.\"}},\"fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,address,address,uint256,(uint256,address)[],bytes))\":{\"params\":{\"parameters\":\"Additional information on the fulfilled order. Note                   that the offerer and the fulfiller must first approve                   this contract (or their chosen conduit if indicated)                   before any tokens can be transferred. Also note that                   contract recipients of ERC1155 consideration items must                   implement `onERC1155Received` in order to receive those                   items.\"},\"returns\":{\"_0\":\"A boolean indicating whether the order has been fulfilled.\"}},\"fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes),address)\":{\"params\":{\"fulfillerConduit\":\"An address indicating what conduit, if any, to                         source the fulfiller's token approvals from. The                         null address signifies that no conduit should be                         used (and direct approvals set on Consideration)                         and `address(1)` signifies to utilize the legacy                         user proxy for the fulfiller.\",\"order\":\"The order to fulfill. Note that both the offerer                         and the fulfiller must first approve this                         contract (or the supplied conduit if indicated)                         to transfer any relevant tokens on their behalf                         and that contracts must implement                         `onERC1155Received` in order to receive ERC1155                         tokens as consideration.\"},\"returns\":{\"_0\":\"A boolean indicating whether the order has been fulfilled.\"}},\"getNonce(address)\":{\"params\":{\"offerer\":\"The offerer in question.\"},\"returns\":{\"_0\":\"The current nonce.\"}},\"getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256))\":{\"params\":{\"order\":\"The components of the order.\"},\"returns\":{\"_0\":\"The order hash.\"}},\"getOrderStatus(bytes32)\":{\"params\":{\"orderHash\":\"The order hash in question.\"},\"returns\":{\"isCancelled\":\"A boolean indicating whether the order in question                     has been cancelled.\",\"isValidated\":\"A boolean indicating whether the order in question                     has been validated (i.e. previously approved or                     partially filled).\",\"totalFilled\":\"The total portion of the order that has been filled                     (i.e. the \\\"numerator\\\").\",\"totalSize\":\"  The total size of the order that is either filled or                     unfilled (i.e. the \\\"denominator\\\").\"}},\"incrementNonce()\":{\"returns\":{\"newNonce\":\"The new nonce.\"}},\"matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"params\":{\"advancedOrders\":\"The advanced orders to match. Note that both the                          offerer and fulfiller on each order must first                          approve this contract (or their proxy if                          indicated by the order) to transfer any relevant                          tokens on their behalf and each consideration                          recipient must implement `onERC1155Received` in                          order toreceive ERC1155 tokens. Also note that                          the offer and consideration components for each                          order must have no remainder after multiplying                          the respective amount with the supplied fraction                          in order for the group of partial fills to be                          considered valid.\",\"criteriaResolvers\":\"An array where each element contains a reference                          to a specific order as well as that order's                          offer or consideration, a token identifier, and                          a proof that the supplied token identifier is                          contained in the order's merkle root. Note that                          an empty root indicates that any (transferrable)                          token identifier is valid and that no associated                          proof needs to be supplied.\",\"fulfillments\":\"An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.\"},\"returns\":{\"batchExecutions\":\"   An array of elements indicating the sequence                            of batch transfers performed as part of                            matching the given orders.\",\"standardExecutions\":\"An array of elements indicating the sequence                            of non-batch transfers performed as part of                            matching the given orders.\"}},\"matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"params\":{\"fulfillments\":\"An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.\",\"orders\":\"The orders to match. Note that both the offerer                          and fulfiller on each order must first approve                          this contract (or their proxy if indicated by                          the order) to transfer any relevant tokens on                          their behalf and each consideration recipient                          must implement `onERC1155Received` in order to                          receive ERC1155 tokens.\"},\"returns\":{\"batchExecutions\":\"   An array of elements indicating the sequence                            of batch transfers performed as part of                            matching the given orders.\",\"standardExecutions\":\"An array of elements indicating the sequence                            of non-batch transfers performed as part of                            matching the given orders.\"}},\"name()\":{\"returns\":{\"_0\":\"The name of this contract.\"}},\"validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[])\":{\"params\":{\"orders\":\"The orders to validate.\"},\"returns\":{\"_0\":\"A boolean indicating whether the supplied orders were         successfully validated.\"}},\"version()\":{\"returns\":{\"_0\":\"The version of this contract.\"}}},\"title\":\"Consideration\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"notice\":\"Retrieve the domain separator, used for signing and verifying signed orders via EIP-712.\"},\"cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256)[])\":{\"notice\":\"Cancel an arbitrary number of orders. Note that only the offerer or the zone of a given order may cancel it.\"},\"constructor\":{\"notice\":\"Derive and set hashes, reference chainId, and associated domain         separator during deployment.\"},\"fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],address)\":{\"notice\":\"Fill an order, fully or partially, with an arbitrary number of         items for offer and consideration alongside criteria resolvers         containing specific token identifiers and associated proofs.\"},\"fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],address)\":{\"notice\":\"Attempt to fill a group of orders, fully or partially, with an         arbitrary number of items for offer and consideration per order         alongside criteria resolvers containing specific token         identifiers and associated proofs. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail.\"},\"fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,address,address,uint256,(uint256,address)[],bytes))\":{\"notice\":\"Fulfill an order offering an ERC20, ERC721, or ERC1155 item by         supplying Ether (or other native tokens), ERC20 tokens, an ERC721         item, or an ERC1155 item as consideration. Six permutations are         supported: Native token to ERC721, Native token to ERC1155, ERC20         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to         ERC20 (with native tokens supplied as msg.value). For an order to         be eligible for fulfillment via this method, it must contain a         single offer item (though that item may have a greater amount if         the item is not an ERC721). An arbitrary number of \\\"additional         recipients\\\" may also be supplied which will each receive native         tokens or ERC20 items from the fulfiller as consideration. Refer         to the documentation for a more comprehensive summary of how to         utilize with this method and what orders are compatible with it.\"},\"fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes),address)\":{\"notice\":\"Fulfill an order with an arbitrary number of items for offer and         consideration. Note that this function does not support         criteria-based orders or partial filling of orders (though         filling the remainder of a partially-filled order is supported).\"},\"getNonce(address)\":{\"notice\":\"Retrieve the current nonce for a given offerer.\"},\"getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256))\":{\"notice\":\"Retrieve the order hash for a given order.\"},\"getOrderStatus(bytes32)\":{\"notice\":\"Retrieve the status of a given order by hash, including whether         the order has been cancelled or validated and the fraction of the         order that has been filled.\"},\"incrementNonce()\":{\"notice\":\"Cancel all orders from a given offerer with a given zone in bulk         by incrementing a nonce. Note that only the offerer may increment         the nonce.\"},\"matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"notice\":\"Match an arbitrary number of full or partial orders, each with an         arbitrary number of items for offer and consideration, supplying         criteria resolvers containing specific token identifiers and         associated proofs as well as fulfillments allocating offer         components to consideration components.\"},\"matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"notice\":\"Match an arbitrary number of orders, each with an arbitrary         number of items for offer and consideration along with a set of         fulfillments allocating offer components to consideration         components. Note that this function does not support         criteria-based or partial filling of orders (though filling the         remainder of a partially-filled order is supported).\"},\"name()\":{\"notice\":\"Retrieve the name of this contract.\"},\"validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[])\":{\"notice\":\"Validate an arbitrary number of orders, thereby registering them         as valid and allowing the fulfiller to skip verification. Note         that anyone can validate a signed order but only the offerer can         validate an order without supplying a signature.\"},\"version()\":{\"notice\":\"Retrieve the version of this contract.\"}},\"notice\":\"Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.         It minimizes external calls to the greatest extent possible and         provides lightweight methods for common routes as well as more         flexible methods for composing advanced orders or groups of orders.         Each order contains an arbitrary number of items that may be spent         (the \\\"offer\\\") along with an arbitrary number of items that must be         received back by the indicated recipients (the \\\"consideration\\\").\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Consideration.sol\":\"Consideration\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/Consideration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// prettier-ignore\\nimport {\\n    ConsiderationInterface\\n} from \\\"./interfaces/ConsiderationInterface.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    OrderType,\\n    ItemType,\\n    BasicOrderRouteType\\n} from \\\"./lib/ConsiderationEnums.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    BasicOrderParameters,\\n    OfferItem,\\n    ConsiderationItem,\\n    OrderParameters,\\n    OrderComponents,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver,\\n    BatchExecution\\n} from \\\"./lib/ConsiderationStructs.sol\\\";\\n\\nimport { ConsiderationInternal } from \\\"./lib/ConsiderationInternal.sol\\\";\\n\\n/**\\n * @title Consideration\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @custom:version rc-1\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\n *         It minimizes external calls to the greatest extent possible and\\n *         provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders or groups of orders.\\n *         Each order contains an arbitrary number of items that may be spent\\n *         (the \\\"offer\\\") along with an arbitrary number of items that must be\\n *         received back by the indicated recipients (the \\\"consideration\\\").\\n */\\ncontract Consideration is ConsiderationInterface, ConsiderationInternal {\\n    /**\\n     * @notice Derive and set hashes, reference chainId, and associated domain\\n     *         separator during deployment.\\n     *\\n     * @param legacyProxyRegistry         A proxy registry that stores per-user\\n     *                                    proxies that may optionally be used to\\n     *                                    transfer approved ERC721+1155 tokens.\\n     * @param legacyTokenTransferProxy    A shared proxy contract that may\\n     *                                    optionally be used to transfer\\n     *                                    approved ERC20 tokens.\\n     * @param requiredProxyImplementation The implementation that must be set on\\n     *                                    each proxy in order to utilize it.\\n     */\\n    constructor(\\n        address legacyProxyRegistry,\\n        address legacyTokenTransferProxy,\\n        address requiredProxyImplementation\\n    )\\n        ConsiderationInternal(\\n            legacyProxyRegistry,\\n            legacyTokenTransferProxy,\\n            requiredProxyImplementation\\n        )\\n    {}\\n\\n    /**\\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\\n     *         item, or an ERC1155 item as consideration. Six permutations are\\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\\n     *         be eligible for fulfillment via this method, it must contain a\\n     *         single offer item (though that item may have a greater amount if\\n     *         the item is not an ERC721). An arbitrary number of \\\"additional\\n     *         recipients\\\" may also be supplied which will each receive native\\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\\n     *         to the documentation for a more comprehensive summary of how to\\n     *         utilize with this method and what orders are compatible with it.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer and the fulfiller must first approve\\n     *                   this contract (or their chosen conduit if indicated)\\n     *                   before any tokens can be transferred. Also note that\\n     *                   contract recipients of ERC1155 consideration items must\\n     *                   implement `onERC1155Received` in order to receive those\\n     *                   items.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\n        external\\n        payable\\n        override\\n        returns (bool)\\n    {\\n        // Declare enums for order type & route to extract from basicOrderType.\\n        BasicOrderRouteType route;\\n        OrderType orderType;\\n\\n        // Declare additional recipient item type to derive from the route type.\\n        ItemType additionalRecipientsItemType;\\n\\n        // Utilize assembly to extract the order type and the basic order route.\\n        assembly {\\n            // Mask all but 2 least-significant bits to derive the order type.\\n            orderType := and(calldataload(0x124), 3)\\n\\n            // Divide basicOrderType by four to derive the route.\\n            route := div(calldataload(0x124), 4)\\n\\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\\n            additionalRecipientsItemType := gt(route, 1)\\n        }\\n\\n        {\\n            // Declare temporary variable for enforcing payable status.\\n            bool correctPayableStatus;\\n\\n            // Utilize assembly to compare the route to the callvalue.\\n            assembly {\\n                // route 0 and 1 are payable, otherwise route is not payable.\\n                correctPayableStatus := eq(\\n                    additionalRecipientsItemType,\\n                    iszero(callvalue())\\n                )\\n            }\\n\\n            // Revert if msg.value has not been supplied as part of payable\\n            // routes or has been supplied as part of non-payable routes.\\n            if (!correctPayableStatus) {\\n                revert InvalidMsgValue(msg.value);\\n            }\\n        }\\n\\n        // Declare more arguments that will be derived from route and calldata.\\n        address additionalRecipientsToken;\\n        ItemType receivedItemType;\\n        ItemType offeredItemType;\\n\\n        // Utilize assembly to retrieve function arguments and cast types.\\n        assembly {\\n            // Determine if offered item type == additional recipient item type.\\n            let offerTypeIsAdditionalRecipientsType := gt(route, 3)\\n\\n            // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24\\n            additionalRecipientsToken := calldataload(\\n                add(0x24, mul(0xa0, offerTypeIsAdditionalRecipientsType))\\n            )\\n\\n            // If route > 2, receivedItemType is route - 2. If route is 2, then\\n            // receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\\n            receivedItemType := add(\\n                mul(sub(route, 2), gt(route, 2)),\\n                eq(route, 2)\\n            )\\n\\n            // If route > 3, offeredItemType is ERC20 (1). If route is 2 or 3,\\n            // offeredItemType = route. If route is 0 or 1, it is route + 2.\\n            offeredItemType := sub(\\n                add(route, mul(iszero(additionalRecipientsItemType), 2)),\\n                mul(\\n                    offerTypeIsAdditionalRecipientsType,\\n                    add(receivedItemType, 1)\\n                )\\n            )\\n        }\\n\\n        // Derive & validate order using parameters and update order status.\\n        _prepareBasicFulfillmentFromCalldata(\\n            parameters,\\n            orderType,\\n            receivedItemType,\\n            additionalRecipientsItemType,\\n            additionalRecipientsToken,\\n            offeredItemType\\n        );\\n\\n        // Read offerer from calldata and place on the stack.\\n        address payable offerer = parameters.offerer;\\n\\n        // Declare conduit argument used by transfer functions.\\n        address conduit;\\n\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\n        assembly {\\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\\n            conduit := calldataload(add(0x1c4, mul(gt(route, 3), 0x20)))\\n        }\\n\\n        // Transfer tokens based on the route.\\n        if (route == BasicOrderRouteType.ETH_TO_ERC721) {\\n            // Transfer ERC721 to caller using offerer's conduit if applicable.\\n            _transferERC721(\\n                parameters.offerToken,\\n                offerer,\\n                msg.sender,\\n                parameters.offerIdentifier,\\n                parameters.offerAmount,\\n                conduit\\n            );\\n\\n            // Transfer native to recipients, return excess to caller & wrap up.\\n            _transferEthAndFinalize(parameters.considerationAmount, parameters);\\n        } else if (route == BasicOrderRouteType.ETH_TO_ERC1155) {\\n            // Transfer ERC1155 to caller using offerer's conduit if applicable.\\n            _transferERC1155(\\n                parameters.offerToken,\\n                offerer,\\n                msg.sender,\\n                parameters.offerIdentifier,\\n                parameters.offerAmount,\\n                conduit\\n            );\\n\\n            // Transfer native to recipients, return excess to caller & wrap up.\\n            _transferEthAndFinalize(parameters.considerationAmount, parameters);\\n        } else if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\\n            // Transfer ERC721 to caller using offerer's conduit if applicable.\\n            _transferERC721(\\n                parameters.offerToken,\\n                offerer,\\n                msg.sender,\\n                parameters.offerIdentifier,\\n                parameters.offerAmount,\\n                conduit\\n            );\\n\\n            // Transfer ERC20 tokens to all recipients and wrap up.\\n            _transferERC20AndFinalize(\\n                msg.sender,\\n                offerer,\\n                parameters.considerationToken,\\n                parameters.considerationAmount,\\n                parameters,\\n                false // Send full amount indicated by all consideration items.\\n            );\\n        } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\\n            // Transfer ERC1155 to caller using offerer's conduit if applicable.\\n            _transferERC1155(\\n                parameters.offerToken,\\n                offerer,\\n                msg.sender,\\n                parameters.offerIdentifier,\\n                parameters.offerAmount,\\n                conduit\\n            );\\n\\n            // Transfer ERC20 tokens to all recipients and wrap up.\\n            _transferERC20AndFinalize(\\n                msg.sender,\\n                offerer,\\n                parameters.considerationToken,\\n                parameters.considerationAmount,\\n                parameters,\\n                false // Send full amount indicated by all consideration items.\\n            );\\n        } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\\n            // Transfer ERC721 to offerer using caller's conduit if applicable.\\n            _transferERC721(\\n                parameters.considerationToken,\\n                msg.sender,\\n                offerer,\\n                parameters.considerationIdentifier,\\n                parameters.considerationAmount,\\n                conduit\\n            );\\n\\n            // Transfer ERC20 tokens to all recipients and wrap up.\\n            _transferERC20AndFinalize(\\n                offerer,\\n                msg.sender,\\n                parameters.offerToken,\\n                parameters.offerAmount,\\n                parameters,\\n                true // Reduce amount sent to fulfiller by additional amounts.\\n            );\\n        } else {\\n            // route == BasicOrderRouteType.ERC1155_TO_ERC20\\n\\n            // Transfer ERC1155 to offerer using caller's conduit if applicable.\\n            _transferERC1155(\\n                parameters.considerationToken,\\n                msg.sender,\\n                offerer,\\n                parameters.considerationIdentifier,\\n                parameters.considerationAmount,\\n                conduit\\n            );\\n\\n            // Transfer ERC20 tokens to all recipients and wrap up.\\n            _transferERC20AndFinalize(\\n                offerer,\\n                msg.sender,\\n                parameters.offerToken,\\n                parameters.offerAmount,\\n                parameters,\\n                true // Reduce amount sent to fulfiller by additional amounts.\\n            );\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order            The order to fulfill. Note that both the offerer\\n     *                         and the fulfiller must first approve this\\n     *                         contract (or the supplied conduit if indicated)\\n     *                         to transfer any relevant tokens on their behalf\\n     *                         and that contracts must implement\\n     *                         `onERC1155Received` in order to receive ERC1155\\n     *                         tokens as consideration.\\n     * @param fulfillerConduit An address indicating what conduit, if any, to\\n     *                         source the fulfiller's token approvals from. The\\n     *                         null address signifies that no conduit should be\\n     *                         used (and direct approvals set on Consideration)\\n     *                         and `address(1)` signifies to utilize the legacy\\n     *                         user proxy for the fulfiller.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function fulfillOrder(Order calldata order, address fulfillerConduit)\\n        external\\n        payable\\n        override\\n        returns (bool)\\n    {\\n        // Convert order to \\\"advanced\\\" order, then validate and fulfill it.\\n        // prettier-ignore\\n        return _validateAndFulfillAdvancedOrder(\\n            _convertOrderToAdvanced(order),\\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\\n            fulfillerConduit\\n        );\\n    }\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder     The order to fulfill along with the fraction of\\n     *                          the order to attempt to fill. Note that both the\\n     *                          offerer and the fulfiller must first approve\\n     *                          this contract (or their proxy if indicated by\\n     *                          the order) to transfer any relevant tokens on\\n     *                          their behalf and that contracts must implement\\n     *                          `onERC1155Received` in order to receive ERC1155\\n     *                          tokens as consideration. Also note that all\\n     *                          offer and consideration components must have no\\n     *                          remainder after multiplication of the respective\\n     *                          amount with the supplied fraction in order for\\n     *                          the partial fill to be considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific offer or consideration, a token\\n     *                          identifier, and a proof that the supplied token\\n     *                          identifier is contained in the merkle root held\\n     *                          by the item in question's criteria element. Note\\n     *                          that an empty criteria indicates that any\\n     *                          (transferrable) token identifier on the token in\\n     *                          question is valid and that no associated proof\\n     *                          needs to be supplied.\\n     * @param fulfillerConduit  An address indicating what conduit, if any, to\\n     *                          source the fulfiller's token approvals from. The\\n     *                          null address signifies that no conduit should be\\n     *                          used (and direct approvals set on Consideration)\\n     *                          and `address(1)` signifies to utilize the legacy\\n     *                          user proxy for the fulfiller.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        address fulfillerConduit\\n    ) external payable override returns (bool) {\\n        // Validate and fulfill the order.\\n        return\\n            _validateAndFulfillAdvancedOrder(\\n                advancedOrder,\\n                criteriaResolvers,\\n                fulfillerConduit\\n            );\\n    }\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their proxy if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferrable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduit          An address indicating what conduit, if\\n     *                                  any, to source the fulfiller's token\\n     *                                  approvals from. The null address\\n     *                                  signifies that no conduit should be used\\n     *                                  (with direct token approvals set on\\n     *                                  Consideration) and `address(1)`\\n     *                                  signifies to utilize the legacy user\\n     *                                  proxy for the fulfiller.\\n     *\\n     * @return availableOrders    An array of booleans indicating if each order\\n     *                            with an index corresponding to the index of\\n     *                            the returned boolean was fulfillable or not.\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        FulfillmentComponent[][] memory offerFulfillments,\\n        FulfillmentComponent[][] memory considerationFulfillments,\\n        address fulfillerConduit\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            bool[] memory availableOrders,\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Validate orders, apply amounts, & determine if they utilize conduits.\\n        _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            criteriaResolvers,\\n            false // Signifies that invalid orders should NOT revert.\\n        );\\n\\n        // Aggregate used offer and consideration items and execute transfers.\\n        (\\n            availableOrders,\\n            standardExecutions,\\n            batchExecutions\\n        ) = _fulfillAvailableOrders(\\n            advancedOrders,\\n            offerFulfillments,\\n            considerationFulfillments,\\n            fulfillerConduit\\n        );\\n\\n        // Return order fulfillment details and executions.\\n        return (availableOrders, standardExecutions, batchExecutions);\\n    }\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported).\\n     *\\n     * @param orders            The orders to match. Note that both the offerer\\n     *                          and fulfiller on each order must first approve\\n     *                          this contract (or their proxy if indicated by\\n     *                          the order) to transfer any relevant tokens on\\n     *                          their behalf and each consideration recipient\\n     *                          must implement `onERC1155Received` in order to\\n     *                          receive ERC1155 tokens.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Convert orders to \\\"advanced\\\" orders.\\n        AdvancedOrder[] memory advancedOrders = _convertOrdersToAdvanced(\\n            orders\\n        );\\n\\n        // Validate orders, apply amounts, & determine if they utilize proxies.\\n        _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\\n            true // Signifies that invalid orders should revert.\\n        );\\n\\n        // Fulfill the orders using the supplied fulfillments.\\n        return _fulfillAdvancedOrders(advancedOrders, fulfillments);\\n    }\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components.\\n     *\\n     * @param advancedOrders    The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or their proxy if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order toreceive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferrable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Validate orders, apply amounts, & determine if they utilize conduits.\\n        _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            criteriaResolvers,\\n            true // Signifies that invalid orders should revert.\\n        );\\n\\n        // Fulfill the orders using the supplied fulfillments.\\n        return _fulfillAdvancedOrders(advancedOrders, fulfillments);\\n    }\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     * or the zone of a given order may cancel it.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return A boolean indicating whether the supplied orders were\\n     *         successfully cancelled.\\n     */\\n    function cancel(OrderComponents[] calldata orders)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        address offerer;\\n        address zone;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Read length of the orders array from memory and place on stack.\\n            uint256 totalOrders = orders.length;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ) {\\n                // Retrieve the order.\\n                OrderComponents calldata order = orders[i];\\n\\n                offerer = order.offerer;\\n                zone = order.zone;\\n\\n                // Ensure caller is either offerer or zone of the order.\\n                if (msg.sender != offerer && msg.sender != zone) {\\n                    revert InvalidCanceller();\\n                }\\n\\n                // Derive order hash using the order parameters and the nonce.\\n                bytes32 orderHash = _getOrderHash(\\n                    OrderParameters(\\n                        offerer,\\n                        zone,\\n                        order.offer,\\n                        order.consideration,\\n                        order.orderType,\\n                        order.startTime,\\n                        order.endTime,\\n                        order.zoneHash,\\n                        order.salt,\\n                        order.conduit,\\n                        order.consideration.length\\n                    ),\\n                    order.nonce\\n                );\\n\\n                // Update the order status as not valid and cancelled.\\n                _orderStatus[orderHash].isValidated = false;\\n                _orderStatus[orderHash].isCancelled = true;\\n\\n                // Emit an event signifying that the order has been cancelled.\\n                emit OrderCancelled(orderHash, offerer, zone);\\n\\n                // Increment counter inside body of loop for gas efficiency.\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering them\\n     *         as valid and allowing the fulfiller to skip verification. Note\\n     *         that anyone can validate a signed order but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return A boolean indicating whether the supplied orders were\\n     *         successfully validated.\\n     */\\n    function validate(Order[] calldata orders)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // Declare variables outside of the loop.\\n        bytes32 orderHash;\\n        address offerer;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Read length of the orders array from memory and place on stack.\\n            uint256 totalOrders = orders.length;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ) {\\n                // Retrieve the order.\\n                Order calldata order = orders[i];\\n\\n                // Retrieve the order parameters.\\n                OrderParameters calldata orderParameters = order.parameters;\\n\\n                // Move offerer from memory to the stack.\\n                offerer = orderParameters.offerer;\\n\\n                // Get current nonce and use it w/ params to derive order hash.\\n                orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\\n                    orderParameters\\n                );\\n\\n                // Retrieve the order status using the derived order hash.\\n                OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n                // Ensure order is fillable and retrieve the filled amount.\\n                _verifyOrderStatus(\\n                    orderHash,\\n                    orderStatus,\\n                    false, // Signifies that partially filled orders are valid.\\n                    true // Signifies to revert if the order is invalid.\\n                );\\n\\n                // If the order has not already been validated...\\n                if (!orderStatus.isValidated) {\\n                    // Verify the supplied signature.\\n                    _verifySignature(offerer, orderHash, order.signature);\\n\\n                    // Update order status to mark the order as valid.\\n                    _orderStatus[orderHash].isValidated = true;\\n\\n                    // Emit an event signifying the order has been validated.\\n                    emit OrderValidated(\\n                        orderHash,\\n                        offerer,\\n                        orderParameters.zone\\n                    );\\n                }\\n\\n                // Increment counter inside body of the loop for gas efficiency.\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a nonce. Note that only the offerer may increment\\n     *         the nonce.\\n     *\\n     * @return newNonce The new nonce.\\n     */\\n    function incrementNonce() external override returns (uint256 newNonce) {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // No need to check for overflow; nonce cannot be incremented that far.\\n        unchecked {\\n            // Increment current nonce for the supplied offerer.\\n            newNonce = ++_nonces[msg.sender];\\n        }\\n\\n        // Emit an event containing the new nonce.\\n        emit NonceIncremented(newNonce, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return The order hash.\\n     */\\n    function getOrderHash(OrderComponents memory order)\\n        external\\n        view\\n        override\\n        returns (bytes32)\\n    {\\n        // Derive order hash by supplying order parameters along with the nonce.\\n        // prettier-ignore\\n        return _getOrderHash(\\n            OrderParameters(\\n                order.offerer,\\n                order.zone,\\n                order.offer,\\n                order.consideration,\\n                order.orderType,\\n                order.startTime,\\n                order.endTime,\\n                order.zoneHash,\\n                order.salt,\\n                order.conduit,\\n                order.consideration.length\\n            ),\\n            order.nonce\\n        );\\n    }\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(bytes32 orderHash)\\n        external\\n        view\\n        override\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        )\\n    {\\n        // Retrieve the order status using the order hash.\\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n        // Return the fields on the order status.\\n        return (\\n            orderStatus.isValidated,\\n            orderStatus.isCancelled,\\n            orderStatus.numerator,\\n            orderStatus.denominator\\n        );\\n    }\\n\\n    /**\\n     * @notice Retrieve the current nonce for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return The current nonce.\\n     */\\n    function getNonce(address offerer)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        // Return the nonce for the supplied offerer.\\n        return _nonces[offerer];\\n    }\\n\\n    /**\\n     * @notice Retrieve the domain separator, used for signing and verifying\\n     * signed orders via EIP-712.\\n     *\\n     * @return The domain separator.\\n     */\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        // Get domain separator, either precomputed or derived based on chainId.\\n        return _domainSeparator();\\n    }\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function name() external pure override returns (string memory) {\\n        // Return the name of the contract.\\n        return _NAME;\\n    }\\n\\n    /**\\n     * @notice Retrieve the version of this contract.\\n     *\\n     * @return The version of this contract.\\n     */\\n    function version() external pure override returns (string memory) {\\n        // Return the version.\\n        return _VERSION;\\n    }\\n}\\n\",\"keccak256\":\"0x79b6becc7cae7f5a2d7e49d832279c82d47ba5e785a1e07ce73490514cc07418\",\"license\":\"MIT\"},\"contracts/interfaces/AbridgedProxyInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface ProxyRegistryInterface {\\n    function proxies(address user) external view returns (address proxy);\\n}\\n\\ninterface ProxyInterface {\\n    function proxyAssert(\\n        address dest,\\n        uint8 howToCall,\\n        bytes calldata callData\\n    ) external;\\n\\n    function implementation() external view returns (address);\\n}\\n\\ninterface TokenTransferProxyInterface {\\n    function transferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4efdc90d1876072ad30eb86a5b4281d32b63f0fc45216531dfa32973d206e3e8\",\"license\":\"MIT\"},\"contracts/interfaces/AbridgedTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface ERC20Interface {\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\\ninterface ERC721Interface {\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\ninterface ERC1155Interface {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x46b326283a731814cae75cae1fe4ff78caf5125743feee713dac56996bc356bc\",\"license\":\"MIT\"},\"contracts/interfaces/ConsiderationEventsAndErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { Side } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationEventsAndErrors\\n * @author 0age\\n * @notice ConsiderationEventsAndErrors contains all events and errors.\\n */\\ninterface ConsiderationEventsAndErrors {\\n    /**\\n     * @dev Emit an event whenever an order is successfully fulfilled.\\n     *\\n     * @param orderHash     The hash of the fulfilled order.\\n     * @param offerer       The offerer of the fulfilled order.\\n     * @param zone          The zone of the fulfilled order.\\n     * @param fulfiller     The fulfiller of the order, or the null address if\\n     *                      there is no specific fulfiller (i.e. the order is\\n     *                      part of a group of orders).\\n     * @param offer         The offer items spent as part of the order.\\n     * @param consideration The consideration items received as part of the\\n     *                      order along with the recipients of each item.\\n     */\\n    event OrderFulfilled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone,\\n        address fulfiller,\\n        SpentItem[] offer,\\n        ReceivedItem[] consideration\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is successfully cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     * @param offerer   The offerer of the cancelled order.\\n     * @param zone      The zone of the cancelled order.\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is explicitly validated. Note that\\n     *      this event will not be emitted on partial fills even though they do\\n     *      validate the order as part of partial fulfillment.\\n     *\\n     * @param orderHash The hash of the validated order.\\n     * @param offerer   The offerer of the validated order.\\n     * @param zone      The zone of the validated order.\\n     */\\n    event OrderValidated(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a nonce for a given offerer is incremented.\\n     *\\n     * @param newNonce The new nonce for the offerer.\\n     * @param offerer  The offerer in question.\\n     */\\n    event NonceIncremented(uint256 newNonce, address indexed offerer);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has\\n     *      already been fully filled.\\n     *\\n     * @param orderHash The order hash on which a fill was attempted.\\n     */\\n    error OrderAlreadyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order outside the\\n     *      specified start time and end time .\\n     */\\n    error InvalidTime();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that specifies\\n     *      a restricted submitter as its order type when not submitted by\\n     *      either the offerrer or the order's zone or approved as valid by the\\n     *      zone in question via a staticcall to `isValidOrder`.\\n     *\\n     * @param orderHash The order hash for the invalid restricted order.\\n     */\\n    error InvalidRestrictedOrder(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when an order is supplied for fulfillment with\\n     *      a consideration array that is shorter than the original array.\\n     */\\n    error MissingOriginalConsiderationItems();\\n\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided as part of an\\n     *      call to fulfill available orders that does not declare at least one\\n     *      component.\\n     */\\n    error MissingFulfillmentComponentOnAggregation(Side side);\\n\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided that does not\\n     *      declare at least one offer component and at least one consideration\\n     *      component.\\n     */\\n    error OfferAndConsiderationRequiredOnFulfillment();\\n\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided with an index\\n     *      that references an order or item that has not been supplied.\\n     */\\n    error FulfilledOrderIndexOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when a signature that does not contain a v\\n     *      value of 27 or 28 has been supplied.\\n     *\\n     * @param v The invalid v value.\\n     */\\n    error BadSignatureV(uint8 v);\\n\\n    /**\\n     * @dev Revert with an error when the signer recovered by the supplied\\n     *      signature does not match the offerer or an allowed EIP-1271 signer\\n     *      as specified by the offerer in the event they are a contract.\\n     */\\n    error InvalidSigner();\\n\\n    /**\\n     * @dev Revert with an error when a signer cannot be recovered from the\\n     *      supplied signature.\\n     */\\n    error InvalidSignature();\\n\\n    /**\\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\\n     */\\n    error BadContractSignature();\\n\\n    /**\\n     * @dev Revert with an error when the initial offer item named by a\\n     *      fulfillment component does not match the type, token, identifier,\\n     *      or conduit preference of the initial consideration item.\\n     */\\n    error MismatchedFulfillmentOfferAndConsiderationComponents();\\n\\n    /**\\n     * @dev Revert with an error when an order or item index are out of range\\n     *      or a fulfillment component does not match the type, token,\\n     *      identifier, or conduit preference of the initial consideration item.\\n     */\\n    error InvalidFulfillmentComponentData();\\n\\n    /**\\n     * @dev Revert with an error if a consideration amount has not been fully\\n     *      zeroed out after applying all fulfillments.\\n     *\\n     * @param orderIndex         The index of the order with the consideration\\n     *                           item with a shortfall.\\n     * @param considerationIndex The index of the consideration item on the\\n     *                           order.\\n     * @param shortfallAmount    The unfulfilled consideration amount.\\n     */\\n    error ConsiderationNotMet(\\n        uint256 orderIndex,\\n        uint256 considerationIndex,\\n        uint256 shortfallAmount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when insufficient ether is supplied as part of\\n     *      msg.value when fulfilling orders.\\n     */\\n    error InsufficientEtherSupplied();\\n\\n    /**\\n     * @dev Revert with an error when an ether transfer reverts.\\n     */\\n    error EtherTransferGenericFailure(address account, uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n\\n    /**\\n     * @dev Revert with an error when a partial fill is attempted on an order\\n     *      that does not specify partial fill support in its order type.\\n     */\\n    error PartialFillsNotEnabledForOrder();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has been\\n     *      cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     */\\n    error OrderIsCancelled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order that has\\n     *      been partially filled.\\n     *\\n     * @param orderHash The hash of the partially used order.\\n     */\\n    error OrderPartiallyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order that has not been supplied.\\n     */\\n    error OrderCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error if an offer item still has unresolved criteria\\n     *      after applying all criteria resolvers.\\n     */\\n    error UnresolvedOfferCriteria();\\n\\n    /**\\n     * @dev Revert with an error if a consideration item still has unresolved\\n     *      criteria after applying all criteria resolvers.\\n     */\\n    error UnresolvedConsiderationCriteria();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with an offer item that has not been supplied.\\n     */\\n    error OfferCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with a consideration item that has not been supplied.\\n     */\\n    error ConsiderationCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with an item that does not expect a criteria to be\\n     *      resolved.\\n     */\\n    error CriteriaNotEnabledForItem();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that\\n     *      contains an invalid proof with respect to the given item and\\n     *      chosen identifier.\\n     */\\n    error InvalidProof();\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel an order as a caller\\n     *      other than the indicated offerer or zone.\\n     */\\n    error InvalidCanceller();\\n\\n    /**\\n     * @dev Revert with an error when supplying a fraction with a value of zero\\n     *      for the numerator or denominator, or one where the numerator exceeds\\n     *      the denominator.\\n     */\\n    error BadFraction();\\n\\n    /**\\n     * @dev Revert with an error when attempting to apply a fraction as part of\\n     *      a partial fill that does not divide the target amount cleanly.\\n     */\\n    error InexactFraction();\\n\\n    /**\\n     * @dev Revert with an error when a caller attempts to reenter a protected\\n     *      function.\\n     */\\n    error NoReentrantCalls();\\n\\n    /**\\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\\n     *      non-payable basic order route or does not supply any callvalue to a\\n     *      payable basic order route.\\n     */\\n    error InvalidMsgValue(uint256 value);\\n\\n    /**\\n     * @dev Revert with an error when the implementation of the respective\\n     *      legacy user proxy does not match the expected proxy implementation.\\n     */\\n    error InvalidProxyImplementation();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order using\\n     *      calldata not produced by default ABI encoding.\\n     */\\n    error InvalidBasicOrderParameterEncoding();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill any number of\\n     *      available orders when none are fulfillable.\\n     */\\n    error NoSpecifiedOrdersAvailable();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n}\\n\",\"keccak256\":\"0x514f95a460521fa4b4c2c86a5cda4d3df34370199da9a77a3235f9f874b737d7\",\"license\":\"MIT\"},\"contracts/interfaces/ConsiderationInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// prettier-ignore\\nimport {\\n    BasicOrderParameters,\\n    OrderComponents,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    BatchExecution,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationInterface\\n * @author 0age\\n * @custom:version 1\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\n *         It minimizes external calls to the greatest extent possible and\\n *         provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders.\\n *\\n * @dev ConsiderationInterface contains all external function interfaces for\\n *      Consideration.\\n */\\ninterface ConsiderationInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their proxy if indicated by the order) in order for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\n        external\\n        payable\\n        returns (bool);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order             The order to fulfill. Note that both the offerer\\n     *                          and the fulfiller must first approve this\\n     *                          contract (or their proxy if indicated by the\\n     *                          order) to transfer any relevant tokens on their\\n     *                          behalf and that contracts must implement\\n     *                          `onERC1155Received` in order to receive ERC1155\\n     *                          tokens as consideration.\\n     * @param fulfillerConduit A flag indicating whether to source approvals\\n     *                          for fulfilled tokens from an associated proxy.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function fulfillOrder(Order calldata order, address fulfillerConduit)\\n        external\\n        payable\\n        returns (bool);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder     The order to fulfill along with the fraction of\\n     *                          the order to attempt to fill. Note that both the\\n     *                          offerer and the fulfiller must first approve\\n     *                          this contract (or their proxy if indicated by\\n     *                          the order) to transfer any relevant tokens on\\n     *                          their behalf and that contracts must implement\\n     *                          `onERC1155Received` in order to receive ERC1155\\n     *                          tokens as consideration. Also note that all\\n     *                          offer and consideration components must have no\\n     *                          remainder after multiplication of the respective\\n     *                          amount with the supplied fraction in order for\\n     *                          the partial fill to be considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific offer or consideration, a token\\n     *                          identifier, and a proof that the supplied token\\n     *                          identifier is contained in the merkle root held\\n     *                          by the item in question's criteria element. Note\\n     *                          that an empty criteria indicates that any\\n     *                          (transferrable) token identifier on the token in\\n     *                          question is valid and that no associated proof\\n     *                          needs to be supplied.\\n     * @param fulfillerConduit A flag indicating whether to source approvals\\n     *                          for fulfilled tokens from an associated proxy.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        address fulfillerConduit\\n    ) external payable returns (bool);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their proxy if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferrable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduit         A flag indicating whether to source\\n     *                                  approvals for fulfilled tokens from an\\n     *                                  associated proxy.\\n     *\\n     * @return availableOrders    An array of booleans indicating if each order\\n     *                            with an index corresponding to the index of\\n     *                            the returned boolean was fulfillable or not.\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        address fulfillerConduit\\n    )\\n        external\\n        payable\\n        returns (\\n            bool[] memory availableOrders,\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        );\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with as set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported).\\n     *\\n     * @param orders            The orders to match. Note that both the offerer\\n     *                          and fulfiller on each order must first approve\\n     *                          this contract (or their proxy if indicated by\\n     *                          the order) to transfer any relevant tokens on\\n     *                          their behalf and each consideration recipient\\n     *                          must implement `onERC1155Received` in order to\\n     *                          receive ERC1155 tokens.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        external\\n        payable\\n        returns (\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        );\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or their proxy if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order toreceive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferrable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        external\\n        payable\\n        returns (\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        );\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     * or the zone of a given order may cancel it.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return A boolean indicating whether the supplied orders were\\n     *         successfully cancelled.\\n     */\\n    function cancel(OrderComponents[] calldata orders) external returns (bool);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering them\\n     *         as valid and allowing the fulfiller to skip verification. Note\\n     *         that anyone can validate a signed order but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return A boolean indicating whether the supplied orders were\\n     *         successfully validated.\\n     */\\n    function validate(Order[] calldata orders) external returns (bool);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a nonce. Note that only the offerer may increment\\n     *         the nonce.\\n     *\\n     * @return newNonce The new nonce.\\n     */\\n    function incrementNonce() external returns (uint256 newNonce);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return The order hash.\\n     */\\n    function getOrderHash(OrderComponents calldata order)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(bytes32 orderHash)\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current nonce for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return The current nonce.\\n     */\\n    function getNonce(address offerer) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Retrieve the version of this contract.\\n     *\\n     * @return The version of this contract.\\n     */\\n    function version() external view returns (string memory);\\n\\n    /**\\n     * @notice Retrieve the domain separator, used for signing and verifying\\n     * signed orders via EIP-712.\\n     *\\n     * @return The domain separator.\\n     */\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xbd6cdc9bb5a29386f8506db5bcfc5ef2d3f76e8027507bd6f115ccbf8e27b0c1\",\"license\":\"MIT\"},\"contracts/interfaces/EIP1271Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface EIP1271Interface {\\n    function isValidSignature(bytes32 digest, bytes calldata signature)\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\",\"keccak256\":\"0x59a9fe120f65dde5249cc4f91b1512223c88f6048e5e78aefc258dc8a19c71b2\",\"license\":\"MIT\"},\"contracts/interfaces/ZoneInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { AdvancedOrder } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ninterface ZoneInterface {\\n    // Called by Consideration whenever extraData is not provided by the caller.\\n    function isValidOrder(\\n        bytes32 orderHash,\\n        address caller,\\n        address offerer,\\n        bytes32 zoneHash\\n    ) external view returns (bytes4 validOrderMagicValue);\\n\\n    // Called by Consideration whenever any extraData is provided by the caller.\\n    function isValidOrderIncludingExtraData(\\n        bytes32 orderHash,\\n        address caller,\\n        AdvancedOrder calldata order,\\n        bytes32[] calldata priorOrderHashes\\n    ) external view returns (bytes4 validOrderMagicValue);\\n}\\n\",\"keccak256\":\"0x493d5b475aa8a9fef53deb425028ced798c3a2a3d47cb9a0fc0cafe6bdbd5db6\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// prettier-ignore\\nimport {\\n    ProxyRegistryInterface,\\n    TokenTransferProxyInterface\\n} from \\\"../interfaces/AbridgedProxyInterfaces.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    ConsiderationEventsAndErrors\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\n\\nimport { OrderStatus } from \\\"./ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationBase\\n * @author 0age\\n * @notice ConsiderationBase contains all storage, constants, and constructor\\n *         logic.\\n */\\ncontract ConsiderationBase is ConsiderationEventsAndErrors {\\n    // Declare constants for name, version, and reentrancy sentinel values.\\n    string internal constant _NAME = \\\"Consideration\\\";\\n    string internal constant _VERSION = \\\"rc.1\\\";\\n    uint256 internal constant _NOT_ENTERED = 1;\\n    uint256 internal constant _ENTERED = 2;\\n\\n    // Precompute hashes, original chainId, and domain separator on deployment.\\n    bytes32 internal immutable _NAME_HASH;\\n    bytes32 internal immutable _VERSION_HASH;\\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\\n    bytes32 internal immutable _ORDER_TYPEHASH;\\n    uint256 internal immutable _CHAIN_ID;\\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\\n\\n    // Allow for interaction with user proxies on the legacy proxy registry.\\n    ProxyRegistryInterface internal immutable _LEGACY_PROXY_REGISTRY;\\n\\n    // Allow for interaction with the legacy token transfer proxy.\\n    TokenTransferProxyInterface internal immutable _LEGACY_TOKEN_TRANSFER_PROXY;\\n\\n    // Ensure that user proxies adhere to the required proxy implementation.\\n    address internal immutable _REQUIRED_PROXY_IMPLEMENTATION;\\n\\n    // Prevent reentrant calls on protected functions.\\n    uint256 internal _reentrancyGuard;\\n\\n    // Track status of each order (validated, cancelled, and fraction filled).\\n    mapping(bytes32 => OrderStatus) internal _orderStatus;\\n\\n    // Cancel all of a given offerer's orders signed with their current nonce.\\n    mapping(address => uint256) internal _nonces;\\n\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param legacyProxyRegistry         A proxy registry that stores per-user\\n     *                                    proxies that may optionally be used to\\n     *                                    transfer approved ERC721+1155 tokens.\\n     * @param legacyTokenTransferProxy    A shared proxy contract that may\\n     *                                    optionally be used to transfer\\n     *                                    approved ERC20 tokens.\\n     * @param requiredProxyImplementation The implementation that must be set on\\n     *                                    each proxy in order to utilize it.\\n     */\\n    constructor(\\n        address legacyProxyRegistry,\\n        address legacyTokenTransferProxy,\\n        address requiredProxyImplementation\\n    ) {\\n        // Derive hashes, reference chainId, and associated domain separator.\\n        _NAME_HASH = keccak256(bytes(_NAME));\\n        _VERSION_HASH = keccak256(bytes(_VERSION));\\n\\n        // prettier-ignore\\n        bytes memory offerItemTypeString = abi.encodePacked(\\n            \\\"OfferItem(\\\",\\n                \\\"uint8 itemType,\\\",\\n                \\\"address token,\\\",\\n                \\\"uint256 identifierOrCriteria,\\\",\\n                \\\"uint256 startAmount,\\\",\\n                \\\"uint256 endAmount\\\",\\n            \\\")\\\"\\n        );\\n        // prettier-ignore\\n        bytes memory considerationItemTypeString = abi.encodePacked(\\n            \\\"ConsiderationItem(\\\",\\n                \\\"uint8 itemType,\\\",\\n                \\\"address token,\\\",\\n                \\\"uint256 identifierOrCriteria,\\\",\\n                \\\"uint256 startAmount,\\\",\\n                \\\"uint256 endAmount,\\\",\\n                \\\"address recipient\\\",\\n            \\\")\\\"\\n        );\\n        // prettier-ignore\\n        bytes memory orderComponentsPartialTypeString = abi.encodePacked(\\n            \\\"OrderComponents(\\\",\\n                \\\"address offerer,\\\",\\n                \\\"address zone,\\\",\\n                \\\"OfferItem[] offer,\\\",\\n                \\\"ConsiderationItem[] consideration,\\\",\\n                \\\"uint8 orderType,\\\",\\n                \\\"uint256 startTime,\\\",\\n                \\\"uint256 endTime,\\\",\\n                \\\"bytes32 zoneHash,\\\",\\n                \\\"uint256 salt,\\\",\\n                \\\"address conduit,\\\",\\n                \\\"uint256 nonce\\\",\\n            \\\")\\\"\\n        );\\n\\n        // prettier-ignore\\n        _EIP_712_DOMAIN_TYPEHASH = keccak256(\\n            abi.encodePacked(\\n                \\\"EIP712Domain(\\\",\\n                    \\\"string name,\\\",\\n                    \\\"string version,\\\",\\n                    \\\"uint256 chainId,\\\",\\n                    \\\"address verifyingContract\\\",\\n                \\\")\\\"\\n            )\\n        );\\n        _OFFER_ITEM_TYPEHASH = keccak256(offerItemTypeString);\\n        _CONSIDERATION_ITEM_TYPEHASH = keccak256(considerationItemTypeString);\\n        _ORDER_TYPEHASH = keccak256(\\n            abi.encodePacked(\\n                orderComponentsPartialTypeString,\\n                considerationItemTypeString,\\n                offerItemTypeString\\n            )\\n        );\\n        _CHAIN_ID = block.chainid;\\n        _DOMAIN_SEPARATOR = _deriveInitialDomainSeparator();\\n\\n        _LEGACY_PROXY_REGISTRY = ProxyRegistryInterface(legacyProxyRegistry);\\n        _LEGACY_TOKEN_TRANSFER_PROXY = TokenTransferProxyInterface(\\n            legacyTokenTransferProxy\\n        );\\n        _REQUIRED_PROXY_IMPLEMENTATION = requiredProxyImplementation;\\n\\n        // Initialize the reentrancy guard in a cleared state.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the initial EIP-712 domain\\n     *      separator.\\n     *\\n     * @return The derived domain separator.\\n     */\\n    function _deriveInitialDomainSeparator()\\n        internal\\n        view\\n        virtual\\n        returns (bytes32)\\n    {\\n        return _deriveDomainSeparator();\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the EIP-712 domain separator.\\n     *\\n     * @return The derived domain separator.\\n     */\\n    function _deriveDomainSeparator() internal view virtual returns (bytes32) {\\n        // prettier-ignore\\n        return keccak256(\\n            abi.encode(\\n                _EIP_712_DOMAIN_TYPEHASH,\\n                _NAME_HASH,\\n                _VERSION_HASH,\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8149d4061704798cf302ef2a59933f79d1bb55868a133688dda127785ecf14a9\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\n// Common Offsets\\n// Offsets for identically positioned fields shared by:\\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\\n\\nuint256 constant Common_token_offset = 0x20;\\nuint256 constant Common_identifier_offset = 0x40;\\nuint256 constant Common_amount_offset = 0x60;\\n\\nuint256 constant ReceivedItem_size = 0xa0;\\nuint256 constant ReceivedItem_amount_offset = 0x60;\\nuint256 constant ReceivedItem_recipient_offset = 0x80;\\n\\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\\n// Store the same constant in an abbreviated format for a line length fix.\\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\\n\\nuint256 constant Execution_offerer_offset = 0x20;\\nuint256 constant Execution_conduit_offset = 0x40;\\n\\nuint256 constant OrderParameters_offer_head_offset = 0x40;\\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\\nuint256 constant OrderParameters_conduit_offset = 0x120;\\n\\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\\n\\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\\n\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant BasicOrder_endAmount_cdPtr = 0x104;\\n\\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\\n\\nuint256 constant EIP712_Order_size = 0x180;\\nuint256 constant EIP712_OfferItem_size = 0xc0;\\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\\nuint256 constant AdditionalRecipients_size = 0x40;\\n\\nuint256 constant receivedItemsHash_ptr = 0x60;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  data for OrderFulfilled\\n *\\n *   event OrderFulfilled(\\n *     bytes32 orderHash,\\n *     address indexed offerer,\\n *     address indexed zone,\\n *     address fulfiller,\\n *     SpentItem[] offer,\\n *       > (itemType, token, id, amount)\\n *     ReceivedItem[] consideration\\n *       > (itemType, token, id, amount, recipient)\\n *   )\\n *\\n *  - 0x00: orderHash\\n *  - 0x20: fulfiller\\n *  - 0x40: offer offset (0x80)\\n *  - 0x60: consideration offset (0x120)\\n *  - 0x80: offer.length (1)\\n *  - 0xa0: offerItemType\\n *  - 0xc0: offerToken\\n *  - 0xe0: offerIdentifier\\n *  - 0x100: offerAmount\\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\\n *  - 0x140: considerationItemType\\n *  - 0x160: considerationToken\\n *  - 0x180: considerationIdentifier\\n *  - 0x1a0: considerationAmount\\n *  - 0x1c0: considerationRecipient\\n *  - ...\\n */\\n\\n// Minimum length of the OrderFulfilled event data.\\n// Must be added to the size of the ReceivedItem array for additionalRecipients\\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\\nuint256 constant OrderFulfilled_selector = (\\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\\n);\\n\\n// Minimum offset in memory to OrderFulfilled event data.\\n// Must be added to the size of the EIP712 hash array for additionalRecipients\\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\\nuint256 constant OrderFulfilled_baseOffset = 0x180;\\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\\n\\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\\n\\n// BasicOrderParameters\\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\\n// uint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\\n// uint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\\n// uint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\\n// uint256 constant BasicOrder_endTime_cdPtr = 0x164;\\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\\n// uint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\\n// uint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\\n// uint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\\n// uint256 constant BasicOrder_signature_cdPtr = 0x244;\\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for ConsiderationItem\\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n *   - 0xa0: itemType\\n *   - 0xc0: token\\n *   - 0xe0: identifier\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n *   - 0x140: recipient\\n */\\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for OfferItem\\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n *   - 0xa0:  itemType\\n *   - 0xc0:  token\\n *   - 0xe0:  identifier (reused for offeredItemsHash)\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n */\\nuint256 constant BasicOrder_offerItem_typeHash_ptr = DefaultFreeMemoryPointer;\\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for Order\\n *   - 0x80:   Order EIP-712 typehash (constant)\\n *   - 0xa0:   orderParameters.offerer\\n *   - 0xc0:   orderParameters.zone\\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n *   - 0x120:  orderType\\n *   - 0x140:  startTime\\n *   - 0x160:  endTime\\n *   - 0x180:  zoneHash\\n *   - 0x1a0:  salt\\n *   - 0x1c0:  conduit\\n *   - 0x1e0:  _nonces[orderParameters.offerer] (from storage)\\n */\\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\\n// uint256 constant BasicOrder_order_conduit_ptr = 0x1c0;\\nuint256 constant BasicOrder_order_nonce_ptr = 0x1e0;\\n\\n// Signature-related\\nbytes32 constant EIP2098_allButHighestBitMask = (\\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n);\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 164\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\n// abi.encodeWithSignature(\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\n// )\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\n\\n// 4 + 32 * 5 == 164\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\n// abi.encodeWithSignature(\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\n// )\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\n\\n// 4 + 32 * 4 == 132\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\",\"keccak256\":\"0x65c42a3e59e33a17334db82413b7354d3f6ef9f01cd3abb5bdc2d44ae80cc910\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// prettier-ignore\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED\\n}\\n\\n// prettier-ignore\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED0,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\n// prettier-ignore\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\n// prettier-ignore\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\n// prettier-ignore\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n    \\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\",\"keccak256\":\"0x81b7737fd051499a84cf904ce6b2ad33d9c83954012226358d83c7e6cb423125\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    ERC20Interface,\\n    ERC721Interface,\\n    ERC1155Interface\\n} from \\\"../interfaces/AbridgedTokenInterfaces.sol\\\";\\n\\nimport { ProxyInterface } from \\\"../interfaces/AbridgedProxyInterfaces.sol\\\";\\n\\nimport { OrderType, ItemType } from \\\"./ConsiderationEnums.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    AdditionalRecipient,\\n    BasicOrderParameters,\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver,\\n    Batch,\\n    BatchExecution\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { ConsiderationInternalView } from \\\"./ConsiderationInternalView.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title ConsiderationInternal\\n * @author 0age\\n * @notice ConsiderationInternal contains all internal functions.\\n */\\ncontract ConsiderationInternal is ConsiderationInternalView {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param legacyProxyRegistry         A proxy registry that stores per-user\\n     *                                    proxies that may optionally be used to\\n     *                                    transfer approved ERC721+1155 tokens.\\n     * @param legacyTokenTransferProxy    A shared proxy contract that may\\n     *                                    optionally be used to transfer\\n     *                                    approved ERC20 tokens.\\n     * @param requiredProxyImplementation The implementation that must be set on\\n     *                                    each proxy in order to utilize it.\\n     */\\n    constructor(\\n        address legacyProxyRegistry,\\n        address legacyTokenTransferProxy,\\n        address requiredProxyImplementation\\n    )\\n        ConsiderationInternalView(\\n            legacyProxyRegistry,\\n            legacyTokenTransferProxy,\\n            requiredProxyImplementation\\n        )\\n    {}\\n\\n    /**\\n     * @dev Internal function to prepare fulfillment of a basic order with\\n     *      manual calldata and memory access. This calculates the order hash,\\n     *      emits an OrderFulfilled event, and asserts basic order validity.\\n     *      Note that calldata offsets must be validated as this function\\n     *      accesses constant calldata pointers for dynamic types that match\\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\\n     *      offsets. Checking that the offsets were produced by default encoding\\n     *      will ensure that other functions using Solidity's calldata accessors\\n     *      (which calculate pointers from the stored offsets) are reading the\\n     *      same data as the order hash is derived from. Also note that This\\n     *      function accesses memory directly. It does not clear the expanded\\n     *      memory regions used, nor does it update the free memory pointer, so\\n     *      other direct memory access must not assume that unused memory is\\n     *      empty.\\n     *\\n     * @param parameters                   The parameters of the basic order.\\n     * @param orderType                    The order type.\\n     * @param receivedItemType             The item type of the initial\\n     *                                     consideration item on the order.\\n     * @param additionalRecipientsItemType The item type of any additional\\n     *                                     consideration item on the order.\\n     * @param additionalRecipientsToken    The ERC20 token contract adddress (if\\n     *                                     applicable) for any additional\\n     *                                     consideration item on the order.\\n     * @param offeredItemType              The item type of the offered item on\\n     *                                     the order.\\n     */\\n    function _prepareBasicFulfillmentFromCalldata(\\n        BasicOrderParameters calldata parameters,\\n        OrderType orderType,\\n        ItemType receivedItemType,\\n        ItemType additionalRecipientsItemType,\\n        address additionalRecipientsToken,\\n        ItemType offeredItemType\\n    ) internal {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard();\\n\\n        // Ensure current timestamp falls between order start time and end time.\\n        _verifyTime(parameters.startTime, parameters.endTime, true);\\n\\n        // Verify that calldata offsets for all dynamic types were produced by\\n        // default encoding. This ensures that the constants we use for calldata\\n        // pointers to dynamic types are the same as those calculated by\\n        // Solidity using their offsets.\\n        _assertValidBasicOrderParameterOffsets();\\n\\n        // Ensure supplied consideration array length is not less than original.\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n            parameters.additionalRecipients.length + 1,\\n            parameters.totalOriginalAdditionalRecipients\\n        );\\n\\n        // Declare stack element for the order hash.\\n        bytes32 orderHash;\\n\\n        {\\n            /**\\n             * First, handle consideration items. Memory Layout:\\n             *  0x60: final hash of the array of consideration item hashes\\n             *  0x80-0x160: reused space for EIP712 hashing of each item\\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n             *   - 0xa0: itemType\\n             *   - 0xc0: token\\n             *   - 0xe0: identifier\\n             *   - 0x100: startAmount\\n             *   - 0x120: endAmount\\n             *   - 0x140: recipient\\n             *  0x160-END_ARR: array of consideration item hashes\\n             *   - 0x160: primary consideration item EIP712 hash\\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\\n             *  END_ARR: beginning of data for OrderFulfilled event\\n             *   - END_ARR + 0x120: length of ReceivedItem array\\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\\n             */\\n\\n            // Load consideration item typehash from runtime and place on stack.\\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\n\\n            // Utilize assembly to enable reuse of memory regions and use\\n            // constant pointers when possible.\\n            assembly {\\n                /*\\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\\n                 * primary consideration item of the basic order.\\n                 */\\n\\n                // Write ConsiderationItem type hash and item type to memory.\\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\\n                mstore(\\n                    BasicOrder_considerationItem_itemType_ptr,\\n                    receivedItemType\\n                )\\n\\n                // Copy calldata region with (token, identifier, amount) from\\n                // BasicOrderParameters to ConsiderationItem. The\\n                // considerationAmount is written to startAmount and endAmount\\n                // as basic orders do not have dynamic amounts.\\n                calldatacopy(\\n                    BasicOrder_considerationItem_token_ptr,\\n                    BasicOrder_considerationToken_cdPtr,\\n                    ThreeWords\\n                )\\n\\n                // Copy calldata region with considerationAmount and offerer\\n                // from BasicOrderParameters to endAmount and recipient in\\n                // ConsiderationItem.\\n                calldatacopy(\\n                    BasicOrder_considerationItem_endAmount_ptr,\\n                    BasicOrder_considerationAmount_cdPtr,\\n                    TwoWords\\n                )\\n\\n                // Calculate EIP712 ConsiderationItem hash and store it in the\\n                // array of EIP712 consideration hashes.\\n                mstore(\\n                    BasicOrder_considerationHashesArray_ptr,\\n                    keccak256(\\n                        BasicOrder_considerationItem_typeHash_ptr,\\n                        EIP712_ConsiderationItem_size\\n                    )\\n                )\\n\\n                /*\\n                 * 2. Write a ReceivedItem struct for the primary consideration\\n                 * item to the consideration array in OrderFulfilled.\\n                 */\\n\\n                // Get the length of the additional recipients array.\\n                let len := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n\\n                // Calculate pointer to length of OrderFulfilled consideration\\n                // array.\\n                let eventConsiderationArrPtr := add(\\n                    OrderFulfilled_consideration_length_baseOffset,\\n                    mul(0x20, len)\\n                )\\n\\n                // Set the length of the consideration array to the number of\\n                // additional recipients, plus one for the primary consideration\\n                // item.\\n                mstore(\\n                    eventConsiderationArrPtr,\\n                    add(\\n                        calldataload(\\n                            BasicOrder_additionalRecipients_length_cdPtr\\n                        ),\\n                        1\\n                    )\\n                )\\n\\n                // Overwrite the consideration array pointer so it points to the\\n                // body of the first element\\n                eventConsiderationArrPtr := add(eventConsiderationArrPtr, 0x20)\\n\\n                // Set itemType at start of the ReceivedItem memory region.\\n                mstore(eventConsiderationArrPtr, receivedItemType)\\n\\n                // Copy calldata region (token, identifier, amount & recipient)\\n                // from BasicOrderParameters to ReceivedItem memory.\\n                calldatacopy(\\n                    add(eventConsiderationArrPtr, Common_token_offset),\\n                    BasicOrder_considerationToken_cdPtr,\\n                    0x80\\n                )\\n\\n                /*\\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\\n                 * additional recipients and add a ReceivedItem for each to the\\n                 * consideration array in the OrderFulfilled event. The original\\n                 * additional recipients are all the considerations signed by\\n                 * the offerer aside from the primary consideration of the\\n                 * order. Uses memory region from 0x80-0x160 as a buffer for\\n                 * calculating EIP712 ConsiderationItem hashes.\\n                 */\\n\\n                // Put pointer to consideration hashes array on the stack.\\n                // This will be updated as each additional recipient is hashed\\n                let\\n                    considerationHashesPtr\\n                := BasicOrder_considerationHashesArray_ptr\\n\\n                // Write item type, token, & identifier for additional recipient\\n                // to memory region for hashing EIP712 ConsiderationItem; these\\n                // values will be reused for each recipient.\\n                mstore(\\n                    BasicOrder_considerationItem_itemType_ptr,\\n                    additionalRecipientsItemType\\n                )\\n                mstore(\\n                    BasicOrder_considerationItem_token_ptr,\\n                    additionalRecipientsToken\\n                )\\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\\n\\n                // Read length of the additionalRecipients array from calldata\\n                // and iterate.\\n                len := calldataload(\\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\\n                )\\n                let i := 0\\n                // prettier-ignore\\n                for {} lt(i, len) {\\n                    i := add(i, 1)\\n                } {\\n                    /*\\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\\n                     */\\n\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        mul(AdditionalRecipients_size, i)\\n                    )\\n\\n                    // Copy startAmount from calldata to the ConsiderationItem\\n                    // struct.\\n                    calldatacopy(\\n                        BasicOrder_considerationItem_startAmount_ptr,\\n                        additionalRecipientCdPtr,\\n                        0x20\\n                    )\\n\\n                    // Copy endAmount and recipient from calldata to the\\n                    // ConsiderationItem struct.\\n                    calldatacopy(\\n                        BasicOrder_considerationItem_endAmount_ptr,\\n                        additionalRecipientCdPtr,\\n                        AdditionalRecipients_size\\n                    )\\n\\n                    // Add 1 word to the pointer as part of each loop to reduce\\n                    // operations needed to get local offset into the array.\\n                    considerationHashesPtr := add(considerationHashesPtr, 0x20)\\n\\n                    // Calculate EIP712 ConsiderationItem hash and store it in\\n                    // the array of consideration hashes.\\n                    mstore(\\n                        considerationHashesPtr,\\n                        keccak256(\\n                            BasicOrder_considerationItem_typeHash_ptr,\\n                            EIP712_ConsiderationItem_size\\n                        )\\n                    )\\n\\n                    /*\\n                     * Write ReceivedItem to OrderFulfilled data.\\n                     */\\n\\n                    // At this point, eventConsiderationArrPtr points to the\\n                    // beginning of the ReceivedItem struct of the previous\\n                    // element in the array. Increase it by the size of the\\n                    // struct to arrive at the pointer for the current element.\\n                    eventConsiderationArrPtr := add(\\n                        eventConsiderationArrPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // Write itemType to the ReceivedItem struct.\\n                    mstore(\\n                        eventConsiderationArrPtr,\\n                        additionalRecipientsItemType\\n                    )\\n\\n                    // Write token to the ReceivedItem struct.\\n                    mstore(\\n                        add(eventConsiderationArrPtr, 0x20),\\n                        additionalRecipientsToken\\n                    )\\n\\n                    // Copy endAmount and recipient to the ReceivedItem struct.\\n                    calldatacopy(\\n                        add(\\n                            eventConsiderationArrPtr,\\n                            ReceivedItem_amount_offset\\n                        ),\\n                        additionalRecipientCdPtr,\\n                        0x40\\n                    )\\n                }\\n\\n                /*\\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\\n                 * Note that it is set at 0x60 \\u2014 all other memory begins at\\n                 * 0x80. 0x60 is the \\\"zero slot\\\" and will be restored at the end\\n                 * of the assembly section and before required by the compiler.\\n                 */\\n                mstore(\\n                    receivedItemsHash_ptr,\\n                    keccak256(\\n                        BasicOrder_considerationHashesArray_ptr,\\n                        mul(add(len, 1), 32)\\n                    )\\n                )\\n\\n                /*\\n                 * 5. Add a ReceivedItem for each tip to the consideration array\\n                 * in the OrderFulfilled event. The tips are all the\\n                 * consideration items that were not signed by the offerer and\\n                 * were provided by the fulfiller.\\n                 */\\n\\n                // Overwrite length to length of the additionalRecipients array.\\n                len := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n                // prettier-ignore\\n                for {} lt(i, len) {\\n                    i := add(i, 1)\\n                } {\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        mul(AdditionalRecipients_size, i)\\n                    )\\n\\n                    // At this point, eventConsiderationArrPtr points to the\\n                    // beginning of the ReceivedItem struct of the previous\\n                    // element in the array. Increase it by the size of the\\n                    // struct to arrive at the pointer for the current element.\\n                    eventConsiderationArrPtr := add(\\n                        eventConsiderationArrPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // Write itemType to the ReceivedItem struct.\\n                    mstore(\\n                        eventConsiderationArrPtr,\\n                        additionalRecipientsItemType\\n                    )\\n\\n                    // Write token to the ReceivedItem struct.\\n                    mstore(\\n                        add(eventConsiderationArrPtr, 0x20),\\n                        additionalRecipientsToken\\n                    )\\n\\n                    // Copy endAmount and recipient to the ReceivedItem struct.\\n                    calldatacopy(\\n                        add(\\n                            eventConsiderationArrPtr,\\n                            ReceivedItem_amount_offset\\n                        ),\\n                        additionalRecipientCdPtr,\\n                        0x40\\n                    )\\n                }\\n            }\\n        }\\n\\n        {\\n            /**\\n             * Next, handle offered items. Memory Layout:\\n             *  EIP712 data for OfferItem\\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n             *   - 0xa0:  itemType\\n             *   - 0xc0:  token\\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\\n             *   - 0x100: startAmount\\n             *   - 0x120: endAmount\\n             */\\n\\n            // Place offer item typehash on the stack.\\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\n\\n            // Utilize assembly to enable reuse of memory regions when possible.\\n            assembly {\\n                /*\\n                 * 1. Calculate OfferItem EIP712 hash\\n                 */\\n\\n                // Write the OfferItem typeHash to memory.\\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\\n\\n                // Write the OfferItem item type to memory.\\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\\n\\n                // Copy calldata region with (offerToken, offerIdentifier,\\n                // offerAmount) from OrderParameters to (token, identifier,\\n                // startAmount) in OfferItem struct. The offerAmount is written\\n                // to startAmount and endAmount as basic orders do not have\\n                // dynamic amounts.\\n                calldatacopy(\\n                    BasicOrder_offerItem_token_ptr,\\n                    BasicOrder_offerToken_cdPtr,\\n                    0x60\\n                )\\n\\n                // Copy offerAmount from calldata to endAmount in OfferItem\\n                // struct.\\n                calldatacopy(\\n                    BasicOrder_offerItem_endAmount_ptr,\\n                    BasicOrder_offerAmount_cdPtr,\\n                    0x20\\n                )\\n\\n                // Compute EIP712 OfferItem hash, write result to scratch space:\\n                //   `keccak256(abi.encode(offeredItem))`\\n                mstore(\\n                    0x00,\\n                    keccak256(\\n                        BasicOrder_offerItem_typeHash_ptr,\\n                        EIP712_OfferItem_size\\n                    )\\n                )\\n\\n                /*\\n                 * 2. Calculate hash of array of EIP712 hashes and write the\\n                 * result to the corresponding OfferItem struct:\\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\\n                 */\\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0x00, 0x20))\\n\\n                /*\\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\\n                 */\\n                let eventConsiderationArrPtr := add(\\n                    OrderFulfilled_offer_length_baseOffset,\\n                    mul(\\n                        0x20,\\n                        calldataload(\\n                            BasicOrder_additionalRecipients_length_cdPtr\\n                        )\\n                    )\\n                )\\n\\n                // Set a length of 1 for the offer array.\\n                mstore(eventConsiderationArrPtr, 1)\\n\\n                // Write itemType to the SpentItem struct.\\n                mstore(add(eventConsiderationArrPtr, 0x20), offeredItemType)\\n\\n                // Copy calldata region with (offerToken, offerIdentifier,\\n                // offerAmount) from OrderParameters to (token, identifier,\\n                // amount) in SpentItem struct.\\n                calldatacopy(\\n                    add(eventConsiderationArrPtr, AdditionalRecipients_size),\\n                    BasicOrder_offerToken_cdPtr,\\n                    ThreeWords\\n                )\\n            }\\n        }\\n\\n        {\\n            /**\\n             * Once consideration items and offer items have been handled,\\n             * derive the final order hash. Memory Layout:\\n             *  0x80-0x1c0: EIP712 data for order\\n             *   - 0x80:   Order EIP-712 typehash (constant)\\n             *   - 0xa0:   orderParameters.offerer\\n             *   - 0xc0:   orderParameters.zone\\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\\n             *   - 0x140:  orderParameters.startTime\\n             *   - 0x160:  orderParameters.endTime\\n             *   - 0x180:  orderParameters.zoneHash\\n             *   - 0x1a0:  orderParameters.salt\\n             *   - 0x1c0:  orderParameters.conduit\\n             *   - 0x1e0:  _nonces[orderParameters.offerer] (from storage)\\n             */\\n\\n            // Read the offerer from calldata and place on the stack.\\n            address offerer;\\n            assembly {\\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\\n            }\\n\\n            // Read offerer's current nonce from storage and place on the stack.\\n            uint256 nonce = _nonces[offerer];\\n\\n            // Load order typehash from runtime code and place on stack.\\n            bytes32 typeHash = _ORDER_TYPEHASH;\\n\\n            assembly {\\n                // Set the OrderItem typeHash in memory.\\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\\n\\n                // Copy offerer and zone from OrderParameters in calldata to the\\n                // Order struct.\\n                calldatacopy(\\n                    BasicOrder_order_offerer_ptr,\\n                    BasicOrder_offerer_cdPtr,\\n                    TwoWords\\n                )\\n\\n                // Copy receivedItemsHash from zero slot to the Order struct.\\n                mstore(\\n                    BasicOrder_order_considerationHashes_ptr,\\n                    mload(receivedItemsHash_ptr)\\n                )\\n\\n                // Write the supplied orderType to the Order struct.\\n                mstore(BasicOrder_order_orderType_ptr, orderType)\\n\\n                // Copy startTime, endTime, zoneHash, salt & conduit from\\n                // calldata to the Order struct.\\n                calldatacopy(\\n                    BasicOrder_order_startTime_ptr,\\n                    BasicOrder_startTime_cdPtr,\\n                    0xa0\\n                )\\n\\n                // Take offerer's nonce retrieved from storage, write to struct.\\n                mstore(BasicOrder_order_nonce_ptr, nonce)\\n\\n                // Compute the EIP712 Order hash.\\n                orderHash := keccak256(\\n                    BasicOrder_order_typeHash_ptr,\\n                    EIP712_Order_size\\n                )\\n            }\\n        }\\n\\n        assembly {\\n            /**\\n             * After the order hash has been derived, emit OrderFulfilled event:\\n             *   event OrderFulfilled(\\n             *     bytes32 orderHash,\\n             *     address indexed offerer,\\n             *     address indexed zone,\\n             *     address fulfiller,\\n             *     SpentItem[] offer,\\n             *       > (itemType, token, id, amount)\\n             *     ReceivedItem[] consideration\\n             *       > (itemType, token, id, amount, recipient)\\n             *   )\\n             * topic0 - OrderFulfilled event signature\\n             * topic1 - offerer\\n             * topic2 - zone\\n             * data:\\n             *  - 0x00: orderHash\\n             *  - 0x20: fulfiller\\n             *  - 0x40: offer arr ptr (0x80)\\n             *  - 0x60: consideration arr ptr (0x120)\\n             *  - 0x80: offer arr len (1)\\n             *  - 0xa0: offer.itemType\\n             *  - 0xc0: offer.token\\n             *  - 0xe0: offer.identifier\\n             *  - 0x100: offer.amount\\n             *  - 0x120: 1 + recipients.length\\n             *  - 0x140: recipient 0\\n             */\\n\\n            // Derive pointer to start of OrderFulfilled event data\\n            let eventDataPtr := add(\\n                OrderFulfilled_baseOffset,\\n                mul(\\n                    0x20,\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr)\\n                )\\n            )\\n\\n            // Write the order hash to the head of the event's data region.\\n            mstore(eventDataPtr, orderHash)\\n\\n            // Write the fulfiller (i.e. the caller) next.\\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\\n\\n            // Write the SpentItem and ReceivedItem array offsets (constants).\\n            mstore(\\n                // SpentItem array offset\\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\\n                OrderFulfilled_offer_body_offset\\n            )\\n            mstore(\\n                // ReceivedItem array offset\\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\\n                OrderFulfilled_consideration_body_offset\\n            )\\n\\n            // Derive total data size including SpentItem and ReceivedItem data.\\n            // SpentItem portion is already included in the baseSize constant,\\n            // as there can only be one element in the array.\\n            let dataSize := add(\\n                OrderFulfilled_baseSize,\\n                mul(\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\\n                    ReceivedItem_size\\n                )\\n            )\\n\\n            // Emit OrderFulfilled log with three topics (the event signature\\n            // as well as the two indexed arguments, the offerer and the zone).\\n            log3(\\n                // Supply the pointer for event data in memory.\\n                eventDataPtr,\\n                // Supply the size of event data in memory.\\n                dataSize,\\n                // Supply the OrderFulfilled event signature.\\n                OrderFulfilled_selector,\\n                // Supply the first topic (the offerer).\\n                calldataload(BasicOrder_offerer_cdPtr),\\n                // Supply the second topic (the zone).\\n                calldataload(BasicOrder_zone_cdPtr)\\n            )\\n\\n            // Restore the zero slot.\\n            mstore(0x60, 0)\\n        }\\n\\n        // Determine whether order is restricted and, if so, that it is valid.\\n        _assertRestrictedBasicOrderValidity(\\n            orderHash,\\n            parameters.zoneHash,\\n            orderType,\\n            parameters.offerer,\\n            parameters.zone\\n        );\\n\\n        // Verify and update the status of the derived order.\\n        _validateBasicOrderAndUpdateStatus(\\n            orderHash,\\n            parameters.offerer,\\n            parameters.signature\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function to verify and update the status of a basic order.\\n     *\\n     * @param orderHash The hash of the order.\\n     * @param offerer   The offerer of the order.\\n     * @param signature A signature from the offerer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _validateBasicOrderAndUpdateStatus(\\n        bytes32 orderHash,\\n        address offerer,\\n        bytes memory signature\\n    ) internal {\\n        // Retrieve the order status for the given order hash.\\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n        // Ensure order is fillable and is not cancelled.\\n        _verifyOrderStatus(\\n            orderHash,\\n            orderStatus,\\n            true, // Only allow unused orders when fulfilling basic orders.\\n            true // Signifies to revert if the order is invalid.\\n        );\\n\\n        // If the order is not already validated, verify the supplied signature.\\n        if (!orderStatus.isValidated) {\\n            _verifySignature(offerer, orderHash, signature);\\n        }\\n\\n        // Update order status as fully filled, packing struct values.\\n        _orderStatus[orderHash].isValidated = true;\\n        _orderStatus[orderHash].isCancelled = false;\\n        _orderStatus[orderHash].numerator = 1;\\n        _orderStatus[orderHash].denominator = 1;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate an order, determine what portion to\\n     *      fill, and update its status. The desired fill amount is supplied as\\n     *      a fraction, as is the returned amount to fill.\\n     *\\n     * @param advancedOrder    The order to fulfill as well as the fraction to\\n     *                         fill. Note that all offer and consideration\\n     *                         amounts must divide with no remainder in order\\n     *                         for a partial fill to be valid.\\n     * @param revertOnInvalid  A boolean indicating whether to revert if the\\n     *                         order is invalid due to the time or order status.\\n     * @param priorOrderHashes The order hashes of each order supplied prior to\\n     *                         the current order as part of a \\\"match\\\" variety of\\n     *                         order fulfillment (e.g. this array will be empty\\n     *                         for single or \\\"fulfill available\\\").\\n     *\\n     * @return orderHash      The order hash.\\n     * @return newNumerator   A value indicating the portion of the order that\\n     *                        will be filled.\\n     * @return newDenominator A value indicating the total size of the order.\\n     */\\n    function _validateOrderAndUpdateStatus(\\n        AdvancedOrder memory advancedOrder,\\n        bool revertOnInvalid,\\n        bytes32[] memory priorOrderHashes\\n    )\\n        internal\\n        returns (\\n            bytes32 orderHash,\\n            uint256 newNumerator,\\n            uint256 newDenominator\\n        )\\n    {\\n        // Retrieve the parameters for the order.\\n        OrderParameters memory orderParameters = advancedOrder.parameters;\\n\\n        // Ensure current timestamp falls between order start time and end time.\\n        if (\\n            !_verifyTime(\\n                orderParameters.startTime,\\n                orderParameters.endTime,\\n                revertOnInvalid\\n            )\\n        ) {\\n            // Assuming an invalid time and no revert, return zeroed out values.\\n            return (bytes32(0), 0, 0);\\n        }\\n\\n        // Read numerator and denominator from memory and place on the stack.\\n        uint256 numerator = uint256(advancedOrder.numerator);\\n        uint256 denominator = uint256(advancedOrder.denominator);\\n\\n        // Ensure that the supplied numerator and denominator are valid.\\n        if (numerator > denominator || numerator == 0) {\\n            revert BadFraction();\\n        }\\n\\n        // If attempting partial fill (n < d) check order type & ensure support.\\n        if (\\n            numerator < denominator &&\\n            _doesNotSupportPartialFills(orderParameters.orderType)\\n        ) {\\n            // Revert if partial fill was attempted on an unsupported order.\\n            revert PartialFillsNotEnabledForOrder();\\n        }\\n\\n        // Retrieve current nonce and use it w/ parameters to derive order hash.\\n        orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\\n            orderParameters\\n        );\\n\\n        // Determine if a proxy should be utilized and ensure a valid submitter.\\n        _assertRestrictedAdvancedOrderValidity(\\n            advancedOrder,\\n            priorOrderHashes,\\n            orderHash,\\n            orderParameters.zoneHash,\\n            orderParameters.orderType,\\n            orderParameters.offerer,\\n            orderParameters.zone\\n        );\\n\\n        // Retrieve the order status using the derived order hash.\\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n        // Ensure order is fillable and is not cancelled.\\n        if (\\n            !_verifyOrderStatus(\\n                orderHash,\\n                orderStatus,\\n                false, // Allow partially used orders to be filled.\\n                revertOnInvalid\\n            )\\n        ) {\\n            // Assuming an invalid order status and no revert, return zero fill.\\n            return (orderHash, 0, 0);\\n        }\\n\\n        // If the order is not already validated, verify the supplied signature.\\n        if (!orderStatus.isValidated) {\\n            _verifySignature(\\n                orderParameters.offerer,\\n                orderHash,\\n                advancedOrder.signature\\n            );\\n        }\\n\\n        // Read filled amount as numerator and denominator and put on the stack.\\n        uint256 filledNumerator = orderStatus.numerator;\\n        uint256 filledDenominator = orderStatus.denominator;\\n\\n        // If order currently has a non-zero denominator it is partially filled.\\n        if (filledDenominator != 0) {\\n            // If denominator of 1 supplied, fill all remaining amount on order.\\n            if (denominator == 1) {\\n                // Scale numerator & denominator to match current denominator.\\n                numerator = filledDenominator;\\n                denominator = filledDenominator;\\n            }\\n            // Otherwise, if supplied denominator differs from current one...\\n            else if (filledDenominator != denominator) {\\n                // scale current numerator by the supplied denominator, then...\\n                filledNumerator *= denominator;\\n\\n                // the supplied numerator & denominator by current denominator.\\n                numerator *= filledDenominator;\\n                denominator *= filledDenominator;\\n            }\\n\\n            // Once adjusted, if current+supplied numerator exceeds denominator:\\n            if (filledNumerator + numerator > denominator) {\\n                // Skip underflow check: denominator >= orderStatus.numerator\\n                unchecked {\\n                    // Reduce current numerator so it + supplied = denominator.\\n                    numerator = denominator - filledNumerator;\\n                }\\n            }\\n\\n            // Skip overflow check: checked above unless numerator is reduced.\\n            unchecked {\\n                // Update order status and fill amount, packing struct values.\\n                _orderStatus[orderHash].isValidated = true;\\n                _orderStatus[orderHash].isCancelled = false;\\n                _orderStatus[orderHash].numerator = uint120(\\n                    filledNumerator + numerator\\n                );\\n                _orderStatus[orderHash].denominator = uint120(denominator);\\n            }\\n        } else {\\n            // Update order status and fill amount, packing struct values.\\n            _orderStatus[orderHash].isValidated = true;\\n            _orderStatus[orderHash].isCancelled = false;\\n            _orderStatus[orderHash].numerator = uint120(numerator);\\n            _orderStatus[orderHash].denominator = uint120(denominator);\\n        }\\n\\n        // Return order hash, new numerator and denominator, and proxy boolean.\\n        return (orderHash, numerator, denominator);\\n    }\\n\\n    /**\\n     * @dev Internal function to validate an order and update its status, adjust\\n     *      prices based on current time, apply criteria resolvers, determine\\n     *      what portion to fill, and transfer relevant tokens.\\n     *\\n     * @param advancedOrder     The order to fulfill as well as the fraction to\\n     *                          fill. Note that all offer and consideration\\n     *                          components must divide with no remainder in\\n     *                          order for the partial fill to be valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific offer or consideration, a token\\n     *                          identifier, and a proof that the supplied token\\n     *                          identifier is contained in the order's merkle\\n     *                          root. Note that a criteria of zero indicates\\n     *                          that any (transferrable) token identifier is\\n     *                          valid and that no proof needs to be supplied.\\n     * @param fulfillerConduit  An address indicating what conduit, if any, to\\n     *                          source the fulfiller's token approvals from. The\\n     *                          null address signifies that no conduit should be\\n     *                          used (and direct approvals set on Consideration)\\n     *                          and `address(1)` signifies to utilize the legacy\\n     *                          user proxy for the fulfiller.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function _validateAndFulfillAdvancedOrder(\\n        AdvancedOrder memory advancedOrder,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        address fulfillerConduit\\n    ) internal returns (bool) {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard();\\n\\n        // Declare empty bytes32 array (unused, will remain empty).\\n        bytes32[] memory priorOrderHashes;\\n\\n        // Validate order, update status, and determine fraction to fill.\\n        (\\n            bytes32 orderHash,\\n            uint256 fillNumerator,\\n            uint256 fillDenominator\\n        ) = _validateOrderAndUpdateStatus(\\n                advancedOrder,\\n                true,\\n                priorOrderHashes\\n            );\\n\\n        // Create an array with length 1 containing the order.\\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\\n        advancedOrders[0] = advancedOrder;\\n\\n        // Apply criteria resolvers using generated orders and details arrays.\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\n\\n        // Retrieve the order parameters after applying criteria resolvers.\\n        OrderParameters memory orderParameters = advancedOrders[0].parameters;\\n\\n        // Perform each item transfer with the appropriate fractional amount.\\n        _applyFractionsAndTransferEach(\\n            orderParameters,\\n            fillNumerator,\\n            fillDenominator,\\n            orderParameters.conduit,\\n            fulfillerConduit\\n        );\\n\\n        // Emit an event signifying that the order has been fulfilled.\\n        _emitOrderFulfilledEvent(\\n            orderHash,\\n            orderParameters.offerer,\\n            orderParameters.zone,\\n            msg.sender,\\n            orderParameters.offer,\\n            orderParameters.consideration\\n        );\\n\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer each item contained in a given single\\n     *      order fulfillment after applying a respective fraction to the amount\\n     *      being transferred.\\n     *\\n     * @param orderParameters  The parameters for the fulfilled order.\\n     * @param numerator        A value indicating the portion of the order that\\n     *                         should be filled.\\n     * @param denominator      A value indicating the total size of the order.\\n     * @param offererConduit   An address indicating what conduit, if any, to\\n     *                         source the offerer's token approvals from. The\\n     *                         null address signifies that no conduit should be\\n     *                         used (and direct approvals set on Consideration)\\n     *                         and `address(1)` signifies to utilize the legacy\\n     *                         user proxy for the offerer.\\n     * @param fulfillerConduit An address indicating what conduit, if any, to\\n     *                         source the fulfiller's token approvals from. The\\n     *                         null address signifies that no conduit should be\\n     *                         used (and direct approvals set on Consideration)\\n     *                         and `address(1)` signifies to utilize the legacy\\n     *                         user proxy for the fulfiller.\\n     */\\n    function _applyFractionsAndTransferEach(\\n        OrderParameters memory orderParameters,\\n        uint256 numerator,\\n        uint256 denominator,\\n        address offererConduit,\\n        address fulfillerConduit\\n    ) internal {\\n        // Derive order duration, time elapsed, and time remaining.\\n        uint256 duration = orderParameters.endTime - orderParameters.startTime;\\n        uint256 elapsed = block.timestamp - orderParameters.startTime;\\n        uint256 remaining = duration - elapsed;\\n\\n        // Put ether value supplied by the caller on the stack.\\n        uint256 etherRemaining = msg.value;\\n\\n        // As of solidity 0.6.0, inline assembly can not directly access function\\n        // definitions, but can still access locally scoped function variables.\\n        // This means that in order to recast the type of a function, we need to\\n        // create a local variable to reference the internal function definition\\n        // (using the same type) and a local variable with the desired type,\\n        // and then cast the original function pointer to the desired type.\\n\\n        /**\\n         * Repurpose existing OfferItem memory regions on the offer array for\\n         * the order by overriding the _transfer function pointer to accept a\\n         * modified OfferItem argument in place of the usual ReceivedItem:\\n         *\\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\\n         *   ItemType itemType; ------------> ItemType itemType;\\n         *   address token; ----------------> address token;\\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\\n         *   uint256 startAmount; ----------> uint256 amount;\\n         *   uint256 endAmount; ------------> address recipient;\\n         */\\n\\n        // Declare a nested scope to minimize stack depth.\\n        {\\n            // Declare a virtual function pointer taking an OfferItem argument.\\n            function(OfferItem memory, address, address)\\n                internal _transferOfferItem;\\n\\n            // Assign _transfer function to a new function pointer (it takes a\\n            // ReceivedItem as its initial argument)\\n            function(ReceivedItem memory, address, address)\\n                internal _transferReceivedItem = _transfer;\\n\\n            // Utilize assembly to override the virtual function pointer.\\n            assembly {\\n                // Cast initial ReceivedItem argument type to an OfferItem type.\\n                _transferOfferItem := _transferReceivedItem\\n            }\\n\\n            // Iterate over each offer on the order.\\n            for (uint256 i = 0; i < orderParameters.offer.length; ) {\\n                // Retrieve the offer item.\\n                OfferItem memory offerItem = orderParameters.offer[i];\\n\\n                // Apply fill fraction to derive offer item amount to transfer.\\n                uint256 amount = _applyFraction(\\n                    offerItem.startAmount,\\n                    offerItem.endAmount,\\n                    numerator,\\n                    denominator,\\n                    elapsed,\\n                    remaining,\\n                    duration,\\n                    false\\n                );\\n\\n                // Utilize assembly to set overloaded offerItem arguments.\\n                assembly {\\n                    // Write derived fractional amount to startAmount as amount.\\n                    mstore(add(offerItem, 0x60), amount)\\n                    // Write fulfiller (i.e. caller) to endAmount as recipient.\\n                    mstore(add(offerItem, 0x80), caller())\\n                }\\n\\n                // Reduce available value if offer spent ETH or a native token.\\n                if (offerItem.itemType == ItemType.NATIVE) {\\n                    // Ensure that sufficient native tokens are still available.\\n                    if (amount > etherRemaining) {\\n                        revert InsufficientEtherSupplied();\\n                    }\\n\\n                    // Skip underflow check as a comparison has just been made.\\n                    unchecked {\\n                        etherRemaining -= amount;\\n                    }\\n                }\\n\\n                // Transfer the item from the offerer to the caller.\\n                _transferOfferItem(\\n                    offerItem,\\n                    orderParameters.offerer,\\n                    offererConduit\\n                );\\n\\n                // Skip overflow check as for loop is indexed starting at zero.\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Repurpose existing ConsiderationItem memory regions on the\\n         * consideration array for the order by overriding the _transfer\\n         * function pointer to accept a modified ConsiderationItem argument in\\n         * place of the usual ReceivedItem:\\n         *\\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\\n         *   ItemType itemType; ------------> ItemType itemType;\\n         *   address token; ----------------> address token;\\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\\n         *   uint256 startAmount; ----------> uint256 amount;\\n         *   uint256 endAmount;        /----> address recipient;\\n         *   address recipient; ------/\\n         */\\n\\n        // Declare a nested scope to minimize stack depth.\\n        {\\n            // Declare virtual function pointer with ConsiderationItem argument.\\n            function(ConsiderationItem memory, address, address)\\n                internal _transferConsiderationItem;\\n\\n            // Reassign _transfer function to a new function pointer (it takes a\\n            /// ReceivedItem as its initial argument).\\n            function(ReceivedItem memory, address, address)\\n                internal _transferReceivedItem = _transfer;\\n\\n            // Utilize assembly to override the virtual function pointer.\\n            assembly {\\n                // Cast ReceivedItem argument type to ConsiderationItem type.\\n                _transferConsiderationItem := _transferReceivedItem\\n            }\\n\\n            // Iterate over each consideration on the order.\\n            for (uint256 i = 0; i < orderParameters.consideration.length; ) {\\n                // Retrieve the consideration item.\\n                ConsiderationItem memory considerationItem = (\\n                    orderParameters.consideration[i]\\n                );\\n\\n                // Apply fraction & derive considerationItem amount to transfer.\\n                uint256 amount = _applyFraction(\\n                    considerationItem.startAmount,\\n                    considerationItem.endAmount,\\n                    numerator,\\n                    denominator,\\n                    elapsed,\\n                    remaining,\\n                    duration,\\n                    true\\n                );\\n\\n                // Use assembly to set overloaded considerationItem arguments.\\n                assembly {\\n                    // Write derived fractional amount to startAmount as amount.\\n                    mstore(add(considerationItem, 0x60), amount)\\n\\n                    // Write original recipient to endAmount as recipient.\\n                    mstore(\\n                        add(considerationItem, 0x80),\\n                        mload(add(considerationItem, 0xa0))\\n                    )\\n                }\\n\\n                // Reduce available value if offer spent ETH or a native token.\\n                if (considerationItem.itemType == ItemType.NATIVE) {\\n                    // Ensure that sufficient native tokens are still available.\\n                    if (amount > etherRemaining) {\\n                        revert InsufficientEtherSupplied();\\n                    }\\n\\n                    // Skip underflow check as a comparison has just been made.\\n                    unchecked {\\n                        etherRemaining -= amount;\\n                    }\\n                }\\n\\n                // Transfer item from caller to recipient specified by the item.\\n                _transferConsiderationItem(\\n                    considerationItem,\\n                    msg.sender,\\n                    fulfillerConduit\\n                );\\n\\n                // Skip overflow check as for loop is indexed starting at zero.\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        // If any ether remains after fulfillments...\\n        if (etherRemaining != 0) {\\n            // return it to the caller.\\n            _transferEth(payable(msg.sender), etherRemaining);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a group of orders, update their\\n     *      statuses, reduce amounts by their previously filled fractions, apply\\n     *      criteria resolvers, and emit OrderFulfilled events.\\n     *\\n     * @param advancedOrders    The advanced orders to validate and reduce by\\n     *                          their previously filled amounts.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          a root of zero indicates that any transferrable\\n     *                          token identifier is valid and that no proof\\n     *                          needs to be supplied.\\n     */\\n    function _validateOrdersAndPrepareToFulfill(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bool revertOnInvalid\\n    ) internal {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard();\\n\\n        // Read length of orders array and place on the stack.\\n        uint256 totalOrders = advancedOrders.length;\\n\\n        // Track the order hash for each order being fulfilled.\\n        bytes32[] memory orderHashes = new bytes32[](totalOrders);\\n\\n        // Override orderHashes length to zero after memory has been allocated.\\n        assembly {\\n            mstore(orderHashes, 0)\\n        }\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Retrieve the current order.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Validate it, update status, and determine fraction to fill.\\n                (\\n                    bytes32 orderHash,\\n                    uint256 numerator,\\n                    uint256 denominator\\n                ) = _validateOrderAndUpdateStatus(\\n                        advancedOrder,\\n                        revertOnInvalid,\\n                        orderHashes\\n                    );\\n\\n                // Update the length of the orderHashes array.\\n                assembly {\\n                    mstore(orderHashes, add(i, 1))\\n                }\\n\\n                // Place the start time for the order on the stack.\\n                uint256 startTime = advancedOrder.parameters.startTime;\\n\\n                // Derive the duration for the order and place it on the stack.\\n                uint256 duration = advancedOrder.parameters.endTime - startTime;\\n\\n                // Derive time elapsed since the order started & place on stack.\\n                uint256 elapsed = block.timestamp - startTime;\\n\\n                // Derive time remaining until order expires and place on stack.\\n                uint256 remaining = duration - elapsed;\\n\\n                // Do not track hash or adjust prices if order is not fulfilled.\\n                if (numerator == 0) {\\n                    // Mark fill fraction as zero if the order is not fulfilled.\\n                    advancedOrder.numerator = 0;\\n\\n                    // Continue iterating through the remaining orders.\\n                    continue;\\n                }\\n\\n                // Otherwise, track the order hash in question.\\n                orderHashes[i] = orderHash;\\n\\n                // Retrieve array of offer items for the order in question.\\n                OfferItem[] memory offer = advancedOrder.parameters.offer;\\n\\n                // Iterate over each offer item on the order.\\n                for (uint256 j = 0; j < offer.length; ++j) {\\n                    // Retrieve the offer item.\\n                    OfferItem memory offerItem = offer[j];\\n\\n                    // Apply order fill fraction to offer item end amount.\\n                    uint256 endAmount = _getFraction(\\n                        numerator,\\n                        denominator,\\n                        offerItem.endAmount\\n                    );\\n\\n                    // Reuse same fraction if start and end amounts are equal.\\n                    if (offerItem.startAmount == offerItem.endAmount) {\\n                        // Apply derived amount to both start and end amount.\\n                        offerItem.startAmount = endAmount;\\n                    } else {\\n                        // Apply order fill fraction to offer item start amount.\\n                        offerItem.startAmount = _getFraction(\\n                            numerator,\\n                            denominator,\\n                            offerItem.startAmount\\n                        );\\n                    }\\n\\n                    // Update end amount in memory to match the derived amount.\\n                    offerItem.endAmount = endAmount;\\n\\n                    // Adjust offer amount using current time; round down.\\n                    offerItem.startAmount = _locateCurrentAmount(\\n                        offerItem.startAmount,\\n                        offerItem.endAmount,\\n                        elapsed,\\n                        remaining,\\n                        duration,\\n                        false // round down\\n                    );\\n                }\\n\\n                // Retrieve array of consideration items for order in question.\\n                ConsiderationItem[] memory consideration = (\\n                    advancedOrder.parameters.consideration\\n                );\\n\\n                // Iterate over each consideration item on the order.\\n                for (uint256 j = 0; j < consideration.length; ++j) {\\n                    // Retrieve the consideration item.\\n                    ConsiderationItem memory considerationItem = (\\n                        consideration[j]\\n                    );\\n\\n                    // Apply fraction to consideration item end amount.\\n                    uint256 endAmount = _getFraction(\\n                        numerator,\\n                        denominator,\\n                        considerationItem.endAmount\\n                    );\\n\\n                    // Reuse same fraction if start and end amounts are equal.\\n                    if (\\n                        considerationItem.startAmount ==\\n                        considerationItem.endAmount\\n                    ) {\\n                        // Apply derived amount to both start and end amount.\\n                        considerationItem.startAmount = endAmount;\\n                    } else {\\n                        // Apply fraction to consideration item start amount.\\n                        considerationItem.startAmount = _getFraction(\\n                            numerator,\\n                            denominator,\\n                            considerationItem.startAmount\\n                        );\\n                    }\\n\\n                    // Update end amount in memory to match the derived amount.\\n                    considerationItem.endAmount = endAmount;\\n\\n                    // Adjust consideration amount using current time; round up.\\n                    considerationItem.startAmount = (\\n                        _locateCurrentAmount(\\n                            considerationItem.startAmount,\\n                            considerationItem.endAmount,\\n                            elapsed,\\n                            remaining,\\n                            duration,\\n                            true // round up\\n                        )\\n                    );\\n\\n                    // Utilize assembly to manually \\\"shift\\\" the recipient value.\\n                    assembly {\\n                        // Write recipient to endAmount, as endAmount is not\\n                        // used from this point on and can be repurposed to fit\\n                        // the layout of a ReceivedItem.\\n                        mstore(\\n                            add(considerationItem, 0x80), // endAmount\\n                            mload(add(considerationItem, 0xa0)) // recipient\\n                        )\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Apply criteria resolvers to each order as applicable.\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\n\\n        // Determine the fulfiller (revertOnInvalid ? address(0) : msg.sender).\\n        address fulfiller;\\n\\n        // Utilize assembly to operate on revertOnInvalid boolean as an integer.\\n        assembly {\\n            // Set the fulfiller to the caller if revertOnValid is false.\\n            fulfiller := mul(iszero(revertOnInvalid), caller())\\n        }\\n\\n        // Emit an event for each order signifying that it has been fulfilled.\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Do not emit an event if no order hash is present.\\n                if (orderHashes[i] == bytes32(0)) {\\n                    continue;\\n                }\\n\\n                // Retrieve parameters for the order in question.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrders[i].parameters\\n                );\\n\\n                // Emit an OrderFulfilled event.\\n                _emitOrderFulfilledEvent(\\n                    orderHashes[i],\\n                    orderParameters.offerer,\\n                    orderParameters.zone,\\n                    fulfiller,\\n                    orderParameters.offer,\\n                    orderParameters.consideration\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to fulfill an arbitrary number of orders, either\\n     *      full or partial, after validating, adjusting amounts, and applying\\n     *      criteria resolvers.\\n     *\\n     * @param advancedOrders     The orders to match, including a fraction to\\n     *                           attempt to fill for each order.\\n     * @param fulfillments       An array of elements allocating offer\\n     *                           components to consideration components. Note\\n     *                           that the final amount of each consideration\\n     *                           component must be zero for a match operation to\\n     *                           be considered valid.\\n     *\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function _fulfillAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        internal\\n        returns (\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Allocate executions by fulfillment and apply them to each execution.\\n        Execution[] memory executions = new Execution[](fulfillments.length);\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Track number of filtered executions.\\n            uint256 totalFilteredExecutions = 0;\\n\\n            // Iterate over each fulfillment.\\n            for (uint256 i = 0; i < fulfillments.length; ++i) {\\n                /// Retrieve the fulfillment in question.\\n                Fulfillment memory fulfillment = fulfillments[i];\\n\\n                // Derive the execution corresponding with the fulfillment.\\n                Execution memory execution = _applyFulfillment(\\n                    advancedOrders,\\n                    fulfillment.offerComponents,\\n                    fulfillment.considerationComponents\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (execution.item.recipient == execution.offerer) {\\n                    // increment total filtered executions.\\n                    totalFilteredExecutions += 1;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[i - totalFilteredExecutions] = execution;\\n                }\\n            }\\n\\n            // If some number of executions have been filtered...\\n            if (totalFilteredExecutions != 0) {\\n                // reduce the total length of the executions array.\\n                assembly {\\n                    mstore(\\n                        executions,\\n                        sub(mload(executions), totalFilteredExecutions)\\n                    )\\n                }\\n            }\\n        }\\n\\n        // Perform final checks and compress executions into standard and batch.\\n        (\\n            ,\\n            standardExecutions,\\n            batchExecutions\\n        ) = _performFinalChecksAndExecuteOrders(advancedOrders, executions);\\n\\n        // Return both standard and batch ERC1155 executions.\\n        return (standardExecutions, batchExecutions);\\n    }\\n\\n    /**\\n     * @dev Internal function to fulfill a group of validated orders, fully or\\n     *      partially, with an arbitrary number of items for offer and\\n     *      consideration per order and to execute transfers. Any order that is\\n     *      not currently active, has already been fully filled, or has been\\n     *      cancelled will be omitted. Remaining offer and consideration items\\n     *      will then be aggregated where possible as indicated by the supplied\\n     *      offer and consideration component arrays and aggregated items will\\n     *      be transferred to the fulfiller or to each intended recipient,\\n     *      respectively. Note that a failing item transfer or an issue with\\n     *      order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or the conduit if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     *\\n     * @return availableOrders    An array of booleans indicating if each order\\n     *                            with an index corresponding to the index of\\n     *                            the returned boolean was fulfillable or not.\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            matching the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            matching the given orders.\\n     */\\n    function _fulfillAvailableOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[][] memory offerFulfillments,\\n        FulfillmentComponent[][] memory considerationFulfillments,\\n        address fulfillerConduit\\n    )\\n        internal\\n        returns (\\n            bool[] memory availableOrders,\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Allocate an execution for each offer and consideration fulfillment.\\n        Execution[] memory executions = new Execution[](\\n            offerFulfillments.length + considerationFulfillments.length\\n        );\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Track number of filtered executions.\\n            uint256 totalFilteredExecutions = 0;\\n\\n            // Iterate over each offer fulfillment.\\n            for (uint256 i = 0; i < offerFulfillments.length; ++i) {\\n                /// Retrieve the offer fulfillment components in question.\\n                FulfillmentComponent[] memory components = offerFulfillments[i];\\n\\n                // Derive aggregated execution corresponding with fulfillment.\\n                Execution memory execution = _aggregateAvailable(\\n                    advancedOrders,\\n                    Side.OFFER,\\n                    components,\\n                    fulfillerConduit\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (execution.item.recipient == execution.offerer) {\\n                    // increment total filtered executions.\\n                    totalFilteredExecutions += 1;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[i - totalFilteredExecutions] = execution;\\n                }\\n            }\\n\\n            // Iterate over each consideration fulfillment.\\n            for (uint256 i = 0; i < considerationFulfillments.length; ++i) {\\n                /// Retrieve consideration fulfillment components in question.\\n                FulfillmentComponent[] memory components = (\\n                    considerationFulfillments[i]\\n                );\\n\\n                // Derive aggregated execution corresponding with fulfillment.\\n                Execution memory execution = _aggregateAvailable(\\n                    advancedOrders,\\n                    Side.CONSIDERATION,\\n                    components,\\n                    fulfillerConduit\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (execution.item.recipient == execution.offerer) {\\n                    // increment total filtered executions.\\n                    totalFilteredExecutions += 1;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[\\n                        i + offerFulfillments.length - totalFilteredExecutions\\n                    ] = execution;\\n                }\\n            }\\n\\n            // If some number of executions have been filtered...\\n            if (totalFilteredExecutions != 0) {\\n                // reduce the total length of the executions array.\\n                assembly {\\n                    mstore(\\n                        executions,\\n                        sub(mload(executions), totalFilteredExecutions)\\n                    )\\n                }\\n            }\\n        }\\n\\n        // Revert if no orders are available.\\n        if (executions.length == 0) {\\n            revert NoSpecifiedOrdersAvailable();\\n        }\\n\\n        // Perform final checks, compress executions, and return.\\n        return _performFinalChecksAndExecuteOrders(advancedOrders, executions);\\n    }\\n\\n    /**\\n     * @dev Internal function to perform a final check that each consideration\\n     *      item for an arbitrary number of fulfilled orders has been met and to\\n     *      compress and trigger associated execututions, transferring the\\n     *      respective items.\\n     *\\n     * @param advancedOrders     The orders to check and perform executions for.\\n     * @param executions         An array of uncompressed elements indicating\\n     *                           the sequence of transfers to perform when\\n     *                           fulfilling the given orders.\\n     *\\n     * @return availableOrders    An array of booleans indicating if each order\\n     *                            with an index corresponding to the index of\\n     *                            the returned boolean was fulfillable or not.\\n     * @return standardExecutions An array of elements indicating the sequence\\n     *                            of non-batch transfers performed as part of\\n     *                            fulfilling the given orders.\\n     * @return batchExecutions    An array of elements indicating the sequence\\n     *                            of batch transfers performed as part of\\n     *                            fulfilling the given orders.\\n     */\\n    function _performFinalChecksAndExecuteOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        Execution[] memory executions\\n    )\\n        internal\\n        returns (\\n            bool[] memory availableOrders,\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Retrieve the length of the advanced orders array and place on stack.\\n        uint256 totalOrders = advancedOrders.length;\\n\\n        // Initialize array for tracking available orders.\\n        availableOrders = new bool[](totalOrders);\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over orders to ensure all considerations are met.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Retrieve the order in question.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Skip consideration item checks for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    // Note: orders do not need to be marked as unavailable as a\\n                    // new memory region has been allocated. Review carefully if\\n                    // altering compiler version or managing memory manually.\\n                    continue;\\n                }\\n\\n                // Mark the order as available.\\n                availableOrders[i] = true;\\n\\n                // Retrieve consideration items to ensure they are fulfilled.\\n                ConsiderationItem[] memory consideration = (\\n                    advancedOrder.parameters.consideration\\n                );\\n\\n                // Iterate over each consideration item to ensure it is met.\\n                for (uint256 j = 0; j < consideration.length; ++j) {\\n                    // Retrieve remaining amount on the consideration item.\\n                    uint256 unmetAmount = consideration[j].startAmount;\\n\\n                    // Revert if the remaining amount is not zero.\\n                    if (unmetAmount != 0) {\\n                        revert ConsiderationNotMet(i, j, unmetAmount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Split executions into \\\"standard\\\" (no batch) and \\\"batch\\\" executions.\\n        (standardExecutions, batchExecutions) = _compressExecutions(executions);\\n\\n        // Put ether value supplied by the caller on the stack.\\n        uint256 etherRemaining = msg.value;\\n\\n        // Iterate over each standard execution.\\n        for (uint256 i = 0; i < standardExecutions.length; ) {\\n            // Retrieve the execution and the associated received item.\\n            Execution memory execution = standardExecutions[i];\\n            ReceivedItem memory item = execution.item;\\n\\n            // If execution transfers native tokens, reduce value available.\\n            if (item.itemType == ItemType.NATIVE) {\\n                // Ensure that sufficient native tokens are still available.\\n                if (item.amount > etherRemaining) {\\n                    revert InsufficientEtherSupplied();\\n                }\\n\\n                // Skip underflow check as amount is less than ether remaining.\\n                unchecked {\\n                    etherRemaining -= item.amount;\\n                }\\n            }\\n\\n            // Transfer the item specified by the execution.\\n            _transfer(item, execution.offerer, execution.conduit);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Iterate over each batch execution.\\n            for (uint256 i = 0; i < batchExecutions.length; ++i) {\\n                _batchTransferERC1155(batchExecutions[i]);\\n            }\\n        }\\n\\n        // If any ether remains after fulfillments, return it to the caller.\\n        if (etherRemaining != 0) {\\n            _transferEth(payable(msg.sender), etherRemaining);\\n        }\\n\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n\\n        // Return arrays with available orders and triggered executions.\\n        return (availableOrders, standardExecutions, batchExecutions);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a given item.\\n     *\\n     * @param item    The item to transfer, including an amount and recipient.\\n     * @param offerer The account offering the item, i.e. the from address.\\n     * @param conduit An address indicating what conduit, if any, to source\\n     *                token approvals from. The null address signifies that no\\n     *                conduit should be used (and direct approvals set on\\n     *                Consideration) and `address(1)` signifies to utilize the\\n     *                legacy user proxy for the transfer.\\n     */\\n    function _transfer(\\n        ReceivedItem memory item,\\n        address offerer,\\n        address conduit\\n    ) internal {\\n        // If the item type indicates Ether or a native token...\\n        if (item.itemType == ItemType.NATIVE) {\\n            // transfer the native tokens to the recipient.\\n            _transferEth(item.recipient, item.amount);\\n        } else if (item.itemType == ItemType.ERC20) {\\n            // Transfer ERC20 tokens from the offerer to the recipient.\\n            _transferERC20(\\n                item.token,\\n                offerer,\\n                item.recipient,\\n                item.amount,\\n                conduit\\n            );\\n        } else if (item.itemType == ItemType.ERC721) {\\n            // Transfer ERC721 token from the offerer to the recipient.\\n            _transferERC721(\\n                item.token,\\n                offerer,\\n                item.recipient,\\n                item.identifier,\\n                item.amount,\\n                conduit\\n            );\\n        } else {\\n            // Transfer ERC1155 token from the offerer to the recipient.\\n            _transferERC1155(\\n                item.token,\\n                offerer,\\n                item.recipient,\\n                item.identifier,\\n                item.amount,\\n                conduit\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer Ether or other native tokens to a\\n     *      given recipient.\\n     *\\n     * @param to     The recipient of the transfer.\\n     * @param amount The amount to transfer.\\n     */\\n    function _transferEth(address payable to, uint256 amount) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Declare a variable indicating whether the call was successful or not.\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        // If the call fails...\\n        if (!success) {\\n            // Revert and pass the revert reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            revert EtherTransferGenericFailure(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient using a given conduit if applicable. Sufficient\\n     *      approvals must be set on this contract, the conduit, or the token\\n     *      transfer proxy in cases where the conduit is set to `address(1)`.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     * @param conduit    An address indicating what conduit, if any, to source\\n     *                   token approvals from. The null address signifies that\\n     *                   no conduit should be used (and direct approvals set on\\n     *                   Consideration) and `address(1)` signifies to utilize\\n     *                   the legacy token transfer proxy for the transfer.\\n     */\\n    function _transferERC20(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        address conduit\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // If no conduit has been specified...\\n        if (conduit == address(0)) {\\n            // Perform the token transfer directly.\\n            _performDirectERC20Transfer(token, from, to, amount);\\n        } else if (conduit == address(1)) {\\n            // Perform transfer via a call to the legacy token transfer proxy.\\n            bool success = _LEGACY_TOKEN_TRANSFER_PROXY.transferFrom(\\n                token,\\n                from,\\n                to,\\n                amount\\n            );\\n\\n            // If the call to the token transfer proxy does not return true...\\n            if (!success) {\\n                // Revert with an error indicating that return value is falsey.\\n                // Note that the legacy token transfer proxy does not support\\n                // non-compliant ERC20 tokens that do not return any data on a\\n                // successful transfer.\\n                revert BadReturnValueFromERC20OnTransfer(\\n                    token,\\n                    from,\\n                    to,\\n                    amount\\n                );\\n            }\\n        } else {\\n            revert(\\\"Not yet implemented\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on this\\n     *      contract.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performDirectERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // Write calldata to the free memory pointer, but restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write calldata into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // to copy up to 32 bytes of return data to scratch space.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                0x20\\n            )\\n\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // If the transfer failed or it returned nothing:\\n            // Group these because they should be uncommon.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed:\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up:\\n                            if returndatasize() {\\n                                // Copy returndata to memory; overwrite existing\\n                                // memory.\\n                                returndatacopy(0, 0, returndatasize())\\n\\n                                // Revert, specifying memory region with copied\\n                                // returndata.\\n                                revert(0, returndatasize())\\n                            }\\n\\n                            // Otherwise revert with a generic error message.\\n                            mstore(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_signature\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n                            revert(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false.\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n                        revert(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            TokenTransferGenericFailure_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise revert with error about token not having code:\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Otherwise the token just returned nothing but otherwise\\n                // succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a single ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set,\\n     *      either on the respective conduit or on this contract itself.\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     * @param amount     The \\\"amount\\\" (this value must be equal to one).\\n     * @param conduit    An address indicating what conduit, if any, to source\\n     *                   token approvals from. The null address signifies that\\n     *                   no conduit should be used (and direct approvals set on\\n     *                   Consideration) and `address(1)` signifies to utilize\\n     *                   the legacy user proxy for the transfer.\\n     */\\n    function _transferERC721(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        address conduit\\n    ) internal {\\n        // Ensure that exactly one 721 item is being transferred.\\n        if (amount != 1) {\\n            revert InvalidERC721TransferAmount();\\n        }\\n\\n        // If no conduit has been specified...\\n        if (conduit == address(0)) {\\n            // Perform transfer via the token contract directly.\\n            assembly {\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Write calldata to the free memory pointer (restore it later).\\n                let memPointer := mload(FreeMemoryPointerSlot)\\n\\n                // Write calldata into memory starting with function selector.\\n                mstore(\\n                    ERC721_transferFrom_sig_ptr,\\n                    ERC721_transferFrom_signature\\n                )\\n                mstore(ERC721_transferFrom_from_ptr, from)\\n                mstore(ERC721_transferFrom_to_ptr, to)\\n                mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ERC721_transferFrom_sig_ptr,\\n                    ERC721_transferFrom_length,\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up:\\n                    if returndatasize() {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, specifying memory region with returndata.\\n                        revert(0, returndatasize())\\n                    }\\n\\n                    // Otherwise revert with a generic error message.\\n                    mstore(\\n                        TokenTransferGenericFailure_error_sig_ptr,\\n                        TokenTransferGenericFailure_error_signature\\n                    )\\n                    mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                    mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                    mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                    mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                    mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                    revert(\\n                        TokenTransferGenericFailure_error_sig_ptr,\\n                        TokenTransferGenericFailure_error_length\\n                    )\\n                }\\n\\n                // Restore the original free memory pointer.\\n                mstore(FreeMemoryPointerSlot, memPointer)\\n\\n                // Restore the zero slot to zero.\\n                mstore(ZeroSlot, 0)\\n            }\\n        } else if (conduit == address(1)) {\\n            // Perform transfer via a call to the proxy for the supplied owner.\\n            bool success = _callProxy(\\n                from,\\n                token,\\n                abi.encodeCall(\\n                    ERC721Interface.transferFrom,\\n                    (from, to, identifier)\\n                )\\n            );\\n\\n            // Ensure that the transfer succeeded.\\n            _assertValidTokenTransfer(\\n                success,\\n                token,\\n                from,\\n                to,\\n                identifier,\\n                amount\\n            );\\n        } else {\\n            revert(\\\"Not yet implemented\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set, either on\\n     *      the respective conduit or on this contract itself.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     * @param amount     The amount to transfer.\\n     * @param conduit    An address indicating what conduit, if any, to source\\n     *                   token approvals from. The null address signifies that\\n     *                   no conduit should be used (and direct approvals set on\\n     *                   Consideration) and `address(1)` signifies to utilize\\n     *                   the legacy user proxy for the transfer.\\n     */\\n    function _transferERC1155(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        address conduit\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // If no conduit has been specified...\\n        if (conduit == address(0)) {\\n            // Perform transfer via the token contract directly.\\n            assembly {\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Write calldata to these slots below, but restore them later.\\n                let memPointer := mload(FreeMemoryPointerSlot)\\n                let slot0x80 := mload(0x80)\\n                let slot0xA0 := mload(0xA0)\\n\\n                // Write calldata into memory, beginning with function selector.\\n                mstore(\\n                    ERC1155_safeTransferFrom_sig_ptr,\\n                    ERC1155_safeTransferFrom_signature\\n                )\\n                mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n                mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n                mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n                mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n                mstore(\\n                    ERC1155_safeTransferFrom_data_offset_ptr,\\n                    ERC1155_safeTransferFrom_data_length_offset\\n                )\\n                mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ERC1155_safeTransferFrom_sig_ptr,\\n                    ERC1155_safeTransferFrom_length,\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up:\\n                    if returndatasize() {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert; specify memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n\\n                    // Otherwise revert with a generic error message.\\n                    mstore(\\n                        TokenTransferGenericFailure_error_sig_ptr,\\n                        TokenTransferGenericFailure_error_signature\\n                    )\\n                    mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                    mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                    mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                    mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                    mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                    revert(\\n                        TokenTransferGenericFailure_error_sig_ptr,\\n                        TokenTransferGenericFailure_error_length\\n                    )\\n                }\\n\\n                mstore(0x80, slot0x80) // Restore slot 0x80.\\n                mstore(0xA0, slot0xA0) // Restore slot 0xA0.\\n\\n                // Restore the original free memory pointer.\\n                mstore(FreeMemoryPointerSlot, memPointer)\\n\\n                // Restore the zero slot to zero.\\n                mstore(ZeroSlot, 0)\\n            }\\n        } else if (conduit == address(1)) {\\n            // Perform transfer via a call to the proxy for the supplied owner.\\n            bool success = _callProxy(\\n                from,\\n                token,\\n                abi.encodeWithSelector(\\n                    ERC1155Interface.safeTransferFrom.selector,\\n                    from,\\n                    to,\\n                    identifier,\\n                    amount,\\n                    \\\"\\\"\\n                )\\n            );\\n\\n            // Ensure that the transfer succeeded.\\n            _assertValidTokenTransfer(\\n                success,\\n                token,\\n                from,\\n                to,\\n                identifier,\\n                amount\\n            );\\n        } else {\\n            revert(\\\"Not yet implemented\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a batch of ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set,\\n     *      either on the respective conduit or on this contract itself.\\n     *\\n     * @param batchExecution The batch of 1155 tokens to be transferred.\\n     */\\n    function _batchTransferERC1155(BatchExecution memory batchExecution)\\n        internal\\n    {\\n        // Place elements of the batch execution in memory onto the stack.\\n        address conduit = batchExecution.conduit;\\n        address token = batchExecution.token;\\n        address from = batchExecution.from;\\n        address to = batchExecution.to;\\n\\n        // Retrieve the tokenIds and amounts.\\n        uint256[] memory tokenIds = batchExecution.tokenIds;\\n        uint256[] memory amounts = batchExecution.amounts;\\n\\n        bool success;\\n\\n        // If no conduit has been specified...\\n        if (conduit == address(0)) {\\n            // Perform transfer via the token contract directly.\\n            (success, ) = token.call(\\n                abi.encodeWithSelector(\\n                    ERC1155Interface.safeBatchTransferFrom.selector,\\n                    from,\\n                    to,\\n                    tokenIds,\\n                    amounts,\\n                    \\\"\\\"\\n                )\\n            );\\n        } else if (conduit == address(1)) {\\n            // Perform transfer via a call to the proxy for the supplied owner.\\n            success = _callProxy(\\n                from,\\n                token,\\n                abi.encodeWithSelector(\\n                    ERC1155Interface.safeBatchTransferFrom.selector,\\n                    from,\\n                    to,\\n                    tokenIds,\\n                    amounts,\\n                    \\\"\\\"\\n                )\\n            );\\n        } else {\\n            revert(\\\"Not yet implemented\\\");\\n        }\\n\\n        // If the call fails...\\n        if (!success) {\\n            // Revert and pass the revert reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic 1155 batch transfer error.\\n            revert ERC1155BatchTransferGenericFailure(\\n                token,\\n                from,\\n                to,\\n                tokenIds,\\n                amounts\\n            );\\n        }\\n\\n        // Ensure that a contract is deployed to the token address.\\n        _assertContractIsDeployed(token);\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to a proxy contract. The proxy\\n     *      contract must be registered on the legacy proxy registry for the\\n     *      given proxy owner and must declare that its implementation matches\\n     *      the required proxy implementation in accordance with EIP-897.\\n     *\\n     * @param proxyOwner The original owner of the proxy in question. Note that\\n     *                   this owner may have been modified since the proxy was\\n     *                   originally deployed.\\n     * @param target     The account that should be called by the proxy.\\n     * @param callData   The calldata to supply when calling the target from the\\n     *                   proxy.\\n     *\\n     * @return success The status of the call to the proxy.\\n     */\\n    function _callProxy(\\n        address proxyOwner,\\n        address target,\\n        bytes memory callData\\n    ) internal returns (bool success) {\\n        // Retrieve the user proxy from the registry assuming one is set.\\n        address proxy = _LEGACY_PROXY_REGISTRY.proxies(proxyOwner);\\n\\n        // Assert that the user proxy has the correct implementation.\\n        if (\\n            ProxyInterface(proxy).implementation() !=\\n            _REQUIRED_PROXY_IMPLEMENTATION\\n        ) {\\n            revert InvalidProxyImplementation();\\n        }\\n\\n        // perform call to proxy via proxyAssert and HowToCall = CALL (value 0).\\n        (success, ) = proxy.call(\\n            abi.encodeWithSelector(\\n                ProxyInterface.proxyAssert.selector,\\n                target,\\n                0,\\n                callData\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer Ether (or other native tokens) to a\\n     *      given recipient as part of basic order fulfillment. Note that\\n     *      proxies are not utilized for native tokens as the transferred amount\\n     *      must be provided as msg.value.\\n     *\\n     * @param amount      The amount to transfer.\\n     * @param parameters  The parameters of the basic order in question.\\n     */\\n    function _transferEthAndFinalize(\\n        uint256 amount,\\n        BasicOrderParameters calldata parameters\\n    ) internal {\\n        // Put ether value supplied by the caller on the stack.\\n        uint256 etherRemaining = msg.value;\\n\\n        // Iterate over each additional recipient.\\n        for (uint256 i = 0; i < parameters.additionalRecipients.length; ) {\\n            // Retrieve the additional recipient.\\n            AdditionalRecipient calldata additionalRecipient = (\\n                parameters.additionalRecipients[i]\\n            );\\n\\n            // Read ether amount to transfer to recipient and place on stack.\\n            uint256 additionalRecipientAmount = additionalRecipient.amount;\\n\\n            // Ensure that sufficient Ether is available.\\n            if (additionalRecipientAmount > etherRemaining) {\\n                revert InsufficientEtherSupplied();\\n            }\\n\\n            // Transfer Ether to the additional recipient.\\n            _transferEth(\\n                additionalRecipient.recipient,\\n                additionalRecipientAmount\\n            );\\n\\n            // Skip underflow check as subtracted value is less than remaining.\\n            unchecked {\\n                // Reduce ether value available.\\n                etherRemaining -= additionalRecipientAmount;\\n            }\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Ensure that sufficient Ether is still available.\\n        if (amount > etherRemaining) {\\n            revert InsufficientEtherSupplied();\\n        }\\n\\n        // Transfer Ether to the offerer.\\n        _transferEth(parameters.offerer, amount);\\n\\n        // If any Ether remains after transfers, return it to the caller.\\n        if (etherRemaining > amount) {\\n            // Skip underflow check as etherRemaining > amount.\\n            unchecked {\\n                // Transfer remaining Ether to the caller.\\n                _transferEth(payable(msg.sender), etherRemaining - amount);\\n            }\\n        }\\n\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\\n     *      part of basic order fulfillment. Note that proxies are not utilized\\n     *      for ERC20 tokens.\\n     *\\n     * @param from        The originator of the ERC20 token transfer.\\n     * @param to          The recipient of the ERC20 token transfer.\\n     * @param erc20Token  The ERC20 token to transfer.\\n     * @param amount      The amount of ERC20 tokens to transfer.\\n     * @param parameters  The parameters of the order.\\n     * @param fromOfferer Whether to decrement amount from the offered amount.\\n     */\\n    function _transferERC20AndFinalize(\\n        address from,\\n        address to,\\n        address erc20Token,\\n        uint256 amount,\\n        BasicOrderParameters calldata parameters,\\n        bool fromOfferer\\n    ) internal {\\n        // Determine the appropriate conduit to utilize.\\n        address conduit = fromOfferer\\n            ? parameters.offererConduit\\n            : parameters.fulfillerConduit;\\n\\n        // Iterate over each additional recipient.\\n        for (uint256 i = 0; i < parameters.additionalRecipients.length; ) {\\n            // Retrieve the additional recipient.\\n            AdditionalRecipient calldata additionalRecipient = (\\n                parameters.additionalRecipients[i]\\n            );\\n\\n            // Decrement the amount to transfer to fulfiller if indicated.\\n            if (fromOfferer) {\\n                amount -= additionalRecipient.amount;\\n            }\\n\\n            // Transfer ERC20 tokens to additional recipient given approval.\\n            _transferERC20(\\n                erc20Token,\\n                from,\\n                additionalRecipient.recipient,\\n                additionalRecipient.amount,\\n                conduit\\n            );\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Transfer ERC20 token amount (from account must have proper approval).\\n        _transferERC20(erc20Token, from, to, amount, conduit);\\n\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to ensure that the sentinel value for the\\n     *      reentrancy guard is not currently set and, if not, to set the\\n     *      sentinel value for the reentrancy guard.\\n     */\\n    function _setReentrancyGuard() internal {\\n        // Ensure that the reentrancy guard is not already set.\\n        _assertNonReentrant();\\n\\n        // Set the reentrancy guard.\\n        _reentrancyGuard = _ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\\n     *      translated into SpentItems and ConsiderationItems are translated\\n     *      into ReceivedItems.\\n     *\\n     * @param orderHash     The order hash.\\n     * @param offerer       The offerer for the order.\\n     * @param zone          The zone for the order.\\n     * @param fulfiller     The fulfiller of the order, or the null address if\\n     *                      the order was fulfilled via order matching.\\n     * @param offer         The offer items for the order.\\n     * @param consideration The consideration items for the order.\\n     */\\n    function _emitOrderFulfilledEvent(\\n        bytes32 orderHash,\\n        address offerer,\\n        address zone,\\n        address fulfiller,\\n        OfferItem[] memory offer,\\n        ConsiderationItem[] memory consideration\\n    ) internal {\\n        // Cast already-modified offer memory region as spent items.\\n        SpentItem[] memory spentItems;\\n        assembly {\\n            spentItems := offer\\n        }\\n\\n        // Cast already-modified consideration memory region as received items.\\n        ReceivedItem[] memory receivedItems;\\n        assembly {\\n            receivedItems := consideration\\n        }\\n\\n        // Emit an event signifying that the order has been fulfilled.\\n        emit OrderFulfilled(\\n            orderHash,\\n            offerer,\\n            zone,\\n            fulfiller,\\n            spentItems,\\n            receivedItems\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x65085939c0629864093f55bfc825ea66a255ef7468df52e0e68625fe361feaac\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationInternalView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { EIP1271Interface } from \\\"../interfaces/EIP1271Interface.sol\\\";\\n\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\n\\nimport { OrderType, ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    Execution,\\n    FulfillmentComponent\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { ConsiderationPure } from \\\"./ConsiderationPure.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title ConsiderationInternalView\\n * @author 0age\\n * @notice ConsiderationInternal contains all internal view functions.\\n */\\ncontract ConsiderationInternalView is ConsiderationPure {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param legacyProxyRegistry         A proxy registry that stores per-user\\n     *                                    proxies that may optionally be used to\\n     *                                    transfer approved ERC721+1155 tokens.\\n     * @param legacyTokenTransferProxy    A shared proxy contract that may\\n     *                                    optionally be used to transfer\\n     *                                    approved ERC20 tokens.\\n     * @param requiredProxyImplementation The implementation that must be set on\\n     *                                    each proxy in order to utilize it.\\n     */\\n    constructor(\\n        address legacyProxyRegistry,\\n        address legacyTokenTransferProxy,\\n        address requiredProxyImplementation\\n    )\\n        ConsiderationPure(\\n            legacyProxyRegistry,\\n            legacyTokenTransferProxy,\\n            requiredProxyImplementation\\n        )\\n    {}\\n\\n    /**\\n     * @dev Internal view function to ensure that the sentinel value for the\\n            reentrancy guard is not currently set.\\n     */\\n    function _assertNonReentrant() internal view {\\n        // Ensure that the reentrancy guard is not currently set.\\n        if (_reentrancyGuard != _NOT_ENTERED) {\\n            revert NoReentrantCalls();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that the current time falls within\\n     *      an order's valid timespan.\\n     *\\n     * @param startTime       The time at which the order becomes active.\\n     * @param endTime         The time at which the order becomes inactive.\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\n     *                        order is not active.\\n     *\\n     * @return valid A boolean indicating whether the order is active.\\n     */\\n    function _verifyTime(\\n        uint256 startTime,\\n        uint256 endTime,\\n        bool revertOnInvalid\\n    ) internal view returns (bool valid) {\\n        // Revert if order's timespan hasn't started yet or has already ended.\\n        if (startTime > block.timestamp || endTime <= block.timestamp) {\\n            // Only revert if revertOnInvalid has been supplied as true.\\n            if (revertOnInvalid) {\\n                revert InvalidTime();\\n            }\\n\\n            // Return false as the order is invalid.\\n            return false;\\n        }\\n\\n        // Return true as the order time is valid.\\n        valid = true;\\n    }\\n\\n    /**\\n     * @dev Internal view function to validate whether a token transfer was\\n     *      successful based on the returned status and data. Note that\\n     *      malicious or non-compliant tokens (like fee-on-transfer tokens) may\\n     *      still return improper data \\u2014 consider checking token balances before\\n     *      and after for more comprehensive transfer validation. Also note that\\n     *      this function must be called after the account in question has been\\n     *      called and before any other contracts have been called.\\n     *\\n     * @param success The status of the call to transfer. Note that contract\\n     *                size must be checked on status of true and no returned\\n     *                data to rule out undeployed contracts.\\n     * @param token   The token to transfer.\\n     * @param from    The originator of the transfer.\\n     * @param to      The recipient of the transfer.\\n     * @param tokenId The tokenId to transfer (if applicable).\\n     * @param amount  The amount to transfer (if applicable).\\n     */\\n    function _assertValidTokenTransfer(\\n        bool success,\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) internal view {\\n        // If the call failed...\\n        if (!success) {\\n            // Revert and pass reason along if one was returned from the token.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error.\\n            revert TokenTransferGenericFailure(\\n                token,\\n                from,\\n                to,\\n                tokenId,\\n                amount\\n            );\\n        }\\n\\n        // Ensure that the token contract has code.\\n        _assertContractIsDeployed(token);\\n    }\\n\\n    /**\\n     * @dev Internal view function to item that a contract is deployed to a\\n     *      given account. Note that this function must be called after the\\n     *      account in question has been called and before any other contracts\\n     *      have been called.\\n     *\\n     * @param account The account to check.\\n     */\\n    function _assertContractIsDeployed(address account) internal view {\\n        // Find out whether data was returned by inspecting returndata buffer.\\n        uint256 returnDataSize;\\n        assembly {\\n            returnDataSize := returndatasize()\\n        }\\n\\n        // If no data was returned, ensure that the account has code.\\n        if (returnDataSize == 0 && account.code.length == 0) {\\n            revert NoContract(account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to verify the signature of an order. An\\n     *      ERC-1271 fallback will be attempted if either the signature length\\n     *      is not 32 or 33 bytes or if the recovered signer does not match the\\n     *      supplied offerer. Note that in cases where a 32 or 33 byte signature\\n     *      is supplied, only standard ECDSA signatures that recover to a\\n     *      non-zero address are supported.\\n     *\\n     * @param offerer   The offerer for the order.\\n     * @param orderHash The order hash.\\n     * @param signature A signature from the offerer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _verifySignature(\\n        address offerer,\\n        bytes32 orderHash,\\n        bytes memory signature\\n    ) internal view {\\n        // Skip signature verification if the offerer is the caller.\\n        if (offerer == msg.sender) {\\n            return;\\n        }\\n\\n        // Derive EIP-712 digest using the domain separator and the order hash.\\n        bytes32 digest = _hashDigest(_domainSeparator(), orderHash);\\n\\n        // Declare r, s, and v signature parameters.\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // If signature contains 64 bytes, parse as EIP-2098 signature. (r+s&v)\\n        if (signature.length == 64) {\\n            // Declare temporary vs that will be decomposed into s and v.\\n            bytes32 vs;\\n\\n            // Read each parameter directly from the signature's memory region.\\n            assembly {\\n                // Put the first word from the signature onto the stack as r.\\n                r := mload(add(signature, 0x20))\\n\\n                // Put the second word from the signature onto the stack as vs.\\n                vs := mload(add(signature, 0x40))\\n\\n                // Extract canonical s from vs (all but the highest bit).\\n                s := and(vs, EIP2098_allButHighestBitMask)\\n\\n                // Extract yParity from highest bit of vs and add 27 to get v.\\n                v := add(shr(255, vs), 27)\\n            }\\n            // If signature is 65 bytes, parse as a standard signature. (r+s+v)\\n        } else if (signature.length == 65) {\\n            // Read each parameter directly from the signature's memory region.\\n            assembly {\\n                r := mload(add(signature, 0x20)) // Put first word on stack at r\\n                s := mload(add(signature, 0x40)) // Put next word on stack at s\\n                v := byte(0, mload(add(signature, 0x60))) // Put last byte at v\\n            }\\n\\n            // Ensure v value is properly formatted.\\n            if (v != 27 && v != 28) {\\n                revert BadSignatureV(v);\\n            }\\n            // For all other signature lengths, try verification via EIP-1271.\\n        } else {\\n            // Attempt EIP-1271 static call to offerer in case it's a contract.\\n            _verifySignatureViaERC1271(offerer, digest, signature);\\n\\n            // Return early if the ERC-1271 signature check succeeded.\\n            return;\\n        }\\n\\n        // Attempt to recover signer using the digest and signature parameters.\\n        address signer = ecrecover(digest, v, r, s);\\n\\n        // Disallow invalid signers.\\n        if (signer == address(0)) {\\n            revert InvalidSignature();\\n            // Should a signer be recovered, but it doesn't match the offerer...\\n        } else if (signer != offerer) {\\n            // Attempt EIP-1271 static call to offerer in case it's a contract.\\n            _verifySignatureViaERC1271(offerer, digest, signature);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to verify the signature of an order using\\n     *      ERC-1271 (i.e. contract signatures via `isValidSignature`).\\n     *\\n     * @param offerer   The offerer for the order.\\n     * @param digest    The signature digest, derived from the domain separator\\n     *                  and the order hash.\\n     * @param signature A signature (or other data) used to validate the digest.\\n     */\\n    function _verifySignatureViaERC1271(\\n        address offerer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view {\\n        // Attempt an EIP-1271 staticcall to the offerer.\\n        bool success = _staticcall(\\n            offerer,\\n            abi.encodeWithSelector(\\n                EIP1271Interface.isValidSignature.selector,\\n                digest,\\n                signature\\n            )\\n        );\\n\\n        // If the call fails...\\n        if (!success) {\\n            // Revert and pass reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            revert BadContractSignature();\\n        }\\n\\n        // Extract result from returndata buffer in case of memory overflow.\\n        bytes4 result;\\n        assembly {\\n            // Only put result on stack if return data is exactly 32 bytes.\\n            if eq(returndatasize(), 0x20) {\\n                // Copy directly from return data into scratch space.\\n                returndatacopy(0, 0, 0x20)\\n\\n                // Take value from scratch space and place it on the stack.\\n                result := mload(0)\\n            }\\n        }\\n\\n        // Ensure result was extracted and matches EIP-1271 magic value.\\n        if (result != EIP1271Interface.isValidSignature.selector) {\\n            revert InvalidSigner();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to staticcall an arbitrary target with given\\n     *      calldata. Note that no data is written to memory and no contract\\n     *      size check is performed.\\n     *\\n     * @param target   The account to staticcall.\\n     * @param callData The calldata to supply when staticcalling the target.\\n     *\\n     * @return success The status of the staticcall to the target.\\n     */\\n    function _staticcall(address target, bytes memory callData)\\n        internal\\n        view\\n        returns (bool success)\\n    {\\n        (success, ) = target.staticcall(callData);\\n    }\\n\\n    /**\\n     * @dev Internal view function to get the EIP-712 domain separator. If the\\n     *      chainId matches the chainId set on deployment, the cached domain\\n     *      separator will be returned; otherwise, it will be derived from\\n     *      scratch.\\n     */\\n    function _domainSeparator() internal view returns (bytes32) {\\n        // prettier-ignore\\n        return block.chainid == _CHAIN_ID\\n            ? _DOMAIN_SEPARATOR\\n            : _deriveDomainSeparator();\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the order hash for a given order.\\n     *      Note that only the original consideration items are included in the\\n     *      order hash, as additional consideration items may be supplied by the\\n     *      caller.\\n     *\\n     * @param orderParameters The parameters of the order to hash.\\n     * @param nonce           The nonce of the order to hash.\\n     *\\n     * @return orderHash The hash.\\n     */\\n    function _getOrderHash(\\n        OrderParameters memory orderParameters,\\n        uint256 nonce\\n    ) internal view returns (bytes32 orderHash) {\\n        // Get length of original consideration array and place it on the stack.\\n        uint256 originalConsiderationLength = (\\n            orderParameters.totalOriginalConsiderationItems\\n        );\\n\\n        /*\\n         * Memory layout for an array of structs (dynamic or not) is similar\\n         * to ABI encoding of dynamic types, with a head segment followed by\\n         * a data segment. The main difference is that the head of an element\\n         * is a memory pointer rather than an offset.\\n         */\\n\\n        // Declare a variable for the derived hash of the offer array.\\n        bytes32 offerHash;\\n\\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\n\\n        // Utilize assembly so that memory regions can be reused across hashes.\\n        assembly {\\n            // Retrieve the free memory pointer and place on the stack.\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\n\\n            // Get the pointer to the offers array.\\n            let offerArrPtr := mload(add(orderParameters, 0x40))\\n\\n            // Load the length.\\n            let offerLength := mload(offerArrPtr)\\n\\n            // Set the pointer to the first offer's head.\\n            offerArrPtr := add(offerArrPtr, 0x20)\\n\\n            // Iterate over the offer items.\\n            // prettier-ignore\\n            for { let i := 0 } lt(i, offerLength) {\\n                i := add(i, 1)\\n            } {\\n                // Read the pointer to the offer data and subtract 32\\n                // to get typeHash pointer.\\n                let ptr := sub(mload(offerArrPtr), 0x20)\\n\\n                // Read the current value before the offer data.\\n                let value := mload(ptr)\\n\\n                // Write the type hash to the previous word.\\n                mstore(ptr, typeHash)\\n\\n                // Take the EIP712 hash and store it in the hash array.\\n                mstore(hashArrPtr, keccak256(ptr, 0xc0))\\n\\n                // Restore the previous word.\\n                mstore(ptr, value)\\n\\n                // Increment the array pointers.\\n                offerArrPtr := add(offerArrPtr, 0x20)\\n                hashArrPtr := add(hashArrPtr, 0x20)\\n            }\\n\\n            // Derive the offer hash.\\n            offerHash := keccak256(\\n                mload(FreeMemoryPointerSlot),\\n                mul(offerLength, 0x20)\\n            )\\n        }\\n\\n        // Declare a variable for the derived hash of the consideration array.\\n        bytes32 considerationHash;\\n\\n        // Read consideration item typehash from runtime code & place on stack.\\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\n\\n        // Utilize assembly so that memory regions can be reused across hashes.\\n        assembly {\\n            // Retrieve the free memory pointer and place on the stack.\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\n\\n            // Get the pointer to the consideration array.\\n            let considerationArrPtr := add(\\n                mload(add(orderParameters, 0x60)),\\n                0x20\\n            )\\n\\n            // Iterate over the offer items.\\n            // prettier-ignore\\n            for { let i := 0 } lt(i, originalConsiderationLength) {\\n                i := add(i, 1)\\n            } {\\n                // Read the pointer to the consideration data and subtract 32\\n                // to get typeHash pointer.\\n                let ptr := sub(mload(considerationArrPtr), 0x20)\\n\\n                // Read the current value before the consideration data.\\n                let value := mload(ptr)\\n\\n                // Write the type hash to the previous word.\\n                mstore(ptr, typeHash)\\n\\n                // Take the EIP712 hash and store it in the hash array.\\n                mstore(hashArrPtr, keccak256(ptr, 0xe0))\\n\\n                // Restore the previous word.\\n                mstore(ptr, value)\\n\\n                // Increment the array pointers.\\n                considerationArrPtr := add(considerationArrPtr, 0x20)\\n                hashArrPtr := add(hashArrPtr, 0x20)\\n            }\\n\\n            // Derive the offer hash.\\n            considerationHash := keccak256(\\n                mload(FreeMemoryPointerSlot),\\n                mul(originalConsiderationLength, 0x20)\\n            )\\n        }\\n\\n        // Read order item EIP-712 typehash from runtime code & place on stack.\\n        typeHash = _ORDER_TYPEHASH;\\n\\n        // Utilize assembly to access derived hashes & other arguments directly.\\n        assembly {\\n            let typeHashPtr := sub(orderParameters, 0x20)\\n            let previousValue := mload(typeHashPtr)\\n            mstore(typeHashPtr, typeHash)\\n\\n            let offerHeadPtr := add(orderParameters, 0x40)\\n            let offerDataPtr := mload(offerHeadPtr)\\n            mstore(offerHeadPtr, offerHash)\\n\\n            let considerationHeadPtr := add(orderParameters, 0x60)\\n            let considerationDataPtr := mload(considerationHeadPtr)\\n            mstore(considerationHeadPtr, considerationHash)\\n\\n            let noncePtr := add(orderParameters, 0x140)\\n            mstore(noncePtr, nonce)\\n\\n            orderHash := keccak256(typeHashPtr, 0x180)\\n            mstore(typeHashPtr, previousValue)\\n            mstore(offerHeadPtr, offerDataPtr)\\n            mstore(considerationHeadPtr, considerationDataPtr)\\n            mstore(noncePtr, originalConsiderationLength)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to to ensure that the supplied consideration\\n     *      array length on a given set of order parameters is not less than the\\n     *      original consideration array length for that order and to retrieve\\n     *      the current nonce for a given order's offerer and zone and use it to\\n     *      derive the order hash.\\n     *\\n     * @param orderParameters The parameters of the order to hash.\\n     *\\n     * @return The hash.\\n     */\\n    function _assertConsiderationLengthAndGetNoncedOrderHash(\\n        OrderParameters memory orderParameters\\n    ) internal view returns (bytes32) {\\n        // Ensure supplied consideration array length is not less than original.\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n            orderParameters.consideration.length,\\n            orderParameters.totalOriginalConsiderationItems\\n        );\\n\\n        // Derive and return order hash using current nonce for the offerer.\\n        return _getOrderHash(orderParameters, _nonces[orderParameters.offerer]);\\n    }\\n\\n    /**\\n     * @dev Internal view function to determine if an order has a restricted\\n     *      order type and, if so, to ensure that either the offerer or the zone\\n     *      are the fulfiller or that a staticcall to `isValidOrder` on the zone\\n     *      returns a magic value indicating that the order is currently valid.\\n     *\\n     * @param orderHash The hash of the order.\\n     * @param zoneHash  The hash to provide upon calling the zone.\\n     * @param orderType The type of the order.\\n     * @param offerer   The offerer in question.\\n     * @param zone      The zone in question.\\n     */\\n    function _assertRestrictedBasicOrderValidity(\\n        bytes32 orderHash,\\n        bytes32 zoneHash,\\n        OrderType orderType,\\n        address offerer,\\n        address zone\\n    ) internal view {\\n        // Order type 2-3 require zone or offerer be caller or zone to approve.\\n        if (\\n            uint256(orderType) > 1 &&\\n            msg.sender != zone &&\\n            msg.sender != offerer\\n        ) {\\n            // Perform minimal staticcall to the zone.\\n            bool success = _staticcall(\\n                zone,\\n                abi.encodeWithSelector(\\n                    ZoneInterface.isValidOrder.selector,\\n                    orderHash,\\n                    msg.sender,\\n                    offerer,\\n                    zoneHash\\n                )\\n            );\\n\\n            // Ensure call was successful and returned the correct magic value.\\n            _assertIsValidOrderStaticcallSuccess(success, orderHash);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to determine if a proxy should be utilized\\n     *      for a given order and to ensure that the submitter is allowed by the\\n     *      order type.\\n     *\\n     * @param advancedOrder    The order in question.\\n     * @param priorOrderHashes The order hashes of each order supplied prior to\\n     *                         the current order as part of a \\\"match\\\" variety of\\n     *                         order fulfillment (e.g. this array will be empty\\n     *                         for single or \\\"fulfill available\\\").\\n     * @param orderHash        The hash of the order.\\n     * @param zoneHash         The hash to provide upon calling the zone.\\n     * @param orderType        The type of the order.\\n     * @param offerer          The offerer in question.\\n     * @param zone             The zone in question.\\n\\n     */\\n    function _assertRestrictedAdvancedOrderValidity(\\n        AdvancedOrder memory advancedOrder,\\n        bytes32[] memory priorOrderHashes,\\n        bytes32 orderHash,\\n        bytes32 zoneHash,\\n        OrderType orderType,\\n        address offerer,\\n        address zone\\n    ) internal view {\\n        // Order type 2-3 require zone or offerer be caller or zone to approve.\\n        if (\\n            uint256(orderType) > 1 &&\\n            msg.sender != zone &&\\n            msg.sender != offerer\\n        ) {\\n            // Declare a variable for the status of the staticcall to the zone.\\n            bool success;\\n\\n            // If no extraData is supplied...\\n            if (advancedOrder.extraData.length == 0) {\\n                // Perform minimal staticcall to the zone.\\n                success = _staticcall(\\n                    zone,\\n                    abi.encodeWithSelector(\\n                        ZoneInterface.isValidOrder.selector,\\n                        orderHash,\\n                        msg.sender,\\n                        offerer,\\n                        zoneHash\\n                    )\\n                );\\n            } else {\\n                // Otherwise, extraData was supplied; in that event, perform a\\n                // more verbose staticcall to the zone.\\n                success = _staticcall(\\n                    zone,\\n                    abi.encodeWithSelector(\\n                        ZoneInterface.isValidOrderIncludingExtraData.selector,\\n                        orderHash,\\n                        msg.sender,\\n                        advancedOrder,\\n                        priorOrderHashes\\n                    )\\n                );\\n            }\\n\\n            // Ensure call was successful and returned the correct magic value.\\n            _assertIsValidOrderStaticcallSuccess(success, orderHash);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to match offer items to consideration items\\n     *      on a group of orders via a supplied fulfillment.\\n     *\\n     * @param advancedOrders          The orders to match.\\n     * @param offerComponents         An array designating offer components to\\n     *                                match to consideration components.\\n     * @param considerationComponents An array designating consideration\\n     *                                components to match to offer components.\\n     *                                Note that each consideration amount must\\n     *                                be zero in order for the match operation\\n     *                                to be valid.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _applyFulfillment(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory offerComponents,\\n        FulfillmentComponent[] memory considerationComponents\\n    ) internal view returns (Execution memory execution) {\\n        // Ensure 1+ of both offer and consideration components are supplied.\\n        if (\\n            offerComponents.length == 0 || considerationComponents.length == 0\\n        ) {\\n            revert OfferAndConsiderationRequiredOnFulfillment();\\n        }\\n\\n        // Validate and aggregate consideration items and store the result as a\\n        // ReceivedItem.\\n        ReceivedItem memory considerationItem = (\\n            _aggregateValidFulfillmentConsiderationItems(\\n                advancedOrders,\\n                considerationComponents,\\n                0\\n            )\\n        );\\n\\n        // Validate & aggregate offer items and store result as an Execution.\\n        (\\n            execution\\n            /**\\n             * ItemType itemType,\\n             * address token,\\n             * uint256 identifier,\\n             * address offerer,\\n             * address conduit,\\n             * uint256 offerAmount\\n             */\\n        ) = _aggregateValidFulfillmentOfferItems(\\n            advancedOrders,\\n            offerComponents,\\n            0\\n        );\\n\\n        // Ensure offer and consideration share types, tokens and identifiers.\\n        if (\\n            execution.item.itemType != considerationItem.itemType ||\\n            execution.item.token != considerationItem.token ||\\n            execution.item.identifier != considerationItem.identifier\\n        ) {\\n            revert MismatchedFulfillmentOfferAndConsiderationComponents();\\n        }\\n\\n        // If total consideration amount exceeds the offer amount...\\n        if (considerationItem.amount > execution.item.amount) {\\n            // Retrieve the first consideration component from the fulfillment.\\n            FulfillmentComponent memory targetComponent = (\\n                considerationComponents[0]\\n            );\\n\\n            // Add excess consideration item amount to original array of orders.\\n            advancedOrders[targetComponent.orderIndex]\\n                .parameters\\n                .consideration[targetComponent.itemIndex]\\n                .startAmount = considerationItem.amount - execution.item.amount;\\n\\n            // Reduce total consideration amount to equal the offer amount.\\n            considerationItem.amount = execution.item.amount;\\n        } else {\\n            // Retrieve the first offer component from the fulfillment.\\n            FulfillmentComponent memory targetComponent = (offerComponents[0]);\\n\\n            // Add excess offer item amount to the original array of orders.\\n            advancedOrders[targetComponent.orderIndex]\\n                .parameters\\n                .offer[targetComponent.itemIndex]\\n                .startAmount = execution.item.amount - considerationItem.amount;\\n        }\\n\\n        // Reuse execution struct with consideration amount and recipient.\\n        execution.item.amount = considerationItem.amount;\\n        execution.item.recipient = considerationItem.recipient;\\n\\n        // Return the final execution that will be triggered for relevant items.\\n        return execution; // Execution(considerationItem, offerer, conduit);\\n    }\\n\\n    /**\\n     * 2. Here's the summary of this section\\n     * blah blah blah\\n     */\\n\\n    /**\\n     * @dev Internal view function to aggregate offer or consideration items\\n     *      from a group of orders into a single execution via a supplied array\\n     *      of fulfillment components. Items that are not available to aggregate\\n     *      will not be included in the aggregated execution.\\n     *\\n     * @param advancedOrders        The orders to aggregate.\\n     * @param side                  The side (i.e. offer or consideration).\\n     * @param fulfillmentComponents An array designating item components to\\n     *                              aggregate if part of an available order.\\n     * @param fulfillerConduit      A flag indicating whether to source\\n     *                              approvals for fulfilled tokens from the\\n     *                              fulfiller's respective proxy.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _aggregateAvailable(\\n        AdvancedOrder[] memory advancedOrders,\\n        Side side,\\n        FulfillmentComponent[] memory fulfillmentComponents,\\n        address fulfillerConduit\\n    ) internal view returns (Execution memory execution) {\\n        // Ensure at least one fulfillment component has been supplied.\\n        if (fulfillmentComponents.length == 0) {\\n            revert MissingFulfillmentComponentOnAggregation(side);\\n        }\\n\\n        // Determine component index after first available (zero implies none).\\n        uint256 nextComponentIndex = 0;\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over components until finding one with a fulfilled order.\\n            for (uint256 i = 0; i < fulfillmentComponents.length; ++i) {\\n                // Retrieve the fulfillment component index.\\n                uint256 orderIndex = fulfillmentComponents[i].orderIndex;\\n\\n                // Ensure that the order index is in range.\\n                if (orderIndex >= advancedOrders.length) {\\n                    revert FulfilledOrderIndexOutOfRange();\\n                }\\n\\n                // If order is being fulfilled (i.e. it is still available)...\\n                if (advancedOrders[orderIndex].numerator != 0) {\\n                    // Update the next potential component index.\\n                    nextComponentIndex = i + 1;\\n\\n                    // Exit the loop.\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // If no available order was located...\\n        if (nextComponentIndex == 0) {\\n            // Return early with a null execution element that will be filtered.\\n            // prettier-ignore\\n            return Execution(\\n                ReceivedItem(\\n                    ItemType.NATIVE,\\n                    address(0),\\n                    0,\\n                    0,\\n                    payable(address(0))\\n                ),\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        // If the fulfillment components are offer components...\\n        if (side == Side.OFFER) {\\n            // Return execution for aggregated items provided by the offerer.\\n            // prettier-ignore\\n            return _aggregateValidFulfillmentOfferItems(\\n                advancedOrders,\\n                fulfillmentComponents,\\n                nextComponentIndex - 1\\n            );\\n        } else {\\n            // Otherwise, fulfillment components are consideration components.\\n            // Return execution for aggregated items provided by the fulfiller.\\n            // prettier-ignore\\n            return _aggregateConsiderationItems(\\n                advancedOrders,\\n                fulfillmentComponents,\\n                nextComponentIndex - 1,\\n                fulfillerConduit\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to aggregate a group of offer items using\\n     *      supplied directives on which component items are candidates for\\n     *      aggregation, skipping items on orders that are not available.\\n     *\\n     * @param advancedOrders  The orders to aggregate offer items from.\\n     * @param offerComponents An array of FulfillmentComponent structs\\n     *                        indicating the order index and item index of each\\n     *                        candidate offer item for aggregation.\\n     * @param startIndex      The initial order index to begin iteration on when\\n     *                        searching for offer items to aggregate.\\n     *\\n     * @return execution The aggregated offer items.\\n     */\\n    function _aggregateValidFulfillmentOfferItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory offerComponents,\\n        uint256 startIndex\\n    ) internal view returns (Execution memory execution) {\\n        // Declare a variable for the final aggregated item amount.\\n        uint256 amount;\\n\\n        // Declare a variable indicating whether the aggregation is invalid.\\n        bool invalidFulfillment;\\n\\n        // Utilize assembly in order to efficiently aggregate the items.\\n        assembly {\\n            // Retrieve fulfillment pointer from offer component & start index.\\n            let fulfillmentPtr := mload(\\n                add(add(offerComponents, 0x20), mul(startIndex, 0x20))\\n            )\\n\\n            // Retrieve the order index using the fulfillment pointer.\\n            let orderIndex := mload(fulfillmentPtr)\\n\\n            // Retrieve item index using an offset of the fulfillment pointer.\\n            let itemIndex := mload(\\n                add(fulfillmentPtr, Fulfillment_itemIndex_offset)\\n            )\\n\\n            // Ensure that the order index is not out of range.\\n            invalidFulfillment := iszero(lt(orderIndex, mload(advancedOrders)))\\n\\n            // Retrieve the initial order pointer from the order index.\\n            let orderPtr := mload(\\n                mload(\\n                    add(\\n                        // Calculate pointer to start of advancedOrders head.\\n                        add(advancedOrders, 0x20),\\n                        // Calculate offset to pointer for desired order.\\n                        mul(orderIndex, 0x20)\\n                    )\\n                )\\n            )\\n            // Retrieve offer array pointer using offset of the order pointer.\\n            let offerArrPtr := mload(\\n                add(orderPtr, OrderParameters_offer_head_offset)\\n            )\\n\\n            // Ensure that the item index is not out of range.\\n            invalidFulfillment := or(\\n                iszero(lt(itemIndex, mload(offerArrPtr))),\\n                invalidFulfillment\\n            )\\n\\n            // Retrieve the offer item pointer using offset of the item index.\\n            let offerItemPtr := mload(\\n                add(\\n                    // Get pointer to beginning of OfferItem.\\n                    add(offerArrPtr, 0x20),\\n                    // Calculate offset to pointer for desired order.\\n                    mul(itemIndex, 0x20)\\n                )\\n            )\\n\\n            // Retrieve the received item pointer.\\n            let receivedItemPtr := mload(execution)\\n\\n            // Set itemType located at the offerItem pointer on receivedItem.\\n            mstore(receivedItemPtr, mload(offerItemPtr))\\n\\n            // Set token located at offset of offerItem pointer on receivedItem.\\n            mstore(\\n                add(receivedItemPtr, Common_token_offset),\\n                mload(add(offerItemPtr, Common_token_offset))\\n            )\\n\\n            // Set identifier located at offset of offerItem pointer as well.\\n            mstore(\\n                add(receivedItemPtr, 0x40),\\n                mload(add(offerItemPtr, Common_identifier_offset))\\n            )\\n\\n            // Set amount on received item and additionaly place on the stack.\\n            let amountPtr := add(offerItemPtr, Common_amount_offset)\\n            amount := mload(amountPtr)\\n\\n            // Set the caller as the recipient on the received item.\\n            mstore(\\n                add(receivedItemPtr, ReceivedItem_recipient_offset),\\n                caller()\\n            )\\n\\n            // Zero out amount on original offerItem to indicate it is spent.\\n            mstore(amountPtr, 0)\\n\\n            // Set the offerer on returned execution using order pointer.\\n            mstore(add(execution, Execution_offerer_offset), mload(orderPtr))\\n\\n            // Set conduit on returned execution using offset of order pointer.\\n            mstore(\\n                add(execution, Execution_conduit_offset),\\n                mload(add(orderPtr, OrderParameters_conduit_offset))\\n            )\\n        }\\n\\n        // Declare new assembly scope to avoid stack too deep errors.\\n        assembly {\\n            // Retrieve the received item pointer using the execution.\\n            let receivedItemPtr := mload(execution)\\n\\n            // Iterate over offer components as long as fulfillment is valid.\\n            // prettier-ignore\\n            for {\\n                let i := add(startIndex, 1)\\n            } and(iszero(invalidFulfillment), lt(i, mload(offerComponents))) {\\n                i := add(i, 1)\\n            } {\\n                // Retrieve fulfillment pointer for the current offer component.\\n                let fulfillmentPtr := mload(\\n                    add(add(offerComponents, 0x20), mul(i, 0x20))\\n                )\\n\\n                // Retrieve the order index using the fulfillment pointer.\\n                let orderIndex := mload(fulfillmentPtr)\\n\\n                // Retrieve the item index using offset of fulfillment pointer.\\n                let itemIndex := mload(\\n                    add(fulfillmentPtr, Fulfillment_itemIndex_offset)\\n                )\\n\\n                // Ensure that the order index is in range.\\n                invalidFulfillment := iszero(\\n                    lt(orderIndex, mload(advancedOrders))\\n                )\\n\\n                // Exit iteration if it is out of range.\\n                if invalidFulfillment {\\n                    break\\n                }\\n\\n                // Retrieve the order pointer using the order index. Note that\\n                // advancedOrders[orderIndex].OrderParameters pointer is first\\n                // word of AdvancedOrder struct, so mload again in a moment.\\n                let orderPtr := mload(\\n                    add(add(advancedOrders, 0x20), mul(orderIndex, 0x20))\\n                )\\n\\n                // If the order is available (i.e. has a numerator != 0)...\\n                if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\\n                    // Retrieve the order pointer (i.e. the second mload).\\n                    orderPtr := mload(orderPtr)\\n\\n                    // Load offer item array pointer.\\n                    let offerArrPtr := mload(\\n                        add(orderPtr, OrderParameters_offer_head_offset)\\n                    )\\n\\n                    // Ensure that the offer item index is in range.\\n                    invalidFulfillment := iszero(\\n                        lt(itemIndex, mload(offerArrPtr))\\n                    )\\n\\n                    // Exit iteration if it is out of range.\\n                    if invalidFulfillment {\\n                        break\\n                    }\\n\\n                    // Retrieve the offer item pointer using the item index.\\n                    let offerItemPtr := mload(\\n                        add(\\n                            // Get pointer to beginning of OfferItem\\n                            add(offerArrPtr, 0x20),\\n                            // Calculate offset to pointer for desired order\\n                            mul(itemIndex, 0x20)\\n                        )\\n                    )\\n\\n                    // Retrieve the amount using the offer item pointer.\\n                    let amountPtr := add(offerItemPtr, Common_amount_offset)\\n\\n                    // Increment the amount.\\n                    amount := add(amount, mload(amountPtr))\\n\\n                    // Zero out amount on original item to indicate it is spent.\\n                    mstore(amountPtr, 0)\\n\\n                    // Ensure the indicated offer item matches original item.\\n                    invalidFulfillment := iszero(\\n                        and(\\n                            // The identifier must match on both items.\\n                            eq(\\n                                mload(\\n                                    add(offerItemPtr, Common_identifier_offset)\\n                                ),\\n                                mload(\\n                                    add(\\n                                        receivedItemPtr,\\n                                        Common_identifier_offset\\n                                    )\\n                                )\\n                            ),\\n                            and(\\n                                and(\\n                                    // The offerer must match on both items.\\n                                    eq(\\n                                        mload(orderPtr),\\n                                        mload(\\n                                            add(execution, Common_token_offset)\\n                                        )\\n                                    ),\\n                                    // The conduit must match on both items.\\n                                    eq(\\n                                        mload(\\n                                            add(\\n                                                orderPtr,\\n                                                OrderParameters_conduit_offset\\n                                            )\\n                                        ),\\n                                        mload(\\n                                            add(\\n                                                execution,\\n                                                Execution_conduit_offset\\n                                            )\\n                                        )\\n                                    )\\n                                ),\\n                                and(\\n                                    // The item type must match on both items.\\n                                    eq(\\n                                        mload(offerItemPtr),\\n                                        mload(receivedItemPtr)\\n                                    ),\\n                                    // The token must match on both items.\\n                                    eq(\\n                                        mload(\\n                                            add(\\n                                                offerItemPtr,\\n                                                Common_token_offset\\n                                            )\\n                                        ),\\n                                        mload(\\n                                            add(\\n                                                receivedItemPtr,\\n                                                Common_token_offset\\n                                            )\\n                                        )\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    )\\n                }\\n            }\\n\\n            // Update the final amount on the returned received item.\\n            mstore(add(receivedItemPtr, Common_amount_offset), amount)\\n        }\\n\\n        // Revert if an order/item was out of range or was not aggregatable.\\n        if (invalidFulfillment) {\\n            revert InvalidFulfillmentComponentData();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to aggregate consideration items from a group\\n     *      of orders into a single execution via a supplied components array.\\n     *      Consideration items that are not available to aggregate will not be\\n     *      included in the aggregated execution.\\n     *\\n     * @param advancedOrders          The orders to aggregate.\\n     * @param considerationComponents An array designating consideration\\n     *                                components to aggregate if part of an\\n     *                                available order.\\n     * @param nextComponentIndex      The index of the next potential\\n     *                                consideration component.\\n     * @param fulfillerConduit       A flag indicating whether to source\\n     *                                approvals for fulfilled tokens from the\\n     *                                fulfiller's respective proxy.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _aggregateConsiderationItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory considerationComponents,\\n        uint256 nextComponentIndex,\\n        address fulfillerConduit\\n    ) internal view returns (Execution memory execution) {\\n        // Validate and aggregate consideration items on available orders and\\n        // store result as a ReceivedItem.\\n        ReceivedItem memory receiveConsiderationItem = (\\n            _aggregateValidFulfillmentConsiderationItems(\\n                advancedOrders,\\n                considerationComponents,\\n                nextComponentIndex\\n            )\\n        );\\n\\n        // Return execution for aggregated items provided by the fulfiller.\\n        execution = Execution(\\n            receiveConsiderationItem,\\n            msg.sender,\\n            fulfillerConduit\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xcc1ce11f3af1f46d62c5354303a024f28a671b7b97565e545b689be408eae1b7\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationPure.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { OrderType, ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver,\\n    Batch,\\n    BatchExecution\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\n\\nimport { ConsiderationBase } from \\\"./ConsiderationBase.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title ConsiderationPure\\n * @author 0age\\n * @notice ConsiderationPure contains all pure functions.\\n */\\ncontract ConsiderationPure is ConsiderationBase {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param legacyProxyRegistry         A proxy registry that stores per-user\\n     *                                    proxies that may optionally be used to\\n     *                                    transfer approved ERC721+1155 tokens.\\n     * @param legacyTokenTransferProxy    A shared proxy contract that may\\n     *                                    optionally be used to transfer\\n     *                                    approved ERC20 tokens.\\n     * @param requiredProxyImplementation The implementation that must be set on\\n     *                                    each proxy in order to utilize it.\\n     */\\n    constructor(\\n        address legacyProxyRegistry,\\n        address legacyTokenTransferProxy,\\n        address requiredProxyImplementation\\n    )\\n        ConsiderationBase(\\n            legacyProxyRegistry,\\n            legacyTokenTransferProxy,\\n            requiredProxyImplementation\\n        )\\n    {}\\n\\n    /**\\n     * @dev Internal pure function to apply criteria resolvers containing\\n     *      specific token identifiers and associated proofs to order items.\\n     *\\n     * @param advancedOrders     The orders to apply criteria resolvers to.\\n     * @param criteriaResolvers  An array where each element contains a\\n     *                           reference to a specific order as well as that\\n     *                           order's offer or consideration, a token\\n     *                           identifier, and a proof that the supplied token\\n     *                           identifier is contained in the order's merkle\\n     *                           root. Note that a root of zero indicates that\\n     *                           any transferrable token identifier is valid and\\n     *                           that no proof needs to be supplied.\\n     */\\n    function _applyCriteriaResolvers(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers\\n    ) internal pure {\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each criteria resolver.\\n            for (uint256 i = 0; i < criteriaResolvers.length; ++i) {\\n                // Retrieve the criteria resolver.\\n                CriteriaResolver memory criteriaResolver = criteriaResolvers[i];\\n\\n                // Read the order index from memory and place it on the stack.\\n                uint256 orderIndex = criteriaResolver.orderIndex;\\n\\n                // Ensure that the order index is in range.\\n                if (orderIndex >= advancedOrders.length) {\\n                    revert OrderCriteriaResolverOutOfRange();\\n                }\\n\\n                // Skip criteria resolution for order if not fulfilled.\\n                if (advancedOrders[orderIndex].numerator == 0) {\\n                    continue;\\n                }\\n\\n                // Retrieve the parameters for the order.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrders[orderIndex].parameters\\n                );\\n\\n                // Read component index from memory and place it on the stack.\\n                uint256 componentIndex = criteriaResolver.index;\\n\\n                // Declare values for item's type and criteria.\\n                ItemType itemType;\\n                uint256 identifierOrCriteria;\\n\\n                // If the criteria resolver refers to an offer item...\\n                if (criteriaResolver.side == Side.OFFER) {\\n                    // Ensure that the component index is in range.\\n                    if (componentIndex >= orderParameters.offer.length) {\\n                        revert OfferCriteriaResolverOutOfRange();\\n                    }\\n\\n                    // Retrieve relevant item using order and component index.\\n                    OfferItem memory offer = (\\n                        orderParameters.offer[componentIndex]\\n                    );\\n\\n                    // Read item type and criteria from memory & place on stack.\\n                    itemType = offer.itemType;\\n                    identifierOrCriteria = offer.identifierOrCriteria;\\n\\n                    // Optimistically update item type to remove criteria usage.\\n                    ItemType newItemType;\\n                    assembly {\\n                        newItemType := sub(3, eq(itemType, 4))\\n                    }\\n                    offer.itemType = newItemType;\\n\\n                    // Optimistically update identifier w/ supplied identifier.\\n                    offer.identifierOrCriteria = criteriaResolver.identifier;\\n                } else {\\n                    // Otherwise, the resolver refers to a consideration item.\\n                    // Ensure that the component index is in range.\\n                    if (\\n                        componentIndex >= orderParameters.consideration.length\\n                    ) {\\n                        revert ConsiderationCriteriaResolverOutOfRange();\\n                    }\\n\\n                    // Retrieve relevant item using order and component index.\\n                    ConsiderationItem memory consideration = (\\n                        orderParameters.consideration[componentIndex]\\n                    );\\n\\n                    // Read item type and criteria from memory & place on stack.\\n                    itemType = consideration.itemType;\\n                    identifierOrCriteria = consideration.identifierOrCriteria;\\n\\n                    // Optimistically update item type to remove criteria usage.\\n                    ItemType newItemType;\\n                    assembly {\\n                        newItemType := sub(3, eq(itemType, 4))\\n                    }\\n                    consideration.itemType = newItemType;\\n\\n                    // Optimistically update identifier w/ supplied identifier.\\n                    consideration.identifierOrCriteria = (\\n                        criteriaResolver.identifier\\n                    );\\n                }\\n\\n                // Ensure the specified item type indicates criteria usage.\\n                if (!_isItemWithCriteria(itemType)) {\\n                    revert CriteriaNotEnabledForItem();\\n                }\\n\\n                // If criteria is not 0 (i.e. a collection-wide offer)...\\n                if (identifierOrCriteria != uint256(0)) {\\n                    // Verify identifier inclusion in criteria root using proof.\\n                    _verifyProof(\\n                        criteriaResolver.identifier,\\n                        identifierOrCriteria,\\n                        criteriaResolver.criteriaProof\\n                    );\\n                }\\n            }\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < advancedOrders.length; ++i) {\\n                // Retrieve the order.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Skip criteria resolution for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    continue;\\n                }\\n\\n                // Read consideration length from memory and place on stack.\\n                uint256 totalItems = (\\n                    advancedOrder.parameters.consideration.length\\n                );\\n\\n                // Iterate over each consideration item on the order.\\n                for (uint256 j = 0; j < totalItems; ++j) {\\n                    // Ensure item type no longer indicates criteria usage.\\n                    if (\\n                        _isItemWithCriteria(\\n                            advancedOrder.parameters.consideration[j].itemType\\n                        )\\n                    ) {\\n                        revert UnresolvedConsiderationCriteria();\\n                    }\\n                }\\n\\n                // Read offer length from memory and place on stack.\\n                totalItems = advancedOrder.parameters.offer.length;\\n\\n                // Iterate over each offer item on the order.\\n                for (uint256 j = 0; j < totalItems; ++j) {\\n                    // Ensure item type no longer indicates criteria usage.\\n                    if (\\n                        _isItemWithCriteria(\\n                            advancedOrder.parameters.offer[j].itemType\\n                        )\\n                    ) {\\n                        revert UnresolvedOfferCriteria();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to derive the current amount of a given item\\n     *      based on the current price, the starting price, and the ending\\n     *      price. If the start and end prices differ, the current price will be\\n     *      extrapolated on a linear basis.\\n     *\\n     * @param startAmount The starting amount of the item.\\n     * @param endAmount   The ending amount of the item.\\n     * @param elapsed     The time elapsed since the order's start time.\\n     * @param remaining   The time left until the order's end time.\\n     * @param duration    The total duration of the order.\\n     * @param roundUp     A boolean indicating whether the resultant amount\\n     *                    should be rounded up or down.\\n     *\\n     * @return The current amount.\\n     */\\n    function _locateCurrentAmount(\\n        uint256 startAmount,\\n        uint256 endAmount,\\n        uint256 elapsed,\\n        uint256 remaining,\\n        uint256 duration,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        // Only modify end amount if it doesn't already equal start amount.\\n        if (startAmount != endAmount) {\\n            // Leave extra amount to add for rounding at zero (i.e. round down).\\n            uint256 extraCeiling = 0;\\n\\n            // If rounding up, set rounding factor to one less than denominator.\\n            if (roundUp) {\\n                // Skip underflow check: duration cannot be zero.\\n                unchecked {\\n                    extraCeiling = duration - 1;\\n                }\\n            }\\n\\n            // Aggregate new amounts weighted by time with rounding factor\\n            uint256 totalBeforeDivision = ((startAmount * remaining) +\\n                (endAmount * elapsed) +\\n                extraCeiling);\\n\\n            // Division is performed without zero check as it cannot be zero.\\n            uint256 newAmount;\\n            assembly {\\n                newAmount := div(totalBeforeDivision, duration)\\n            }\\n\\n            // Return the current amount (expressed as endAmount internally).\\n            return newAmount;\\n        }\\n\\n        // Return the original amount (now expressed as endAmount internally).\\n        return endAmount;\\n    }\\n\\n    /**\\n     * @dev Internal pure function to return a fraction of a given value and to\\n     *      ensure the resultant value does not have any fractional component.\\n     *\\n     * @param numerator   A value indicating the portion of the order that\\n     *                    should be filled.\\n     * @param denominator A value indicating the total size of the order.\\n     * @param value       The value for which to compute the fraction.\\n     *\\n     * @return newValue The value after applying the fraction.\\n     */\\n    function _getFraction(\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 value\\n    ) internal pure returns (uint256 newValue) {\\n        // Return value early in cases where the fraction resolves to 1.\\n        if (numerator == denominator) {\\n            return value;\\n        }\\n\\n        // Multiply the numerator by the value and ensure no overflow occurs.\\n        uint256 valueTimesNumerator = value * numerator;\\n\\n        // Divide (Note: denominator must not be zero!) and check for remainder.\\n        bool exact;\\n        assembly {\\n            newValue := div(valueTimesNumerator, denominator)\\n            exact := iszero(mulmod(value, numerator, denominator))\\n        }\\n\\n        // Ensure that division gave a final result with no remainder.\\n        if (!exact) {\\n            revert InexactFraction();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to \\\"compress\\\" executions, splitting them into\\n     *      \\\"standard\\\" (or unbatched) executions and \\\"batch\\\" executions. Note\\n     *      that there may be additional compression that could be performed,\\n     *      such as allowing contrarian orders to cancel one another.\\n     *\\n     * @param executions An array of uncompressed executions.\\n     *\\n     * @return standardExecutions An array of executions that were not able to\\n     *                            be compressed.\\n     * @return batchExecutions    An array of executions (all ERC1155 transfers)\\n     *                            that have been compressed into batches.\\n     */\\n    function _compressExecutions(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (\\n            Execution[] memory standardExecutions,\\n            BatchExecution[] memory batchExecutions\\n        )\\n    {\\n        // Skip overflow checks as all incremented values start at low amounts.\\n        unchecked {\\n            // Read executions array length from memory and place on the stack.\\n            uint256 totalExecutions = executions.length;\\n\\n            // Return early if less than two executions are provided.\\n            if (totalExecutions <= 1) {\\n                return (executions, new BatchExecution[](0));\\n            }\\n\\n            // Determine the toal number of ERC1155 executions in the array.\\n            uint256 total1155Executions = 0;\\n\\n            // Allocate array in memory for indices of each ERC1155 execution.\\n            uint256[] memory indexBy1155 = new uint256[](totalExecutions);\\n\\n            // Iterate over each execution.\\n            for (uint256 i = 0; i < executions.length; ++i) {\\n                // If the item specified by the execution is an ERC1155 item...\\n                if (executions[i].item.itemType == ItemType.ERC1155) {\\n                    // Set index of 1155 execution in memory, then increment it.\\n                    indexBy1155[total1155Executions++] = i;\\n                }\\n            }\\n\\n            // Return early if less than two ERC1155 executions are located.\\n            if (total1155Executions <= 1) {\\n                return (executions, new BatchExecution[](0));\\n            }\\n\\n            // Allocate array to track potential ERC1155 batch executions.\\n            Batch[] memory batches = new Batch[](total1155Executions);\\n\\n            // Read initial execution index from memory and place on the stack.\\n            uint256 initialExecutionIndex = indexBy1155[0];\\n\\n            // Get hash from initial token, offerer, recipient, & proxy usage.\\n            bytes32 hash = _getHashByExecutionIndex(\\n                executions,\\n                initialExecutionIndex\\n            );\\n\\n            // Allocate an array of length 1 in memory for the execution index.\\n            uint256[] memory executionIndices = new uint256[](1);\\n\\n            // Populate the memory region with the initial execution index.\\n            executionIndices[0] = initialExecutionIndex;\\n\\n            // Set hash and array with execution index as first batch element.\\n            batches[0].hash = hash;\\n            batches[0].executionIndices = executionIndices;\\n\\n            // Track total number of unique hashes (starts at one).\\n            uint256 uniqueHashes = 1;\\n\\n            // Iterate over each additional 1155 execution.\\n            for (uint256 i = 1; i < total1155Executions; ++i) {\\n                // Read execution index from memory and place on the stack.\\n                uint256 executionIndex = indexBy1155[i];\\n\\n                // Derive hash based on the same parameters as the initial hash.\\n                hash = _getHashByExecutionIndex(executions, executionIndex);\\n\\n                // Assume no matching hash exists unless proven otherwise.\\n                bool foundMatchingHash = false;\\n\\n                // Iterate over all known unique hashes.\\n                for (uint256 j = 0; j < uniqueHashes; ++j) {\\n                    // If the hash matches the known unique hash in question...\\n                    if (hash == batches[j].hash) {\\n                        // Retrieve execution index of the original execution.\\n                        uint256[] memory oldExecutionIndices = (\\n                            batches[j].executionIndices\\n                        );\\n\\n                        // Place old execution indices array length on stack.\\n                        uint256 originalLength = oldExecutionIndices.length;\\n\\n                        // Allocate execution indices array w/ an extra element.\\n                        uint256[] memory newExecutionIndices = (\\n                            new uint256[](originalLength + 1)\\n                        );\\n\\n                        // Iterate over existing execution indices.\\n                        for (uint256 k = 0; k < originalLength; ++k) {\\n                            // Add them to the new execution indices array.\\n                            newExecutionIndices[k] = oldExecutionIndices[k];\\n                        }\\n\\n                        // Add new execution index to the end of the array.\\n                        newExecutionIndices[originalLength] = executionIndex;\\n\\n                        // Update the batch with the extended array.\\n                        batches[j].executionIndices = newExecutionIndices;\\n\\n                        // Mark that new hash matches one already in a batch.\\n                        foundMatchingHash = true;\\n\\n                        // Stop scanning for a match as one has now been found.\\n                        break;\\n                    }\\n                }\\n\\n                // If no matching hash was located, create a new batch element.\\n                if (!foundMatchingHash) {\\n                    // Reuse existing array & update w/ current execution index.\\n                    executionIndices[0] = executionIndex;\\n\\n                    // Set next batch element and increment total unique hashes.\\n                    batches[uniqueHashes].hash = hash;\\n                    batches[uniqueHashes++].executionIndices = executionIndices;\\n                }\\n            }\\n\\n            // Return early if every hash is unique.\\n            if (uniqueHashes == total1155Executions) {\\n                return (executions, new BatchExecution[](0));\\n            }\\n\\n            // Allocate an array to track the batch each execution is used in.\\n            // Values of zero indicate that it is not used in a batch, whereas\\n            // non-zero values indicate the execution index *plus one*.\\n            uint256[] memory usedInBatch = new uint256[](totalExecutions);\\n\\n            // Stack elements have been exhausted, so utilize memory to track\\n            // total elements used as part of a batch as well as total batches.\\n            uint256[] memory totals = new uint256[](2);\\n\\n            // Iterate over each potential batch (determined via unique hashes).\\n            for (uint256 i = 0; i < uniqueHashes; ++i) {\\n                // Retrieve the indices for the batch in question.\\n                uint256[] memory indices = batches[i].executionIndices;\\n\\n                // Read total number of indices from memory and place on stack.\\n                uint256 indicesLength = indices.length;\\n\\n                // if more than one execution applies to a potential batch...\\n                if (indicesLength >= 2) {\\n                    // Increment the total number of batches.\\n                    ++totals[1];\\n\\n                    // Increment total executions used as part of a batch.\\n                    totals[0] += indicesLength;\\n\\n                    // Iterate over each execution index for the batch.\\n                    for (uint256 j = 0; j < indicesLength; ++j) {\\n                        // Update array tracking batch the execution applies to.\\n                        usedInBatch[indices[j]] = i + 1;\\n                    }\\n                }\\n            }\\n\\n            // Split executions into standard and batched executions and return.\\n            // prettier-ignore\\n            return _splitExecution(\\n                    executions,\\n                    batches,\\n                    usedInBatch,\\n                    totals[0],\\n                    totals[1]\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to complete the process of \\\"compressing\\\"\\n     *      executions and return both unbatched and batched execution arrays.\\n     *\\n     * @param executions             An array of uncompressed executions.\\n     * @param batches                An array of elements indicating which\\n     *                               executions form the \\\"baseline\\\" for a batch.\\n     * @param batchExecutionPointers An array of indices, incremented by one (as\\n     *                               zero indicates no batching), that each\\n     *                               point to a respective batch per execution.\\n     * @param totalUsedInBatch       The total execution elements to batch.\\n     * @param totalBatches           The total number of batch executions.\\n     *\\n     * @return An array of executions that could not be compressed.\\n     * @return An array of executions (all ERC1155 transfers) that have been\\n     *         compressed into batches.\\n     */\\n    function _splitExecution(\\n        Execution[] memory executions,\\n        Batch[] memory batches,\\n        uint256[] memory batchExecutionPointers,\\n        uint256 totalUsedInBatch,\\n        uint256 totalBatches\\n    ) internal pure returns (Execution[] memory, BatchExecution[] memory) {\\n        // Skip overflow checks as all incremented values start at low amounts.\\n        unchecked {\\n            // Read executions array length from memory and place on the stack.\\n            uint256 totalExecutions = executions.length;\\n\\n            // Allocate standard executions array (exclude ones used in batch).\\n            Execution[] memory standardExecutions = new Execution[](\\n                totalExecutions - totalUsedInBatch\\n            );\\n\\n            // Allocate batch executions array (length equal to total batches).\\n            BatchExecution[] memory batchExecutions = new BatchExecution[](\\n                totalBatches\\n            );\\n\\n            // Track the index of the next available standard execution element.\\n            uint256 nextStandardExecutionIndex = 0;\\n\\n            // Allocate array in memory to track next element index per batch.\\n            uint256[] memory batchElementIndices = new uint256[](totalBatches);\\n\\n            // Iterate over each execution.\\n            for (uint256 i = 0; i < totalExecutions; ++i) {\\n                // Check if execution is standard (0) or part of a batch (1+).\\n                uint256 batchExecutionPointer = batchExecutionPointers[i];\\n\\n                // Retrieve the execution element.\\n                Execution memory execution = executions[i];\\n\\n                // If the execution is a standard execution...\\n                if (batchExecutionPointer == 0) {\\n                    // Copy it to next standard index, then increment the index.\\n                    standardExecutions[nextStandardExecutionIndex++] = (\\n                        execution\\n                    );\\n                    // Otherwise, it is a batch execution.\\n                } else {\\n                    // Decrement pointer to derive the batch execution index.\\n                    uint256 batchIndex = batchExecutionPointer - 1;\\n\\n                    // If it is the first item applied to the batch execution...\\n                    if (batchExecutions[batchIndex].token == address(0)) {\\n                        // Determine total elements in batch and place on stack.\\n                        uint256 totalElements = (\\n                            batches[batchIndex].executionIndices.length\\n                        );\\n\\n                        // Populate all other fields using execution parameters.\\n                        batchExecutions[batchIndex] = BatchExecution(\\n                            execution.item.token, // token\\n                            execution.offerer, // from\\n                            execution.item.recipient, // to\\n                            new uint256[](totalElements), // tokenIds\\n                            new uint256[](totalElements), // amounts\\n                            execution.conduit // conduit\\n                        );\\n                    }\\n\\n                    // Put next batch element index on stack, then increment it.\\n                    uint256 batchElementIndex = (\\n                        batchElementIndices[batchIndex]++\\n                    );\\n\\n                    // Update current element's batch with respective tokenId.\\n                    batchExecutions[batchIndex].tokenIds[batchElementIndex] = (\\n                        execution.item.identifier\\n                    );\\n\\n                    // Retrieve execution item amount and place on the stack.\\n                    uint256 amount = execution.item.amount;\\n\\n                    // Ensure that the amount is non-zero.\\n                    _assertNonZeroAmount(amount);\\n\\n                    // Update current element's batch with respective amount.\\n                    batchExecutions[batchIndex].amounts[batchElementIndex] = (\\n                        amount\\n                    );\\n                }\\n            }\\n\\n            // Return both the standard and batch execution arrays.\\n            return (standardExecutions, batchExecutions);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to apply a fraction to a consideration\\n     * or offer item.\\n     *\\n     * @param startAmount     The starting amount of the item.\\n     * @param endAmount       The ending amount of the item.\\n     * @param numerator       A value indicating the portion of the order that\\n     *                        should be filled.\\n     * @param denominator     A value indicating the total size of the order.\\n     * @param elapsed         The time elapsed since the order's start time.\\n     * @param remaining       The time left until the order's end time.\\n     * @param duration        The total duration of the order.\\n     *\\n     * @return amount The received item to transfer with the final amount.\\n     */\\n    function _applyFraction(\\n        uint256 startAmount,\\n        uint256 endAmount,\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 elapsed,\\n        uint256 remaining,\\n        uint256 duration,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount) {\\n        // If start amount equals end amount, apply fraction to end amount.\\n        if (startAmount == endAmount) {\\n            amount = _getFraction(numerator, denominator, endAmount);\\n        } else {\\n            // Otherwise, apply fraction to both to extrapolate final amount.\\n            amount = _locateCurrentAmount(\\n                _getFraction(numerator, denominator, startAmount),\\n                _getFraction(numerator, denominator, endAmount),\\n                elapsed,\\n                remaining,\\n                duration,\\n                roundUp\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to aggregate a group of consideration items\\n     *      using supplied directives on which component items are candidates\\n     *      for aggregation, skipping items on orders that are not available.\\n     *\\n     * @param advancedOrders          The orders to aggregate consideration\\n     *                                items from.\\n     * @param considerationComponents An array of FulfillmentComponent structs\\n     *                                indicating the order index and item index\\n     *                                of each candidate consideration item for\\n     *                                aggregation.\\n     * @param startIndex              The initial order index to begin iteration\\n     *                                on when searching for consideration items\\n     *                                to aggregate.\\n     *\\n     * @return receivedItem The aggregated consideration items.\\n     */\\n    function _aggregateValidFulfillmentConsiderationItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory considerationComponents,\\n        uint256 startIndex\\n    ) internal pure returns (ReceivedItem memory receivedItem) {\\n        // Declare a variable indicating whether the aggregation is invalid.\\n        bool invalidFulfillment;\\n\\n        // Utilize assembly in order to efficiently aggregate the items.\\n        assembly {\\n            // Retrieve the length of the orders array.\\n            let totalOrders := mload(advancedOrders)\\n\\n            // Begin iteration at the indicated start index.\\n            let i := startIndex\\n\\n            // Get fulfillment ptr from consideration component & start index.\\n            let fulfillmentPtr := mload(\\n                add(add(considerationComponents, 0x20), mul(i, 0x20))\\n            )\\n\\n            // Retrieve the order index using the fulfillment pointer.\\n            let orderIndex := mload(fulfillmentPtr)\\n\\n            // Retrieve item index using an offset of the fulfillment pointer.\\n            let itemIndex := mload(add(fulfillmentPtr, 0x20))\\n\\n            // Ensure that the order index is not out of range.\\n            invalidFulfillment := iszero(lt(orderIndex, totalOrders))\\n\\n            // Only continue if the fulfillment is not invalid.\\n            if iszero(invalidFulfillment) {\\n                // Calculate pointer to AdvancedOrder element at\\n                // advancedOrders[orderIndex].OrderParameters pointer is first\\n                // word of AdvancedOrder struct, so we mload twice.\\n                let orderPtr := mload(\\n                    // Read the pointer to advancedOrders[orderIndex] from its\\n                    // head in the array.\\n                    mload(\\n                        // Calculate head position of advancedOrders[orderIndex]\\n                        add(add(advancedOrders, 0x20), mul(orderIndex, 0x20))\\n                    )\\n                )\\n\\n                // Load consideration array pointer.\\n                let considerationArrPtr := mload(\\n                    add(orderPtr, OrderParameters_consideration_head_offset)\\n                )\\n\\n                // Check if itemIndex is within the range of the array.\\n                invalidFulfillment := iszero(\\n                    lt(itemIndex, mload(considerationArrPtr))\\n                )\\n\\n                // Only continue if the fulfillment is not invalid.\\n                if iszero(invalidFulfillment) {\\n                    // Retrieve consideration item pointer using the item index.\\n                    let considerationItemPtr := mload(\\n                        add(\\n                            // Get pointer to beginning of receivedItem.\\n                            add(considerationArrPtr, 0x20),\\n                            // Calculate offset to pointer for desired order.\\n                            mul(itemIndex, 0x20)\\n                        )\\n                    )\\n\\n                    // Set the item type on the received item.\\n                    mstore(receivedItem, mload(considerationItemPtr))\\n\\n                    // Set the token on the received item.\\n                    mstore(\\n                        add(receivedItem, Common_token_offset),\\n                        mload(add(considerationItemPtr, Common_token_offset))\\n                    )\\n\\n                    // Set the identifier on the received item.\\n                    mstore(\\n                        add(receivedItem, Common_identifier_offset),\\n                        mload(\\n                            add(considerationItemPtr, Common_identifier_offset)\\n                        )\\n                    )\\n\\n                    // Retrieve amount pointer using consideration item pointer.\\n                    let amountPtr := add(\\n                        considerationItemPtr,\\n                        Common_amount_offset\\n                    )\\n                    // Set the amount.\\n                    mstore(\\n                        add(receivedItem, Common_amount_offset),\\n                        mload(amountPtr)\\n                    )\\n\\n                    // Zero out amount on item to indicate it is credited.\\n                    mstore(amountPtr, 0)\\n\\n                    // Set the recipient.\\n                    mstore(\\n                        add(receivedItem, ReceivedItem_recipient_offset),\\n                        mload(\\n                            add(\\n                                considerationItemPtr,\\n                                ConsiderationItem_recipient_offset\\n                            )\\n                        )\\n                    )\\n\\n                    // Increment the iterator.\\n                    i := add(i, 1)\\n\\n                    // Iterate over remaining consideration components.\\n                    // prettier-ignore\\n                    for {} lt(i, mload(considerationComponents)) {\\n                        i := add(i, 1)\\n                    } {\\n                        // Retrieve the fulfillment pointer.\\n                        fulfillmentPtr := mload(\\n                            add(\\n                                add(considerationComponents, 0x20),\\n                                mul(i, 0x20)\\n                            )\\n                        )\\n\\n                        // Get the order index using the fulfillment pointer.\\n                        orderIndex := mload(fulfillmentPtr)\\n\\n                        // Get the item index using the fulfillment pointer.\\n                        itemIndex := mload(add(fulfillmentPtr, 0x20))\\n\\n                        // Ensure the order index is in range.\\n                        invalidFulfillment := iszero(\\n                            lt(orderIndex, totalOrders)\\n                        )\\n\\n                        // Exit iteration if order index is not in range.\\n                        if invalidFulfillment {\\n                            break\\n                        }\\n                        // Get pointer to AdvancedOrder element. The pointer\\n                        // will be reused as the pointer to OrderParameters.\\n                        orderPtr := mload(\\n                            add(\\n                                add(advancedOrders, 0x20),\\n                                mul(orderIndex, 0x20)\\n                            )\\n                        )\\n\\n                        // Only continue if numerator is not zero.\\n                        if mload(\\n                            add(orderPtr, AdvancedOrder_numerator_offset)\\n                        ) {\\n                            // First word of AdvancedOrder is pointer to\\n                            // OrderParameters.\\n                            orderPtr := mload(orderPtr)\\n\\n                            // Load consideration array pointer.\\n                            considerationArrPtr := mload(\\n                                add(\\n                                    orderPtr,\\n                                    OrderParameters_consideration_head_offset\\n                                )\\n                            )\\n\\n                            // Check if itemIndex is within the range of array.\\n                            invalidFulfillment := iszero(\\n                                lt(itemIndex, mload(considerationArrPtr))\\n                            )\\n\\n                            // Exit iteration if item index is not in range.\\n                            if invalidFulfillment {\\n                                break\\n                            }\\n\\n                            // Retrieve consideration item pointer using index.\\n                            considerationItemPtr := mload(\\n                                add(\\n                                    // Get pointer to beginning of receivedItem.\\n                                    add(considerationArrPtr, 0x20),\\n                                    // Use offset to pointer for desired order.\\n                                    mul(itemIndex, 0x20)\\n                                )\\n                            )\\n\\n                            // Retrieve amount pointer using consideration item\\n                            // pointer.\\n                            amountPtr := add(\\n                                considerationItemPtr,\\n                                Common_amount_offset\\n                            )\\n\\n                            // Increment the amount on the received item.\\n                            mstore(\\n                                add(receivedItem, Common_amount_offset),\\n                                add(\\n                                    mload(\\n                                        add(receivedItem, Common_amount_offset)\\n                                    ),\\n                                    mload(amountPtr)\\n                                )\\n                            )\\n\\n                            // Zero out amount on original item to indicate it\\n                            // is credited.\\n                            mstore(amountPtr, 0)\\n\\n                            // Ensure the indicated item matches original item.\\n                            invalidFulfillment := iszero(\\n                                and(\\n                                    // Item recipients must match.\\n                                    eq(\\n                                        mload(\\n                                            add(\\n                                                considerationItemPtr,\\n                                                ConsiderItem_recipient_offset\\n                                            )\\n                                        ),\\n                                        mload(\\n                                            add(\\n                                                receivedItem,\\n                                                ReceivedItem_recipient_offset\\n                                            )\\n                                        )\\n                                    ),\\n                                    and(\\n                                        // Item types must match.\\n                                        eq(\\n                                            mload(considerationItemPtr),\\n                                            mload(receivedItem)\\n                                        ),\\n                                        and(\\n                                            // Item tokens must match.\\n                                            eq(\\n                                                mload(\\n                                                    add(\\n                                                        considerationItemPtr,\\n                                                        Common_token_offset\\n                                                    )\\n                                                ),\\n                                                mload(\\n                                                    add(\\n                                                        receivedItem,\\n                                                        Common_token_offset\\n                                                    )\\n                                                )\\n                                            ),\\n                                            // Item identifiers must match.\\n                                            eq(\\n                                                mload(\\n                                                    add(\\n                                                        considerationItemPtr,\\n                                                        Common_identifier_offset\\n                                                    )\\n                                                ),\\n                                                mload(\\n                                                    add(\\n                                                        receivedItem,\\n                                                        Common_identifier_offset\\n                                                    )\\n                                                )\\n                                            )\\n                                        )\\n                                    )\\n                                )\\n                            )\\n\\n                            // Exit iteration if items do not match.\\n                            if invalidFulfillment {\\n                                break\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Revert if an order/item was out of range or was not aggregatable.\\n        if (invalidFulfillment) {\\n            revert InvalidFulfillmentComponentData();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a staticcall to `isValidOrder`\\n     *      or `isValidOrderIncludingExtraData` as part of validating a\\n     *      restricted order that was not submitted by the named offerer or zone\\n     *      was successful and returned the required magic value.\\n     *\\n     * @param success   A boolean indicating the status of the staticcall.\\n     * @param orderHash The order hash of the order in question.\\n     */\\n    function _assertIsValidOrderStaticcallSuccess(\\n        bool success,\\n        bytes32 orderHash\\n    ) internal pure {\\n        // If the call failed...\\n        if (!success) {\\n            // Revert and pass reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            revert InvalidRestrictedOrder(orderHash);\\n        }\\n\\n        // Extract result from returndata buffer in case of memory overflow.\\n        bytes4 result;\\n        assembly {\\n            // Only put result on stack if return data is exactly 32 bytes.\\n            if eq(returndatasize(), 0x20) {\\n                // Copy directly from return data into scratch space.\\n                returndatacopy(0, 0, 0x20)\\n\\n                // Take value from scratch space and place it on the stack.\\n                result := mload(0)\\n            }\\n        }\\n\\n        // Ensure result was extracted and matches isValidOrder magic value.\\n        if (result != ZoneInterface.isValidOrder.selector) {\\n            revert InvalidRestrictedOrder(orderHash);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to validate that a given order is fillable\\n     *      and not cancelled based on the order status.\\n     *\\n     * @param orderHash       The order hash.\\n     * @param orderStatus     The status of the order, including whether it has\\n     *                        been cancelled and the fraction filled.\\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\\n     *                        are supported by the calling function.\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\n     *                        order has been cancelled or filled beyond the\\n     *                        allowable amount.\\n     *\\n     * @return valid A boolean indicating whether the order is valid.\\n     */\\n    function _verifyOrderStatus(\\n        bytes32 orderHash,\\n        OrderStatus memory orderStatus,\\n        bool onlyAllowUnused,\\n        bool revertOnInvalid\\n    ) internal pure returns (bool valid) {\\n        // Ensure that the order has not been cancelled.\\n        if (orderStatus.isCancelled) {\\n            // Only revert if revertOnInvalid has been supplied as true.\\n            if (revertOnInvalid) {\\n                revert OrderIsCancelled(orderHash);\\n            }\\n\\n            // Return false as the order status is invalid.\\n            return false;\\n        }\\n\\n        // If the order is not entirely unused...\\n        if (orderStatus.numerator != 0) {\\n            // ensure the order has not been partially filled when not allowed.\\n            if (onlyAllowUnused) {\\n                // Always revert on partial fills when onlyAllowUnused is true.\\n                revert OrderPartiallyFilled(orderHash);\\n                // Otherwise, ensure that order has not been entirely filled.\\n            } else if (orderStatus.numerator >= orderStatus.denominator) {\\n                // Only revert if revertOnInvalid has been supplied as true.\\n                if (revertOnInvalid) {\\n                    revert OrderAlreadyFilled(orderHash);\\n                }\\n\\n                // Return false as the order status is invalid.\\n                return false;\\n            }\\n        }\\n\\n        // Return true as the order status is valid.\\n        valid = true;\\n    }\\n\\n    /**\\n     * @dev Internal pure function to hash key parameters of a given execution\\n     *      from an array of execution elements by index.\\n     *\\n     * @param executions     An array of execution elements.\\n     * @param executionIndex An index designating which execution element from\\n     *                       the array to hash.\\n     *\\n     * @return A hash of the key parameters of the execution.\\n     */\\n    function _getHashByExecutionIndex(\\n        Execution[] memory executions,\\n        uint256 executionIndex\\n    ) internal pure returns (bytes32) {\\n        // Retrieve ERC1155 execution element.\\n        Execution memory execution = executions[executionIndex];\\n\\n        // Retrieve the received item for the given execution element.\\n        ReceivedItem memory item = execution.item;\\n\\n        // Derive hash based on token, offerer, recipient, and proxy usage.\\n        // prettier-ignore\\n        return _hashBatchableItemIdentifier(\\n            item.token,\\n            execution.offerer,\\n            item.recipient,\\n            execution.conduit\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to derive a hash for comparing transfers to\\n     *      see if they can be batched. Only applies to ERC1155 tokens.\\n     *\\n     * @param token    The token to transfer.\\n     * @param from     The originator of the transfer.\\n     * @param to       The recipient of the transfer.\\n     * @param conduit A boolean indicating whether to utilize a proxy when\\n     *                 performing the transfer.\\n     *\\n     * @return value The hash.\\n     */\\n    function _hashBatchableItemIdentifier(\\n        address token,\\n        address from,\\n        address to,\\n        address conduit\\n    ) internal pure returns (bytes32 value) {\\n        // Leverage scratch space to perform an efficient hash.\\n        assembly {\\n            mstore(0x20, conduit) // Place proxy bool at end of scratch space.\\n            mstore(0x1c, to) // Place to address just before bool.\\n            mstore(0x08, from) // Place from address just before to.\\n\\n            // Place combined token + start of from at start of scratch space.\\n            mstore(0x00, or(shl(0x60, token), shr(0x40, from)))\\n\\n            value := keccak256(0x00, 0x40) // Hash scratch space region.\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to efficiently derive an digest to sign for\\n     *      an order in accordance with EIP-712.\\n     *\\n     * @param domainSeparator The domain separator.\\n     * @param orderHash       The order hash.\\n     *\\n     * @return value The hash.\\n     */\\n    function _hashDigest(bytes32 domainSeparator, bytes32 orderHash)\\n        internal\\n        pure\\n        returns (bytes32 value)\\n    {\\n        // Leverage scratch space to perform an efficient hash.\\n        assembly {\\n            // Place the EIP-712 prefix at the start of scratch space.\\n            mstore(\\n                0x00,\\n                0x1901000000000000000000000000000000000000000000000000000000000000 // solhint-disable-line max-line-length\\n            )\\n\\n            // Place the domain separator in the next region of scratch space.\\n            mstore(0x02, domainSeparator)\\n\\n            // Place the order hash in scratch space, spilling into the first\\n            // two bytes of the free memory pointer \\u2014 this should never be set\\n            // as memory cannot be expanded to that size, and will be zeroed out\\n            // after the hash is performed.\\n            mstore(0x22, orderHash)\\n\\n            value := keccak256(0x00, 0x42) // Hash the relevant region.\\n\\n            mstore(0x22, 0) // Clear out the dirtied bits in the memory pointer.\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check whether a given item type represents\\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\\n     *      resolved to one of a number of different identifiers at the time of\\n     *      order fulfillment).\\n     *\\n     * @param itemType The item type in question.\\n     *\\n     * @return withCriteria A boolean indicating that the item type in question\\n     *                      represents a criteria-based item.\\n     */\\n    function _isItemWithCriteria(ItemType itemType)\\n        internal\\n        pure\\n        returns (bool withCriteria)\\n    {\\n        // ERC721WithCriteria is item type 4. ERC1155WithCriteria is item type\\n        // 5.\\n        assembly {\\n            withCriteria := gt(itemType, 3)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check whether a given order type indicates\\n     *      that partial fills are not supported (e.g. only \\\"full fills\\\" are\\n     *      allowed for the order in question).\\n     *\\n     * @param orderType The order type in question.\\n     *\\n     * @return isFullOrder A boolean indicating whether the order type only\\n     *                     supports full fills.\\n     */\\n    function _doesNotSupportPartialFills(OrderType orderType)\\n        internal\\n        pure\\n        returns (bool isFullOrder)\\n    {\\n        // The \\\"full\\\" order types are even, while \\\"partial\\\" order types are odd.\\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper.\\n        assembly {\\n            // Same thing as uint256(orderType) & 1 == 0\\n            isFullOrder := iszero(and(orderType, 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to convert an order to an advanced order with\\n     *      numerator and denominator of 1 and empty extraData.\\n     *\\n     * @param order The order to convert.\\n     *\\n     * @return advancedOrder The new advanced order.\\n     */\\n    function _convertOrderToAdvanced(Order calldata order)\\n        internal\\n        pure\\n        returns (AdvancedOrder memory advancedOrder)\\n    {\\n        // Convert to partial order (1/1 or full fill) and return new value.\\n        advancedOrder = AdvancedOrder(\\n            order.parameters,\\n            1,\\n            1,\\n            order.signature,\\n            \\\"\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to convert an array of orders to an array of\\n     *      advanced orders with numerator and denominator of 1.\\n     *\\n     * @param orders The orders to convert.\\n     *\\n     * @return advancedOrders The new array of partial orders.\\n     */\\n    function _convertOrdersToAdvanced(Order[] calldata orders)\\n        internal\\n        pure\\n        returns (AdvancedOrder[] memory advancedOrders)\\n    {\\n        // Read the number of orders from calldata and place on the stack.\\n        uint256 totalOrders = orders.length;\\n\\n        // Allocate new empty array for each partial order in memory.\\n        advancedOrders = new AdvancedOrder[](totalOrders);\\n\\n        // Skip overflow check as the index for the loop starts at zero.\\n        unchecked {\\n            // Iterate over the given orders.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Convert to partial order (1/1 or full fill) and update array.\\n                advancedOrders[i] = _convertOrderToAdvanced(orders[i]);\\n            }\\n        }\\n\\n        // Return the array of advanced orders.\\n        return advancedOrders;\\n    }\\n\\n    /**\\n     * @dev Internal pure function to revert and pass along the revert reason if\\n     *      data was returned by the last call.\\n     */\\n    function _revertWithReasonIfOneIsReturned() internal pure {\\n        assembly {\\n            // If data was returned...\\n            if returndatasize() {\\n                // Copy returndata to memory, overwriting existing memory.\\n                returndatacopy(0, 0, returndatasize())\\n\\n                // Revert, specifying memory region with copied returndata.\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a given element is contained\\n     *      in a merkle root via a supplied proof.\\n     *\\n     * @param leaf  The element for which to prove inclusion.\\n     * @param root  The merkle root that inclusion will be proved against.\\n     * @param proof The merkle proof.\\n     */\\n    function _verifyProof(\\n        uint256 leaf,\\n        uint256 root,\\n        bytes32[] memory proof\\n    ) internal pure {\\n        // Convert the supplied leaf element from uint256 to bytes32.\\n        bytes32 computedHash = bytes32(leaf);\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Iterate over each proof element.\\n            for (uint256 i = 0; i < proof.length; ++i) {\\n                // Retrieve the proof element.\\n                bytes32 proofElement = proof[i];\\n\\n                if (computedHash <= proofElement) {\\n                    // Hash(current computed hash + current element of proof)\\n                    computedHash = _efficientHash(computedHash, proofElement);\\n                } else {\\n                    // Hash(current element of proof + current computed hash)\\n                    computedHash = _efficientHash(proofElement, computedHash);\\n                }\\n            }\\n        }\\n\\n        // Ensure that the final derived hash matches the expected root.\\n        if (computedHash != bytes32(root)) {\\n            revert InvalidProof();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to efficiently hash two bytes32 values.\\n     *\\n     * @param a The first component of the hash.\\n     * @param b The second component of the hash.\\n     *\\n     * @return value The hash.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b)\\n        internal\\n        pure\\n        returns (bytes32 value)\\n    {\\n        assembly {\\n            mstore(0x00, a) // Place element a in first word of scratch space.\\n            mstore(0x20, b) // Place element b in second word of scratch space.\\n            value := keccak256(0x00, 0x40) // Hash scratch space region.\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that the supplied consideration\\n     *      array length for an order to be fulfilled is not less than the\\n     *      original consideration array length for that order.\\n     *\\n     * @param suppliedConsiderationItemTotal The number of consideration items\\n     *                                       supplied when fulfilling the order.\\n     * @param originalConsiderationItemTotal The number of consideration items\\n     *                                       supplied on initial order creation.\\n     */\\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n        uint256 suppliedConsiderationItemTotal,\\n        uint256 originalConsiderationItemTotal\\n    ) internal pure {\\n        // Ensure supplied consideration array length is not less than original.\\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\\n            revert MissingOriginalConsiderationItems();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a given item amount in not\\n     *      zero.\\n     *\\n     * @param amount The amount to check.\\n     */\\n    function _assertNonZeroAmount(uint256 amount) internal pure {\\n        if (amount == 0) {\\n            revert MissingItemAmount();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to validate calldata offsets for dynamic\\n     *      types in BasicOrderParameters. This ensures that functions using the\\n     *      calldata object normally will be using the same data as the assembly\\n     *      functions. Note that no parameters are supplied as all basic order\\n     *      functions use the same calldata encoding.\\n     */\\n    function _assertValidBasicOrderParameterOffsets() internal pure {\\n        // Declare a boolean designating basic order parameter offset validity.\\n        bool validOffsets;\\n\\n        // Utilize assembly in order to read offset data directly from calldata.\\n        assembly {\\n            /*\\n             * Checks:\\n             * 1. Order parameters struct offset == 0x20\\n             * 2. Additional recipients arr offset == 0x200\\n             * 3. Signature offset == 0x240 + (recipients.length * 0x40)\\n             */\\n            validOffsets := and(\\n                // Order parameters have offset of 0x20\\n                eq(calldataload(0x04), 0x20),\\n                // Additional recipients have offset of 0x200\\n                eq(calldataload(0x224), 0x240)\\n            )\\n            validOffsets := and(\\n                validOffsets,\\n                eq(\\n                    // Load signature offset from calldata\\n                    calldataload(0x244),\\n                    // Calculate expected offset: start of recipients + len * 64\\n                    add(0x260, mul(calldataload(0x264), 0x40))\\n                )\\n            )\\n        }\\n\\n        // Revert with an error if basic order parameter offsets are invalid.\\n        if (!validOffsets) {\\n            revert InvalidBasicOrderParameterEncoding();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x63bf3bda38235ce362c87791de6b06f8ceef67ce26224b8e6c36aa09d190cbf4\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// prettier-ignore\\nimport {\\n    OrderType,\\n    BasicOrderType,\\n    ItemType,\\n    Side\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\n/**\\n * @dev An order contains ten components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support, restricted\\n *      order status, and the offerer's conduit usage preference), the start and\\n *      end time, a hash that will be provided to the zone when validating\\n *      restricted orders, a salt, a nonce, and an arbitrary number of offer\\n *      items that can be spent along with consideration items that must be\\n *      received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    address conduit;\\n    uint256 nonce;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item an has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    address offererConduit; // 0x1c4\\n    address fulfillerConduit; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the nonce, must\\n *      be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    address conduit; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                           // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in additon to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be included in a staticcall to\\n *      `isValidOrderIncludingExtraData` on the zone for the order if the order\\n *      type is restricted and the offerer or zone are not the caller.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone nonce), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfullment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    address conduit;\\n}\\n\\n/**\\n * @dev A batch execution operates in a similar fashion to a standard execution,\\n *      but instead will transfer a number of ERC1155 tokenIds on the same token\\n *      contract in a single batch transaction.\\n */\\nstruct BatchExecution {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] tokenIds;\\n    uint256[] amounts;\\n    address conduit;\\n}\\n\\n/**\\n * @dev An internal struct for facilitating batch execution construction.\\n */\\nstruct Batch {\\n    bytes32 hash;\\n    uint256[] executionIndices;\\n}\\n\",\"keccak256\":\"0xf5e998d631f18c9f9dd13b872352526b629078f4e03fa4fd4e8d683f0add5288\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101e060405234620000af5762000020620000196200011f565b9162000201565b604051615e0d9081620006e3823960805181614021015260a05181614047015260c05181613ffe015260e051818181611c900152614097015261010051818181611b5c01526140e6015261012051818181611d2b015261413401526101405181613fac01526101605181613fd20152610180518161379901526101a0518161316b01526101c051816137f90152f35b600080fd5b604081019081106001600160401b03821117620000d057604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b03821190821017620000d057604052565b51906001600160a01b0382168203620000af57565b620064f090606082380392836040519485926200013d8285620000e6565b833981010312620000af5762000153826200010a565b9062000170604062000168602086016200010a565b94016200010a565b91929190565b604051906200018582620000b4565b600d82526c21b7b739b4b232b930ba34b7b760991b6020830152565b60405190620001b082620000b4565b600482526372632e3160e01b6020830152565b90815180926000905b828210620001e9575011620001df570190565b6000828201520190565b915080602080928401015181850152018391620001cc565b906200020c62000176565b805160208092012060805262000221620001a1565b80519082012060a0526040516909ecccccae492e8cada560b31b8183019081529181600a84016e1d5a5b9d0e081a5d195b551e5c194b608a1b8152600f016d1859191c995cdcc81d1bdad95b8b60921b8152600e017f75696e74323536206964656e7469666965724f7243726974657269612c0000008152601d017f75696e74323536207374617274416d6f756e742c0000000000000000000000008152601401701d5a5b9d0c8d4d88195b99105b5bdd5b9d607a1b8152601101602960f81b81526001010390601f19918281018452620002fd9084620000e6565b6040519281840184620003298260129071086dedce6d2c8cae4c2e8d2dedc92e8cada560731b81520190565b6e1d5a5b9d0e081a5d195b551e5c194b608a1b8152600f016d1859191c995cdcc81d1bdad95b8b60921b8152600e017f75696e74323536206964656e7469666965724f7243726974657269612c0000008152601d017f75696e74323536207374617274416d6f756e742c0000000000000000000000008152601401711d5a5b9d0c8d4d88195b99105b5bdd5b9d0b60721b8152601201701859191c995cdcc81c9958da5c1a595b9d607a1b8152601101602960f81b8152600101038481018652620003f59086620000e6565b60405195868481016200041f906010906f09ee4c8cae486dedae0dedccadce8e6560831b81520190565b6f1859191c995cdcc81bd999995c995c8b60821b81526010016c1859191c995cdcc81e9bdb994b609a1b8152600d017113d999995c925d195b56d7481bd999995c8b60721b81526012017f436f6e73696465726174696f6e4974656d5b5d20636f6e73696465726174696f8152611b8b60f21b60208201526022016f1d5a5b9d0e081bdc99195c951e5c194b60821b8152601001711d5a5b9d0c8d4d881cdd185c9d151a5b594b60721b81526012016f1d5a5b9d0c8d4d88195b99151a5b594b60821b815260100170189e5d195ccccc881e9bdb9952185cda0b607a1b81526011016c1d5a5b9d0c8d4d881cd85b1d0b609a1b8152600d016f1859191c995cdcc818dbdb991d5a5d0b60821b81526010016c75696e74323536206e6f6e636560981b8152600d01602960f81b8152600101038581018852620005629088620000e6565b6040516c08a92a06e626488dedac2d2dc5609b1b8582019081529080600d83016b1cdd1c9a5b99c81b985b594b60a21b8152600c016e1cdd1c9a5b99c81d995c9cda5bdb8b608a1b8152600f016f1d5a5b9d0c8d4d8818da185a5b92590b60821b81526010017f6164647265737320766572696679696e67436f6e7472616374000000000000008152601901602960f81b81526001010387810182526200060a9082620000e6565b51902060c0528251902060e0528451902061010052604051938492830195866200063491620001c3565b6200063f91620001c3565b6200064a91620001c3565b0390810182526200065c9082620000e6565b5190206101205246610140526200067262000695565b610160526001600160a01b0391821661018052166101a0526101c0526001600055565b60c05160805160a0516040519160208301938452604083015260608201524660808201523060a082015260a0815260c0810181811060018060401b03821117620000d0576040525190209056fe60806040526004361015610013575b600080fd5b60003560e01c806306fdde031461013f5780630dfa8f67146101365780632d0335ab1461012d5780633644e5151461012457806346423aa71461011b57806354fd4d5014610112578063627cdcb9146101095780637ceac2a314610100578063864eba38146100f757806395c37a41146100ee578063c65e79a0146100e5578063d92b6880146100dc578063e58dd01d146100d3578063ef3e0fd2146100ca5763f0f90af0146100c257600080fd5b61000e6114da565b5061000e611435565b5061000e61124f565b5061000e6111cc565b5061000e61112e565b5061000e611020565b5061000e610ed8565b5061000e610dd9565b5061000e6103ae565b5061000e610368565b5061000e6102d6565b5061000e6102b2565b5061000e610274565b5061000e61020a565b5061000e610199565b91908251928382526000905b848210610181575092806020939411610174575b601f01601f1916010190565b6000838284010152610168565b90602090818082850101519082860101520190610154565b503461000e57600036600319011261000e576101e86040516101ba81610488565b600d81526c21b7b739b4b232b930ba34b7b760991b6020820152604051918291602083526020830190610148565b0390f35b6001600160a01b0381160361000e57565b3590610208826101ec565b565b5060031960403682011261000e57600435906001600160401b03821161000e57604090823603011261000e5761026a6020916102546024359161024c836101ec565b600401615c80565b60405190610261826104be565b60008252612070565b6040519015158152f35b503461000e57602036600319011261000e57600435610292816101ec565b60018060a01b031660005260026020526020604060002054604051908152f35b503461000e57600036600319011261000e5760206102ce613fa9565b604051908152f35b503461000e57602036600319011261000e5760043560005260016020526040600020604051906103058261042a565b546101e8606060ff831615159283855260ff8160081c161515948560208201526001600160781b038260101c169182604083015260881c928391015260405194859485909493926060926080830196151583521515602083015260408201520152565b503461000e57600036600319011261000e576101e860405161038981610488565b600481526372632e3160e01b6020820152604051918291602083526020830190610148565b503461000e57600036600319011261000e576103c8613c8b565b3360005260026020526020604060002060018154018091556040518181527f7ab0fc7de8910a6100b24df423c3d0835534506dca9473d30c3e7df51241b2cf833392a2604051908152f35b50634e487b7160e01b600052604160045260246000fd5b608081019081106001600160401b0382111761044557604052565b61044d610413565b604052565b60a081019081106001600160401b0382111761044557604052565b60c081019081106001600160401b0382111761044557604052565b604081019081106001600160401b0382111761044557604052565b606081019081106001600160401b0382111761044557604052565b602081019081106001600160401b0382111761044557604052565b90601f801991011681019081106001600160401b0382111761044557604052565b6040519061016082018281106001600160401b0382111761044557604052565b6040519061020882610452565b60405190610208826104a3565b604051906102088261046d565b6020906001600160401b03811161055a575b60051b0190565b610562610413565b610553565b3590600682101561000e57565b92919261058082610541565b60409461058f865192836104d9565b819584835260208093019160a080960285019481861161000e57925b8584106105bb5750505050505050565b868483031261000e5784879184516105d281610452565b6105db87610567565b8152828701356105ea816101ec565b83820152858701358682015260608088013590820152608080880135908201528152019301926105ab565b9080601f8301121561000e5781602061063093359101610574565b90565b92919261063f82610541565b60409461064e865192836104d9565b819584835260208093019160c080960285019481861161000e57925b85841061067a5750505050505050565b868483031261000e5784879184516106918161046d565b61069a87610567565b8152828701356106a9816101ec565b838201528587013586820152606080880135908201526080808801359082015260a080880135906106d9826101ec565b82015281520193019261066a565b9080601f8301121561000e5781602061063093359101610633565b6004111561000e57565b359061020882610702565b9190916101608184031261000e5761072d6104fa565b92610737826101fd565b8452610745602083016101fd565b60208501526001600160401b0390604083013582811161000e578161076b918501610615565b6040860152606083013591821161000e576107879183016106e7565b60608401526107986080820161070c565b608084015260a081013560a084015260c081013560c084015260e081013560e084015261010080820135908401526101206107d48183016101fd565b908401526101408091013590830152565b35906001600160781b038216820361000e57565b6020906001600160401b038111610816575b601f01601f19160190565b61081e610413565b61080b565b92919261082f826107f9565b9161083d60405193846104d9565b82948184528183011161000e578281602093846000960137010152565b9080601f8301121561000e5781602061063093359101610823565b91909160a08184031261000e5761088a61051a565b926001600160401b03823581811161000e57826108a8918501610717565b85526108b6602084016107e5565b60208601526108c7604084016107e5565b6040860152606083013581811161000e57826108e491850161085a565b6060860152608083013590811161000e576108ff920161085a565b6080830152565b9080601f8301121561000e5781359061091e82610541565b9261092c60405194856104d9565b828452602092838086019160051b8301019280841161000e57848301915b84831061095a5750505050505090565b82356001600160401b03811161000e57869161097b84848094890101610875565b81520192019161094a565b81601f8201121561000e5780359161099d83610541565b926109ab60405194856104d9565b808452602092838086019260051b82010192831161000e578301905b8282106109d5575050505090565b813581529083019083016109c7565b9092916109f084610541565b91604094610a00865194856104d9565b839581855260208095019160051b83019380851161000e5783925b858410610a2b5750505050505050565b6001600160401b0390843582811161000e5786019060a08285031261000e578451610a5581610452565b8235815289830135600281101561000e578a82015285830135868201526060808401359082015260808084013594851161000e57610a97868c96879601610986565b90820152815201930192610a1b565b9080601f8301121561000e57816020610630933591016109e4565b81601f8201121561000e57803590610ad882610541565b92604092610ae8845195866104d9565b808552602091828087019260061b8501019381851161000e578301915b848310610b155750505050505090565b858383031261000e578386918251610b2c81610488565b853581528286013583820152815201920191610b05565b9080601f8301121561000e57813590610b5b82610541565b92610b6960405194856104d9565b828452602092838086019160051b8301019280841161000e57848301915b848310610b975750505050505090565b82356001600160401b03811161000e578691610bb884848094890101610ac1565b815201920191610b87565b50634e487b7160e01b600052602160045260246000fd5b60061115610be457565b610208610bc3565b6080908051610bfa81610bda565b83528160018060a01b03918260208201511660208601526040810151604086015260608101516060860152015116910152565b90815180825260208080930193019160005b828110610c4d575050505090565b909192938260e06001928751610c64828251610bec565b6040858060a01b039182868201511660a085015201511660c0820152019501910192919092610c3f565b90815180825260208080930193019160005b828110610cae575050505090565b835185529381019392810192600101610ca0565b908082519081815260208091019281808460051b8301019501936000915b848310610cf05750505050505090565b9091929394958480600192601f19858203018652895190848060a01b039182815116825282848201511684830152604083818301511690830152610d59610d466060808401519060c08091870152850190610c8e565b6080808401519085830390860152610c8e565b9260a080920151169101529801930193019194939290610ce0565b91939290936060830194606084528051809652608084019560208092019060005b818110610dc35750505094610db591610630959685830390860152610c2d565b916040818403910152610cc2565b8251151589529783019791830191600101610d95565b5060a036600319011261000e576001600160401b0360043581811161000e57610e06903690600401610906565b9060243581811161000e57610e1f903690600401610aa6565b9160443582811161000e57610e38903690600401610b43565b9260643592831161000e576101e893610e58610e6b943690600401610b43565b9160843593610e66856101ec565b61177b565b60409391935193849384610d74565b9181601f8401121561000e578235916001600160401b03831161000e576020808501948460051b01011161000e57565b602060031982011261000e57600435906001600160401b03821161000e57610ed491600401610e7a565b9091565b503461000e57610ee736610eaa565b610eef613c8b565b60005b818110610f055760405160018152602090f35b80610f1360019284866119f3565b610f1d8180611922565b90610f278261175e565b91610f3a610f353683610717565b6141b4565b91610f72610f6e610f5d610f58866000526001602052604060002090565b611a23565b610f678187615b1e565b5051151590565b1590565b610f81575b5050505001610ef2565b610ff7611014917ffde361574a066b44b3b5fe98a87108b7565e327327954c4faeea56a4e6491a0a93610fcd610fc6610fbf60209485810190611a65565b3691610823565b8789613d94565b610ff1610fe4876000526001602052604060002090565b805460ff19166001179055565b0161175e565b604051918291888060a01b03809116961694829190602083019252565b0390a338808080610f77565b503461000e57602036600319011261000e576004356001600160401b03811161000e57611051903690600401610717565b80516001600160a01b031660208201519091906001600160a01b0316906040810151606082019081516080840151611088816119c8565b60a085015160c086015160e08701519161010093848901519561012097888b01516110b89060018060a01b031690565b9951519b6110c46104fa565b6001600160a01b039e8f1681529d1660208e015260408d015260608c01526110ef9060808c016119dc565b60a08a015260c089015260e08801528601526001600160a01b0390911690840152610140918284015201516111239161408a565b604051908152602090f35b5060031960603682011261000e57600435906001600160401b039081831161000e5760a090833603011261000e5760243590811161000e576020916111a161117d61026a933690600401610e7a565b91906111996044359461118f866101ec565b3690600401610875565b9236916109e4565b90612070565b90916111be61063093604084526040840190610c2d565b916020818403910152610cc2565b50606036600319011261000e576001600160401b0360043581811161000e576111f9903690600401610906565b9060243581811161000e57611212903690600401610aa6565b60443591821161000e5761123f9261123161123a933690600401610e7a565b93909282612845565b612d0f565b906101e8604051928392836111a7565b503461000e5761125e36610eaa565b611266613c8b565b60005b81811061127c5760405160018152602090f35b611287818385611938565b6112908161175e565b60209061129e82840161175e565b6001600160a01b03828116939092903385141580611429575b611417576040956112ca8188018261195e565b606091828401926112db8486611993565b60809291908d6112ec8986016119d2565b95610120978d898c016112fe9061175e565b9a611309908d611993565b9d90506113146104fa565b6001600160a01b03909f168f528e6001600160a01b03909216910152369061133b92610574565b908b0152369061134a92610633565b9088015286019061135a916119dc565b60a0838101359086015260c0808401359086015260e0808401359086015261010080840135908601526001600160a01b0390911690840152610140918284015201356113a59161408a565b936113ba856000526001602052604060002090565b805460ff191690556113d6856000526001602052604060002090565b805461ff0019166101001790555193845216917f6bacc01dbe442496068f7d234edd811f1a5f833243e0aec824f86ab861f3c90d90602090a3600101611269565b60405163203b1cdd60e21b8152600490fd5b508383163314156112b7565b50604036600319011261000e576001600160401b0360043581811161000e57611462903690600401610e7a565b9160243590811161000e5761147b903690600401610e7a565b9161148584611fd7565b9360005b8181106114a85750505061123f9261123a6114a2611768565b82612845565b806114be6114b960019385876119f3565b615c80565b6114c8828961204e565b526114d3818861204e565b5001611489565b5060031960203682011261000e57600435906001600160401b03821161000e576102408260040191833603011261000e5761012435918260021c6001811190341582036117425761155c6003821192600283149687600285116001198601020191600183018602811560011b8601039260038760a00260240135931689611b0b565b6115686064840161175e565b9160051b6101c401359461157b82610bda565b816115c9575050906115b66115bd9460449361159960a4850161175e565b60e48501359160c48601359133916001600160a01b03169061331b565b01356138f1565b60405160018152602090f35b6115d282610bda565b60018203611615575050906115b6611610946044936115f360a4850161175e565b60e48501359160c48601359133916001600160a01b03169061343a565b6115bd565b61162182949394610bda565b15611670575061165b6116109461163a60a4840161175e565b6001600160a01b039094169360e48401359060c4850135903390879061331b565b60446116668461175e565b9101359133613a27565b61167981610bda565b600381036116b6575061165b6116109461169560a4840161175e565b6001600160a01b039094169360e48401359060c4850135903390879061343a565b806116c2600492610bda565b03611711576116f8611610946116d78561175e565b6001600160a01b03909416936044840135906024850135908690339061331b565b60e461170660a4830161175e565b91013591339061398f565b6116f8611610946117218561175e565b6001600160a01b03909416936044840135906024850135908690339061343a565b604051630a61be9f60e41b8152346004820152602490fd5b0390fd5b35610630816101ec565b604051611774816104be565b6000815290565b9061178b90959394929582612a75565b6117a061179b8651865190611aff565b612c51565b91600093845b8751861015611833576117c36117bc878a61204e565b51856149b2565b8051608001516001600160a01b031660208201516117f1906001600160a01b03165b6001600160a01b031690565b6001600160a01b039091160361181057506001809101955b01946117a6565b9561182d8297600193830390611826828a61204e565b528761204e565b50611809565b94509495929190956000945b81518610156118c85761185d88611856888561204e565b5185614aab565b8051608001516001600160a01b03166020820151611883906001600160a01b03166117e5565b6001600160a01b03909116036118a257506001809101955b019461183f565b956118c282976001938851840103906118bb828961204e565b528661204e565b5061189b565b935050939450915080611900575b508051156118ee576118e791612dd5565b9192909190565b60405163d5da9a1b60e01b8152600490fd5b8151038152386118d6565b50634e487b7160e01b600052603260045260246000fd5b90359061015e198136030182121561000e570190565b909161063092811015611951575b60051b810190611922565b61195961190b565b611946565b903590601e198136030182121561000e57018035906001600160401b03821161000e576020019160a082023603831361000e57565b903590601e198136030182121561000e57018035906001600160401b03821161000e576020019160c082023603831361000e57565b60041115610be457565b3561063081610702565b60048210156119e85752565b6119f0610bc3565b52565b9190811015611a16575b60051b81013590603e198136030182121561000e570190565b611a1e61190b565b6119fd565b90604051611a308161042a565b606081935460ff81161515835260ff8160081c16151560208401526001600160781b038160101c16604084015260881c910152565b903590601e198136030182121561000e57018035906001600160401b03821161000e5760200191813603831361000e57565b903590601e198136030182121561000e57018035906001600160401b03821161000e57602001918160061b3603831361000e57565b50634e487b7160e01b600052601160045260246000fd5b6001906001198111611af3570190565b611afb611acc565b0190565b81198111611af3570190565b959190611b16613a9f565b611b2a610140880135610120890135613ca9565b50611b33615d9e565b611b5a611b4e611b476102008a018a611a97565b9050611ae3565b6101e089013590615d6c565b7f00000000000000000000000000000000000000000000000000000000000000006080528160a0526060602460c037604060646101203760e06080908120610160526001610264359081016102a060059290921b918201526102c081019384526024906102e00137610160928460a0528560c052600060e05260005b839461020435821015611c335790604060a0600193602090818560061b6102840161010037838560061b6102840161012037019660e0608020885201968888528960c08201526101008360061b6102840191013701939293611bd6565b5090929350969590966001610204350160051b610160206060525b8361026435821015611c815790604060a060019301958787528860c08201526101008360061b6102840191013701611c4e565b505093509490506102089391507f00000000000000000000000000000000000000000000000000000000000000006080528260a052606060c460c03760206101046101203760c0608020600052602060002060e05260016102643560051b610200015261022092836102643560051b0152606060c46102406102643560051b0137611e2c610fbf60843593611d288560018060a01b03166000526002602052604060002090565b547f00000000000000000000000000000000000000000000000000000000000000006080526040608460a03760605161010052846101205260a0610144610140376101e0526101809485608020956102643560051b0190868252336101a06102643560051b015260806101c06102643560051b01526101206101e06102643560051b01527f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f3160a4359260a061026435026101e00190a36000606052611e2360608201611e1e611df68261175e565b96611e036080860161175e565b6001600160a01b03989091908916906101608701358b6141ed565b61175e565b95810190611a65565b921690611f1b916102089382600052600160205282611e94610f6e604060002060405190611e598261042a565b5460ff81161515825260ff8160081c16151560208301526001600160781b038160101c16604083015260881c6060820152610f678185615b8b565b611f30575b611eb39250610fe491506000526001602052604060002090565b611ed5611eca826000526001602052604060002090565b805461ff0019169055565b611f0b611eec826000526001602052604060002090565b805470ffffffffffffffffffffffffffffff0000191662010000179055565b6000526001602052604060002090565b80546001600160881b0316600160881b179055565b611f3992613d94565b388082611e99565b60405190611f4e82610452565b60405160808361016083016001600160401b03811184821017611fca575b6040526000808452806020850152606093846040820152848082015281848201528160a08201528160c08201528160e08201528161010082015281610120820152816101408201528252806020830152604082015282808201520152565b611fd2610413565b611f6c565b90611fe182610541565b611fee60405191826104d9565b8281528092611fff601f1991610541565b019060005b82811061201057505050565b60209061201b611f41565b82828501015201612004565b602090805115612035570190565b611afb61190b565b604090805160011015612035570190565b6020918151811015612063575b60051b010190565b61206b61190b565b61205b565b91909161207b613c8b565b60026000556120898161217d565b90936040519461209886610488565b6001865260005b6020808210156120c157906020916120b5611f41565b90828a0101520161209f565b505090919361211393956120f3612142986120f893835115612151575b60208401526120ec83612027565b5082614fd1565b612027565b51516101208101519094906001600160a01b03169185612665565b80516001600160a01b03165b60208201519092906001600160a01b031660606040840151930151933392613bc3565b61214c6001600055565b600190565b61215961190b565b6120de565b8060001904821181151516612171570290565b612179611acc565b0290565b805191612196610f6e60a085015160c086015190613ca9565b612488576121bd6121b160208401516001600160781b031690565b6001600160781b031690565b926121d56121b160408501516001600160781b031690565b938481118015612480575b61246e5784811080612456575b612444576121fa826141b4565b9161223560e08201516080830151612211816119c8565b83516001600160a01b031660208501519091906001600160a01b031692878a614636565b61224c610f58846000526001602052604060002090565b9461225a610f6e8786615b1e565b612434578361226c610f6e8851151590565b612410575b5050506122a26121b160606122936121b160408901516001600160781b031690565b9601516001600160781b031690565b9485156123b9576001810361238157505083925b836122c18683611aff565b11612377575b84612342612372926122e6610fe4866000526001602052604060002090565b6122fd611eca866000526001602052604060002090565b6001600160781b03928391011661231e856000526001602052604060002090565b9062010000600160881b0382549160101b169062010000600160881b031916179055565b8416612358836000526001602052604060002090565b906001600160881b0382549181199060881b169116179055565b929190565b80840394506122c7565b939094848103612392575b506122b6565b6123ac816123a6876123b29599989961215e565b9661215e565b9561215e565b923861238c565b935093506123d4610fe4826000526001602052604060002090565b6123eb611eca826000526001602052604060002090565b6123726001600160781b0361234281871661231e856000526001602052604060002090565b915161242c92906060906001600160a01b031692015191613d94565b388083612271565b5050509150915090600090600090565b60405163a11b63ff60e01b8152600490fd5b5060016080830151612467816119c8565b16156121ed565b604051632d02959960e11b8152600490fd5b5080156121e0565b600092508291508190565b90918151926124ae610f6e60a086015160c087015190613ca9565b612561576124c96121b160208501516001600160781b031690565b6124e06121b160408601516001600160781b031690565b948582118015612559575b61246e5785821080612541575b61244457612235612508826141b4565b9360e0830151608084015161251c816119c8565b84516001600160a01b0316602086015190929088906001600160a01b0316948b614714565b5060016080820151612552816119c8565b16156124f8565b5081156124eb565b50600092508291508190565b9091815192612588610f6e60a086015160c087015190613cda565b612561576125a36121b160208501516001600160781b031690565b6125ba6121b160408601516001600160781b031690565b94858211801561261f575b61246e5785821080612607575b612444576125e2612508826141b4565b6125f9610f58846000526001602052604060002090565b9461225a610f6e8786615bc4565b5060016080820151612618816119c8565b16156125d2565b5081156125c5565b60018110612637575b6000190190565b61263f611acc565b612630565b81811061264f570390565b612657611acc565b0390565b5161063081610bda565b91909493929460c08301519360a09161268e61268684870197885190612644565b965142612644565b956126998782612644565b349460005b6040808a0151805183101561274757898e92886126d98f94896126c2898d9361204e565b5196606088019687519560808a01968751906158a7565b80935233905282516126ea81610bda565b6126f381610bda565b1561271c575b50508a51600193926127169290916001600160a01b031690612f8e565b0161269e565b90925089839a929a11612737575003968c90816127166126f9565b51631a783b8d60e01b8152600490fd5b5050509397909192949596995060005b6060808c015180518310156127f45790898861279088888f9661277b898b9261204e565b519687019586519560808901968751906158e7565b80925288830151905281516127a481610bda565b6127ad81610bda565b156127c9575b50600192916127c3913390612f8e565b01612757565b90988093925081116127e25790910396899060016127b3565b604051631a783b8d60e01b8152600490fd5b50505050505050509293505050806128095750565b6102089033613085565b9061281d82610541565b61282a60405191826104d9565b828152809261283b601f1991610541565b0190602036910137565b9061284e613a9f565b81519161285a83612813565b91600090818452815b8581106128e757506128759083614fd1565b8381106128825750505050565b8061288f6001928561204e565b51156128e2576128dc6128a2828561204e565b51516128ae838761204e565b5181519091906001600160a01b031660208201516001600160a01b0316906060604084015193015193613aef565b01612875565b6128dc565b6128f1818561204e565b516128fc8682612493565b926001929192938486018a5260c082519360a09485810151928391015103914203808303918d8c8915612a5d57508a6129349161204e565b5284516040015188828d825b6129e5575b5050505060608095510151888c905b61296d575b505050505050505050506001905b01612863565b81518110156129e05789818a8a8a8a6129c38b8b8b61298d8a9b8d61204e565b519560808701986129a08a5188836152af565b918801968751908b5182146000146129d0575050508086525b8089528551615276565b9052015190520190612954565b6129d9926152af565b86526129b9565b612959565b878b88888751851015612a545786956060612a3994612a04888c61204e565b51906080820190612a1782518a836152af565b938493019889519083518214600014612a44575050508188525b528551615241565b905201839082612940565b612a4d926152af565b8852612a31565b50505050612945565b98505050505050506001949350602091500152612967565b90612a7e613a9f565b815191612a8a83612813565b91600090818452815b858110612afd5750612aa59083614fd1565b838110612ab25750505050565b80612abf6001928561204e565b5115612af857612af2612ad2828561204e565b5151612ade838761204e565b5181519091906001600160a01b031661211f565b01612aa5565b612af2565b612b07818561204e565b51612b12868261256d565b926001929192938486018a5260c082519360a09485810151928391015103914203808303918d8c8915612be857508a612b4a9161204e565b5284516040015188828d825b612bb5575b5050505060608095510151888c905b612b83575b505050505050505050506001905b01612a93565b8151811015612bb05789818a8a8a8a612ba38b8b8b61298d8a9b8d61204e565b9052015190520190612b6a565b612b6f565b878b88888751851015612bdf5786956060612bd494612a04888c61204e565b905201839082612b56565b50505050612b5b565b98505050505050506001949350602091500152612b7d565b60405190612c0d82610452565b60006080838281528260208201528260408201528260608201520152565b60405190612c38826104a3565b6000604083612c45612c00565b81528260208201520152565b90612c5b82610541565b612c6860405191826104d9565b8281528092612c79601f1991610541565b019060005b828110612c8a57505050565b602090612c95612c2b565b82828501015201612c7e565b60408136031261000e5760408051916001600160401b0391830182811184821017612d02575b604052803582811161000e57612ce09036908301610ac1565b8352602081013591821161000e57612cfa91369101610ac1565b602082015290565b612d0a610413565b612cc7565b929192612d1b84612c51565b9160009081955b808710612d4f575050612d3d93945080612d44575b50612dd5565b9291509190565b825103825238612d37565b9091612d64612d5f8884866119f3565b612ca1565b612d76815160208093015190876147f7565b8051608001519181015190916001600160a01b0390811691612d9891166117e5565b6001600160a01b0390911603612db957506001809101965b01959190612d22565b96612dcf8298600193830390611826828a61204e565b50612db0565b908151612de181612813565b926000905b828210612ed757505050612df9906153ee565b349360005b8351811015612e8757612e11818561204e565b518051908151612e2081610bda565b612e2981610bda565b15612e69575b602081015160019392612e63929091612e5d906040906001600160a01b03169201516001600160a01b031690565b91612f8e565b01612dfe565b9691906060810190838251116127e257905190920396909190612e2f565b50909260005b8451811015612eb25780612eac612ea66001938861204e565b5161364b565b01612e8d565b5090919380612ec7575b506123726001600055565b612ed19033613085565b38612ebc565b91949093612ee5858461204e565b5193612efe6121b160208701516001600160781b031690565b15612f7f57612f16612f10878461204e565b60019052565b606080955101519660005b8851811015612f6c5786612f35828b61204e565b51015180612f465750600101612f21565b6040516314bea84160e31b8152600481018a905260248101929092526044820152606490fd5b50939296509350936001905b0190612de6565b93509360019095929195612f78565b91908251612f9b81610bda565b612fa481610bda565b612fc75750506080810151606090910151610208916001600160a01b0316613085565b60018351612fd481610bda565b612fdd81610bda565b0361300c57602083015160808401516060909401516102089490926001600160a01b03918216929091166130f6565b6002835161301981610bda565b61302281610bda565b036130565760208301516080840151604085015160609095015161020895909390926001600160a01b03928316921661331b565b60208301516080840151604085015160609095015161020895909390926001600160a01b03928316921661343a565b9061308f81615d85565b600080808084865af1156130a1575050565b604492506130ad615cef565b60405163470c7c1d60e01b81526001600160a01b0390921660048301526024820152fd5b9081602091031261000e5751801515810361000e5790565b506040513d6000823e3d90fd5b909361310184615d85565b6001600160a01b039081168061311d5750509261020893613256565b9193929160010361321b57604051630aed65f560e11b81526001600160a01b0385811660048301528681166024830152831660448201526064810184905290602090829060849082906000907f0000000000000000000000000000000000000000000000000000000000000000165af190811561320e575b6000916131e0575b50156131a95750505050565b604051639889192360e01b81526001600160a01b039384166004820152938316602485015290911660448301526064820152608490fd5b613201915060203d8111613207575b6131f981836104d9565b8101906130d1565b3861319d565b503d6131ef565b6132166130e9565b613195565b60405162461bcd60e51b8152602060048201526013602482015272139bdd081e595d081a5b5c1b195b595b9d1959606a1b6044820152606490fd5b9092604051926000946323b872dd60e01b865280600452816024528260445260208660648180885af1803d15601f3d1160018a51141617163d15158116156132a7575b505050505050604052606052565b80863b1515166132995787959650156132ce57632f8aeb3960e11b85526004869052602485fd5b156132ee5760a494639889192360e01b8552600452602452604452606452fd5b3d6133125760a49463f486bc8760e01b855260045260245260445281606452608452fd5b833d81803e3d90fd5b92909493919360018303613428576001600160a01b0316806133bc5750823b156133a757604051936000956323b872dd60e01b8752806004528160245282604452868060648180895af115613377575050505050604052606052565b869495503d61339e5760a49563f486bc8760e01b8652600452602452604452606452608452fd5b843d81803e3d90fd5b82632f8aeb3960e11b60005260045260246000fd5b600190959193959492941460001461321b576040516323b872dd60e01b60208201526001600160a01b038083166024830152831660448201526064810184905261020895906134239061341c81608481015b03601f1981018352826104d9565b828461376f565b613cfe565b60405163efcc00b160e01b8152600490fd5b909492919261344885615d85565b6001600160a01b0316806134ec5750803b156134d857604051936080519260a05194600097637921219560e11b89528060045281602452826044528360645260a06084528860a452888060c48180895af1156134b157505050505060805260a052604052606052565b889495503d61339e5760a49563f486bc8760e01b8652600452602452604452606452608452fd5b632f8aeb3960e11b60005260045260246000fd5b90949192919060010361321b57604051637921219560e11b60208201526001600160a01b03808316602483015283166044820152606481018490526084810185905260a060a4820152600060c482015261020895906134239061341c8160e4810161340e565b6060519081815260208091019160809160005b828110613573575050505090565b835185529381019392810192600101613565565b926135b690602095926135c49460018060a01b038092168752168686015260a0604086015260a0850190610c8e565b908382036060850152610c8e565b906080818303910152600081520190565b3d15613600573d906135e6826107f9565b916135f460405193846104d9565b82523d6000602084013e565b606090565b6001600160a01b0391821681529181166020830152909116604082015260a06060820181905261063093919261363d91840190610c8e565b916080818403910152610c8e565b60a081015181516020830151604084015160608501516080909501516001600160a01b03938416959284169490939182169116806136f657506000806040516020810190631759616b60e11b82526136ad8161340e8989898d60248601613587565b519082895af16136bb6135d5565b505b156136cf575050505061020890613d5a565b61175a9395506136dd615cef565b6040516357e222f160e11b815295869560048701613605565b60010361321b57604051631759616b60e11b602082015261372c906137258161340e8787878b60248601613587565b868661376f565b6136bd565b9081602091031261000e5751610630816101ec565b6001600160a01b0390911681526000602082015260606040820181905261063092910190610148565b60405163c455279160e01b81526001600160a01b03918216600482015260209392909184836024817f000000000000000000000000000000000000000000000000000000000000000085165afa9283156138c6575b6000936138a7575b50604051635c60da1b60e01b81529085826004818785165afa91821561389a575b60009261386b575b50807f000000000000000000000000000000000000000000000000000000000000000016911603613859576000809493613849829561340e604051938492830196633f801f9160e01b885260248401613746565b51925af16138556135d5565b5090565b60405163dcd488e360e01b8152600490fd5b61388c919250863d8811613893575b61388481836104d9565b810190613731565b90386137f5565b503d61387a565b6138a26130e9565b6137ed565b6138bf919350853d87116138935761388481836104d9565b91386137cc565b6138ce6130e9565b6137c4565b91908110156138e4575b60061b0190565b6138ec61190b565b6138dd565b60009291345b61020082016139068184611a97565b905086101561394e578561391d6139239285611a97565b906138d3565b908135908082116127e2576139458261394060206001960161175e565b613085565b039401936138f7565b509293508282116127e257816139406060613969930161175e565b80821161397d575b50506102086001600055565b613988910333613085565b3880613971565b9493929190946101a0840135936139a5856101ec565b60005b61020082016139b78184611a97565b9050821015613a1257906139ff876139d58361391d60019688611a97565b97602089358281809410613a05575b039901356139f1816101ec565b858060a01b031687896130f6565b016139a8565b613a0d611acc565b6139e4565b505050613a209495916130f6565b6001600055565b919492936101c081013593613a3b856101ec565b60005b6102008301613a4d8185611a97565b9050821015613a905790613a8a87613a6b8361391d60019689611a97565b602081013590613a7a826101ec565b3590858060a01b0316898d6130f6565b01613a3e565b505095613a20959391506130f6565b613aa7613c8b565b6002600055565b90815180825260208080930193019160005b828110613ace575050505090565b909192938260a082613ae36001948951610bec565b01950193929101613ac0565b91939290936040805193608091828601918652602090600082880152838188015285518093528160a088019601936000915b848310613b785750505050848403606086015250506001600160a01b039081169416927f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f3192918291613b739190613aae565b0390a3565b90919293949684836001928a518051613b9081610bda565b8252848060a01b038482015116848301528581015186830152606080910151908201520198019301919094939294613b21565b929094939160409182519460809182870191875260018060a01b0394856020921682890152838189015286518093528160a089019701936000915b848310613c47575050505050508282859493613b7393867f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31989603606087015216971695613aae565b90919293949784836001928b518051613c5f81610bda565b8252808401518c1684830152858101518683015260609081015190820152019901959493019190613bfe565b600160005403613c9757565b604051637fa8a98760e01b8152600490fd5b4210908115613ccf575b50613cbd57600190565b6040516337bf561360e11b8152600490fd5b905042101538613cb3565b4210908115613cf3575b50613cee57600190565b600090565b905042101538613ce4565b949392909415613d15575050505061020890613d5a565b60a49550613d21615cef565b60405163f486bc8760e01b81526001600160a01b0395861660048201529185166024830152909316604484015260648301526084820152fd5b3d1580613d8b575b613d695750565b604051632f8aeb3960e11b81526001600160a01b039091166004820152602490fd5b50803b15613d62565b6001600160a01b0392909183831690338214613ee857613dd290613db6613fa9565b61190160f01b6000526002526022526042600020906000602252565b90825194604095868114600014613e7e5750602084810151878601516000919060ff81901c601b0190613e2f906001600160ff1b03165b8b519384938a859094939260ff6060936080840197845216602083015260408201520152565b838052039060015afa15613e71575b6000511680613e58578551638baa579f60e01b8152600490fd5b90919293945003613e6857505050565b61020892613eef565b613e796130e9565b613e3e565b604103613eda57602084015186850151606086015160001a90601b82141580613ecf575b613eb55791600091613e2f602094613e09565b8851630f801e8560e11b815260ff83166004820152602490fd5b50601c821415613ea2565b505090916102089350613eef565b5050505050565b613f29610f6e91613f37613f3c9495604051938491630b135d3f60e11b988960208501526024840152604060448401526064830190610148565b03601f1981018452836104d9565b613f93565b613f7957600060203d14613f6e575b6001600160e01b03191603613f5c57565b604051632057875960e21b8152600490fd5b602081803e51613f4b565b613f81615cef565b604051634f7fb80d60e01b8152600490fd5b6000918291602082519201905afa6138556135d5565b467f000000000000000000000000000000000000000000000000000000000000000003613ff4577f000000000000000000000000000000000000000000000000000000000000000090565b60405160208101907f000000000000000000000000000000000000000000000000000000000000000082527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a081526140848161046d565b51902090565b91909161014081018051917f0000000000000000000000000000000000000000000000000000000000000000604051604083018051928351926020809501906000915b868684106141915750505050506040519160051b8220917f00000000000000000000000000000000000000000000000000000000000000009093606086019481865101906000915b8a831061416d5750505050508560051b6040512093601f1901978851907f00000000000000000000000000000000000000000000000000000000000000008a5282519383528451958552865261018089209852525252565b8380600192601f1981510180519089815260e0812087525201920192019190614115565b80600192601f1981510180519088815260c08120875252019201920191906140cd565b610630906141cd60608201515161014083015190615d6c565b80516001600160a01b03166000908152600260205260409020549061408a565b92916001906004811015614290575b118061427d575b8061426a575b614214575b50505050565b6040516303874c7760e21b6020820152602481018490523360448201526001600160a01b03909216606483015260848201526142619261425c9190613f378260a48101613f29565b615ab1565b3880808061420e565b50336001600160a01b0383161415614209565b50336001600160a01b0385161415614203565b614298610bc3565b6141fc565b90815180825260208080930193019160005b8281106142bd575050505090565b909192938260a0600192875180516142d481610bda565b82528084015185841b8690031684830152604080820151908301526060808201519083015260809081015190820152019501939291016142af565b90815180825260208080930193019160005b82811061432f575050505090565b909192938260c06001928751805161434681610bda565b8252848060a01b038085830151168584015260408083015190840152606080830151908401526080808301519084015260a0809201511690820152019501910192919092614321565b9060048210156119e85752565b9192610630936144db92845260018060a01b0316602084015260806040840152805160a060808501526101206143dc818601835160018060a01b03169052565b60208201516001600160a01b0316610140868101919091526144296144116040850151610160808a015261028089019061429d565b606085015188820361011f19016101808a015261430f565b9261443d60808201516101a089019061438f565b60a08101516101c088015260c08101516101e088015260e081015161020088015261010080820151610220890152928101516001600160a01b0316610240880152015161026086015260208301516001600160781b031660a086015260408301516001600160781b031660c086015260806144ca606085015193607f1994858983030160e08a0152610148565b930151918584030190850152610148565b906060818303910152613552565b92610630949261462892855260018060a01b0316602085015260806040850152805160a06080860152610120614529818701835160018060a01b03169052565b60208201516001600160a01b03166101408781019190915261457661455e6040850151610160808b01526102808a019061429d565b606085015189820361011f19016101808b015261430f565b9261458a60808201516101a08a019061438f565b60a08101516101c089015260c08101516101e089015260e0810151610200890152610100808201516102208a0152928101516001600160a01b0316610240890152015161026087015260208301516001600160781b031660a087015260408301516001600160781b031660c08701526080614617606085015193607f1994858a83030160e08b0152610148565b930151918684030190860152610148565b916060818403910152610c8e565b94909392600190614646816119c8565b1180614701575b806146ee575b61465e575050505050565b6146b894608081015151156000146146c257506040516303874c7760e21b6020820152602481018590523360448201526001600160a01b039093166064840152608483019190915261425c9190613f378260a48101613f29565b3880808080613ee8565b604051632bb1c66d60e21b602082015261425c94509250613f37908390613f299033886024850161439c565b50336001600160a01b0384161415614653565b50336001600160a01b038216141561464d565b95919493600190614724816119c8565b11806147e4575b806147d1575b61473e575b505050505050565b61479995608081015151156000146147a45750506040516303874c7760e21b6020820152602481018590523360448201526001600160a01b039093166064840152608483019190915261425c9190613f378260a48101613f29565b388080808080614736565b604051632bb1c66d60e21b602082015261425c95509350613f37918491613f2991903389602486016144e9565b50336001600160a01b0385161415614731565b50336001600160a01b038316141561472b565b9190614801612c2b565b508051158015614996575b6149845761481a8284615921565b926148258282614b4a565b93614830855161265b565b81519061483c82610bda565b61484582610bda565b61484e81610bda565b1480159061494b575b8015614938575b61492657846148e293608093610630966060809481928288019586518484510151106000146148f857506148c2926148b56148ac61489d602094612027565b5194838a519151015190612644565b9684519061204e565b515101519101519061204e565b510152818751015181525b5186519091015201516001600160a01b031690565b82516001600160a01b0390911660809190910152565b602091506148b56148ac61491e95614911604094612027565b5195510151895190612644565b5101526148cd565b6040516309cfb45560e01b8152600490fd5b506040855101516040820151141561485e565b508451602001516001600160a01b03166020820151614972906001600160a01b03166117e5565b6001600160a01b039091161415614857565b604051634c74edb760e11b8152600490fd5b5081511561480c565b60021115610be457565b6119f082610bda565b906149bb612c2b565b50805115614a9257600091825b8251811015614a8b576149db818461204e565b51518251811015614a79576121b160206149f8614a07938661204e565b5101516001600160781b031690565b614a13576001016149c8565b6001019250905b8215614a3257614a2c61063093612627565b91614cd1565b505050614a3d61051a565b6000815260006020820152600060408201526000606082015260006080820152614a65610527565b908152600060208201526000604082015290565b604051631a50ca5560e11b8152600490fd5b5090614a1a565b60405163375c24c160e01b815260006004820152602490fd5b91614ab4612c2b565b50815115614b3157600092835b8351811015614b2957614ad4818561204e565b51518251811015614a79576121b160206149f8614af1938661204e565b614afd57600101614ac1565b600101935090915b8315614b1d57614b1761063094612627565b91614e14565b50505050614a3d61051a565b509091614b05565b60405163375c24c160e01b815260016004820152602490fd5b90614b53612c2b565b92602082015192602084519401519360208083518310159260051b8401015151916040830151908151881015179660051b0101519260006060885195805187526020810151602088015260408101516040880152018051956080339101525261012082519260208901938452015192604088019384528751956001975b8151891081151615614cc1575060208860051b82010151976020895199015183518a1015998a614caf5760209060051b850101516020810151614c19575b505060010197614bd0565b90979199505196604088015190815181101580614c8557506001929160209160051b01015190606082015101976000606083015260208a01516020830151148a5183511416908851610120820151149088519051141616906040808b0151910151141615989038614c0e565b9996505050955050509450606091505b0152614c9d57565b604051637fda727960e01b8152600490fd5b50505050509493905060609150614c95565b9693505050945060609150614c95565b92919092614cdd612c2b565b9360208360051b82010151602081519101519460208085518410159360051b8601015151926040840151908151891015179760051b0101519360006060895196805188526020810151602089015260408101516040890152018051966080339101525261012083519360208a0194855201519360408901948552600189519701975b8151891081151615614cc1575060208860051b82010151976020895199015183518a1015998a614caf5760209060051b850101516020810151614da8575b505060010197614d5f565b90979199505196604088015190815181101580614c8557506001929160209160051b01015190606082015101976000606083015260208a01516020830151148a5183511416908851610120820151149088519051141616906040808b0151910151141615989038614d9d565b9291614e1e612c2b565b50614e27612c00565b9380519060208360051b8501015193602085519501519383861095861596614e7a575b505050505050614c9d5760405191614e61836104a3565b82523360208301526001600160a01b0316604082015290565b606091929394959897965060209060051b850101515101518051881097881598614ea8575b97959697614e4a565b60206001939260a09260051b01015180518952602081015160208a0152604081015160408a0152600060608201805160608c0152520151608088015201955b8151871015614fc5575060208660051b820101519560208751970151848810159788614fb85760209060051b850101516020810151614f2c575b505060010195614ee7565b516060015180519298509181101580614faa57509060209160051b010151600060608201805160608901510160608901525260408601516040820151146020870151602083015114168651825114169060a060808801519101511416159586614f96573880614f21565b5050505090915b9190388080808080614e9f565b959697505050505050614f9d565b5050505050509091614f9d565b93949550505050614f9d565b919060005b815181101561515557614fe9818361204e565b5180519085518210156151435760209161500a6121b1846149f8848b61204e565b1561513857615019908761204e565b51519160409283830151918301516150308161499f565b6150398161499f565b6150da5783018051518210156150c95790615054915161204e565b5191600383519361506485610bda565b849061507b848201916004835198148503906149a9565b606085015190525b11156150b9575090600192918161509e575b50505b01614fd6565b6150b2916080606083015192015191615d00565b3880615095565b51634a75b57b60e11b8152600490fd5b8351635fd9fc6760e11b8152600490fd5b92906060809401805151821015615127576003916150f8915161204e565b519384519461510686610bda565b859161511d858301926004845199148603906149a9565b8501519052615083565b82516330446bef60e11b8152600490fd5b505050600190615098565b6040516321a561b160e21b8152600490fd5b50509060005b815181101561523d5761516e818361204e565b516151866121b160208301516001600160781b031690565b156152345760608082510151519060005b8281106151ff5750505060408082510151519160005b8381106151c257505050506001905b0161515b565b6151e26151dc6151d683868651015161204e565b5161265b565b60031090565b6151ee576001016151ad565b825163a6cfc67360e01b8152600490fd5b6152136151dc6151d683858851015161204e565b61521f57600101615197565b60405160016202297360e61b03198152600490fd5b506001906151bc565b5050565b93929093848103615253575050505090565b9161526661526c9261527295969461215e565b9261215e565b90611aff565b0490565b93929093848103615288575050505090565b9161526c61529e6152aa9361527296979561215e565b9160001987019461215e565b611aff565b92919281811461523d57816152c4828661215e565b0493096152cd57565b60405163c63cf08960e01b8152600490fd5b906152e982610541565b6040906152f8825191826104d9565b8381528093615309601f1991610541565b019160005b83811061531b5750505050565b60209082516153298161046d565b6000815282600081830152600085830152606080808401526080830152600060a083015282860101520161530e565b6040519061536582610488565b6001825260203681840137565b6040519061537f826104a3565b600282526040366020840137565b9061539782610541565b60406153a5815192836104d9565b83825281936153b6601f1991610541565b0191600091825b8481106153cb575050505050565b60209082516153d981610488565b858152826060818301528286010152016153bd565b90815191600192838111156156ad57600061540882612813565b918582815b61565d575b50821115615650576154238261538d565b9061542d84612027565b51926154398487615c17565b615441615358565b9461544b86612027565b5261545584612027565b5152602094848661546586612027565b510152889489805b848110615556575050505083146155485761548790612813565b91615490615372565b9360005b8281106154be57505050610ed49495506154b76154b084612027565b519361203d565b51936156b8565b80826154cb8b938761204e565b51015180519060028210156154e3575b505001615494565b6154f66154ef8a61203d565b5160010190565b6154ff8a61203d565b528161550a8a612027565b51016155158a612027565b528360005b8381106155285750506154db565b81850161553f615538838661204e565b518c61204e565b5201849061551a565b505050509150610630611768565b615560818561204e565b5161556b818c615c17565b90600084815b8c81106155ba575b50501561558b575b5050018a9061546d565b61559485612027565b5261559f898961204e565b515282896155b0848b019a8a61204e565b5101523880615581565b6155c4818d61204e565b515185146155d457018590615571565b9150508b6155e2828c61204e565b510151908c825191846155f6898501612813565b948960005b8681106156255750505061561361561a93948661204e565b528c61204e565b510152838438615579565b8281939597965061563792945061204e565b51615642828861204e565b52018f9293918987926155fb565b5050509150610630611768565b85518110156156a85780600361567e61567785948a61204e565b515161265b565b61568781610bda565b14615694575b018161540d565b806156a2838701968861204e565b5261568d565b615412565b509150610630611768565b949390949291926156cc8151938403612c51565b936156d6836152df565b966156e2600094612813565b91845b8681106156f757505050505050509190565b615701818361204e565b51958a61570e838861204e565b51978061573c57505090615734826001809491019861572d828d61204e565b528a61204e565b505b016156e5565b9197600193926157cc91906080906157b190600019016001600160a01b0380615776615768848a61204e565b51516001600160a01b031690565b16156157d2575b50615788818c61204e565b5193888501615797838e61204e565b52604081510151906060916157b987846157b1878d61204e565b51015161204e565b52510151956157c787615d85565b61204e565b52615736565b61588b6020806157e2858f61204e565b51015151875182810151838a0151918901516001600160a01b0391821696928216938a939092615873928d92911661586361582561581f87612813565b96612813565b6040948501519098906001600160a01b031699615852615843610534565b6001600160a01b03909e168e52565b6001600160a01b03909116908c0152565b166001600160a01b031690880152565b60608601528401526001600160a01b031660a0830152565b615895828861204e565b526158a0818761204e565b503861577d565b959192939490948587146000146158c55750505061063093506152af565b929194846158db610630986158e19497866152af565b936152af565b90615241565b959192939490948587146000146159055750505061063093506152af565b929194846158db6106309861591b9497866152af565b90615276565b91909161592c612c00565b8151602080860151805191015192958282108015959193919290615956575b5050505050614c9d57565b60609192939496955060209060051b840101515101518051861095861596615981575b95949561594b565b9060209160051b0101519182518752602083015191602088019283526040840151916040890192835260a06060860195600087519760608d019889525201519560808a019687526001985b81518a1015615aa2575060208960051b820101519860208a519a0151848b10159a8b615a925760209060051b850101516020810151615a11575b5050600101986159cc565b51606001518051929b509181101580615a8157509060209160051b010151600060608201805189510189525284516040820151148651602083015114168b51825114169060a089519101511416159889615a6c573880615a06565b5050505050505050905b903880808080615979565b999a50505050505050505050615a76565b5050505050505050505090615a76565b97985050505050505050615a76565b15615afe57600060203d14615af3575b6001600160e01b031916633c78b38960e21b01615adb5750565b60249060405190633ed4053f60e21b82526004820152fd5b602081803e51615ac1565b602490615b09615cef565b60405190633ed4053f60e21b82526004820152fd5b906020810151615b72576001600160781b03806040830151169182615b47575b50505050600190565b60600151161115615b5a57808080615b3e565b602490604051906310fda3e160e01b82526004820152fd5b604051630694555d60e21b815260048101839052602490fd5b906020810151615b7257604001516001600160781b0316615bac5750600190565b6024906040519063ee9e0e6360e01b82526004820152fd5b906000906020810151615c0e576001600160781b03806040830151169182615bf1575b5050505050600190565b60600151161115615c0457808080615be7565b615b5a5750600090565b50905050600090565b90615c219161204e565b518051602080820151818401516080909301516040948501516001600160a01b039081169093528216601c5290821660085260601b6bffffffffffffffffffffffff191690821c6bffffffffffffffffffffffff161760009081522090565b615c88611f41565b50615cd2615ca4615c998380611922565b926020810190611a65565b615cbb60405194615cb486610452565b3690610717565b845260016020850152600160408501523691610823565b6060820152604051615ce3816104be565b60008152608082015290565b3d615cf657565b3d6000803e3d6000fd5b92909192906000915b8451831015615d4f57615d1c838661204e565b5190818111615d3b5760005260205260016040600020925b0191615d09565b906000526020526001604060002092615d34565b9150925003615d5a57565b6040516309bde33960e01b8152600490fd5b10615d7357565b604051632335530b60e11b8152600490fd5b15615d8c57565b60405163246cf94560e21b8152600490fd5b6102643560061b6102600161024435146102406102243514602060043514161615615dc557565b6040516339f3e3fd60e01b8152600490fdfea2646970667358221220c658fb668e86f75879bb958d34689da654cd9a6d4e3dd60b8cdf2e0eae9d213264736f6c634300080d0033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b60003560e01c806306fdde031461013f5780630dfa8f67146101365780632d0335ab1461012d5780633644e5151461012457806346423aa71461011b57806354fd4d5014610112578063627cdcb9146101095780637ceac2a314610100578063864eba38146100f757806395c37a41146100ee578063c65e79a0146100e5578063d92b6880146100dc578063e58dd01d146100d3578063ef3e0fd2146100ca5763f0f90af0146100c257600080fd5b61000e6114da565b5061000e611435565b5061000e61124f565b5061000e6111cc565b5061000e61112e565b5061000e611020565b5061000e610ed8565b5061000e610dd9565b5061000e6103ae565b5061000e610368565b5061000e6102d6565b5061000e6102b2565b5061000e610274565b5061000e61020a565b5061000e610199565b91908251928382526000905b848210610181575092806020939411610174575b601f01601f1916010190565b6000838284010152610168565b90602090818082850101519082860101520190610154565b503461000e57600036600319011261000e576101e86040516101ba81610488565b600d81526c21b7b739b4b232b930ba34b7b760991b6020820152604051918291602083526020830190610148565b0390f35b6001600160a01b0381160361000e57565b3590610208826101ec565b565b5060031960403682011261000e57600435906001600160401b03821161000e57604090823603011261000e5761026a6020916102546024359161024c836101ec565b600401615c80565b60405190610261826104be565b60008252612070565b6040519015158152f35b503461000e57602036600319011261000e57600435610292816101ec565b60018060a01b031660005260026020526020604060002054604051908152f35b503461000e57600036600319011261000e5760206102ce613fa9565b604051908152f35b503461000e57602036600319011261000e5760043560005260016020526040600020604051906103058261042a565b546101e8606060ff831615159283855260ff8160081c161515948560208201526001600160781b038260101c169182604083015260881c928391015260405194859485909493926060926080830196151583521515602083015260408201520152565b503461000e57600036600319011261000e576101e860405161038981610488565b600481526372632e3160e01b6020820152604051918291602083526020830190610148565b503461000e57600036600319011261000e576103c8613c8b565b3360005260026020526020604060002060018154018091556040518181527f7ab0fc7de8910a6100b24df423c3d0835534506dca9473d30c3e7df51241b2cf833392a2604051908152f35b50634e487b7160e01b600052604160045260246000fd5b608081019081106001600160401b0382111761044557604052565b61044d610413565b604052565b60a081019081106001600160401b0382111761044557604052565b60c081019081106001600160401b0382111761044557604052565b604081019081106001600160401b0382111761044557604052565b606081019081106001600160401b0382111761044557604052565b602081019081106001600160401b0382111761044557604052565b90601f801991011681019081106001600160401b0382111761044557604052565b6040519061016082018281106001600160401b0382111761044557604052565b6040519061020882610452565b60405190610208826104a3565b604051906102088261046d565b6020906001600160401b03811161055a575b60051b0190565b610562610413565b610553565b3590600682101561000e57565b92919261058082610541565b60409461058f865192836104d9565b819584835260208093019160a080960285019481861161000e57925b8584106105bb5750505050505050565b868483031261000e5784879184516105d281610452565b6105db87610567565b8152828701356105ea816101ec565b83820152858701358682015260608088013590820152608080880135908201528152019301926105ab565b9080601f8301121561000e5781602061063093359101610574565b90565b92919261063f82610541565b60409461064e865192836104d9565b819584835260208093019160c080960285019481861161000e57925b85841061067a5750505050505050565b868483031261000e5784879184516106918161046d565b61069a87610567565b8152828701356106a9816101ec565b838201528587013586820152606080880135908201526080808801359082015260a080880135906106d9826101ec565b82015281520193019261066a565b9080601f8301121561000e5781602061063093359101610633565b6004111561000e57565b359061020882610702565b9190916101608184031261000e5761072d6104fa565b92610737826101fd565b8452610745602083016101fd565b60208501526001600160401b0390604083013582811161000e578161076b918501610615565b6040860152606083013591821161000e576107879183016106e7565b60608401526107986080820161070c565b608084015260a081013560a084015260c081013560c084015260e081013560e084015261010080820135908401526101206107d48183016101fd565b908401526101408091013590830152565b35906001600160781b038216820361000e57565b6020906001600160401b038111610816575b601f01601f19160190565b61081e610413565b61080b565b92919261082f826107f9565b9161083d60405193846104d9565b82948184528183011161000e578281602093846000960137010152565b9080601f8301121561000e5781602061063093359101610823565b91909160a08184031261000e5761088a61051a565b926001600160401b03823581811161000e57826108a8918501610717565b85526108b6602084016107e5565b60208601526108c7604084016107e5565b6040860152606083013581811161000e57826108e491850161085a565b6060860152608083013590811161000e576108ff920161085a565b6080830152565b9080601f8301121561000e5781359061091e82610541565b9261092c60405194856104d9565b828452602092838086019160051b8301019280841161000e57848301915b84831061095a5750505050505090565b82356001600160401b03811161000e57869161097b84848094890101610875565b81520192019161094a565b81601f8201121561000e5780359161099d83610541565b926109ab60405194856104d9565b808452602092838086019260051b82010192831161000e578301905b8282106109d5575050505090565b813581529083019083016109c7565b9092916109f084610541565b91604094610a00865194856104d9565b839581855260208095019160051b83019380851161000e5783925b858410610a2b5750505050505050565b6001600160401b0390843582811161000e5786019060a08285031261000e578451610a5581610452565b8235815289830135600281101561000e578a82015285830135868201526060808401359082015260808084013594851161000e57610a97868c96879601610986565b90820152815201930192610a1b565b9080601f8301121561000e57816020610630933591016109e4565b81601f8201121561000e57803590610ad882610541565b92604092610ae8845195866104d9565b808552602091828087019260061b8501019381851161000e578301915b848310610b155750505050505090565b858383031261000e578386918251610b2c81610488565b853581528286013583820152815201920191610b05565b9080601f8301121561000e57813590610b5b82610541565b92610b6960405194856104d9565b828452602092838086019160051b8301019280841161000e57848301915b848310610b975750505050505090565b82356001600160401b03811161000e578691610bb884848094890101610ac1565b815201920191610b87565b50634e487b7160e01b600052602160045260246000fd5b60061115610be457565b610208610bc3565b6080908051610bfa81610bda565b83528160018060a01b03918260208201511660208601526040810151604086015260608101516060860152015116910152565b90815180825260208080930193019160005b828110610c4d575050505090565b909192938260e06001928751610c64828251610bec565b6040858060a01b039182868201511660a085015201511660c0820152019501910192919092610c3f565b90815180825260208080930193019160005b828110610cae575050505090565b835185529381019392810192600101610ca0565b908082519081815260208091019281808460051b8301019501936000915b848310610cf05750505050505090565b9091929394958480600192601f19858203018652895190848060a01b039182815116825282848201511684830152604083818301511690830152610d59610d466060808401519060c08091870152850190610c8e565b6080808401519085830390860152610c8e565b9260a080920151169101529801930193019194939290610ce0565b91939290936060830194606084528051809652608084019560208092019060005b818110610dc35750505094610db591610630959685830390860152610c2d565b916040818403910152610cc2565b8251151589529783019791830191600101610d95565b5060a036600319011261000e576001600160401b0360043581811161000e57610e06903690600401610906565b9060243581811161000e57610e1f903690600401610aa6565b9160443582811161000e57610e38903690600401610b43565b9260643592831161000e576101e893610e58610e6b943690600401610b43565b9160843593610e66856101ec565b61177b565b60409391935193849384610d74565b9181601f8401121561000e578235916001600160401b03831161000e576020808501948460051b01011161000e57565b602060031982011261000e57600435906001600160401b03821161000e57610ed491600401610e7a565b9091565b503461000e57610ee736610eaa565b610eef613c8b565b60005b818110610f055760405160018152602090f35b80610f1360019284866119f3565b610f1d8180611922565b90610f278261175e565b91610f3a610f353683610717565b6141b4565b91610f72610f6e610f5d610f58866000526001602052604060002090565b611a23565b610f678187615b1e565b5051151590565b1590565b610f81575b5050505001610ef2565b610ff7611014917ffde361574a066b44b3b5fe98a87108b7565e327327954c4faeea56a4e6491a0a93610fcd610fc6610fbf60209485810190611a65565b3691610823565b8789613d94565b610ff1610fe4876000526001602052604060002090565b805460ff19166001179055565b0161175e565b604051918291888060a01b03809116961694829190602083019252565b0390a338808080610f77565b503461000e57602036600319011261000e576004356001600160401b03811161000e57611051903690600401610717565b80516001600160a01b031660208201519091906001600160a01b0316906040810151606082019081516080840151611088816119c8565b60a085015160c086015160e08701519161010093848901519561012097888b01516110b89060018060a01b031690565b9951519b6110c46104fa565b6001600160a01b039e8f1681529d1660208e015260408d015260608c01526110ef9060808c016119dc565b60a08a015260c089015260e08801528601526001600160a01b0390911690840152610140918284015201516111239161408a565b604051908152602090f35b5060031960603682011261000e57600435906001600160401b039081831161000e5760a090833603011261000e5760243590811161000e576020916111a161117d61026a933690600401610e7a565b91906111996044359461118f866101ec565b3690600401610875565b9236916109e4565b90612070565b90916111be61063093604084526040840190610c2d565b916020818403910152610cc2565b50606036600319011261000e576001600160401b0360043581811161000e576111f9903690600401610906565b9060243581811161000e57611212903690600401610aa6565b60443591821161000e5761123f9261123161123a933690600401610e7a565b93909282612845565b612d0f565b906101e8604051928392836111a7565b503461000e5761125e36610eaa565b611266613c8b565b60005b81811061127c5760405160018152602090f35b611287818385611938565b6112908161175e565b60209061129e82840161175e565b6001600160a01b03828116939092903385141580611429575b611417576040956112ca8188018261195e565b606091828401926112db8486611993565b60809291908d6112ec8986016119d2565b95610120978d898c016112fe9061175e565b9a611309908d611993565b9d90506113146104fa565b6001600160a01b03909f168f528e6001600160a01b03909216910152369061133b92610574565b908b0152369061134a92610633565b9088015286019061135a916119dc565b60a0838101359086015260c0808401359086015260e0808401359086015261010080840135908601526001600160a01b0390911690840152610140918284015201356113a59161408a565b936113ba856000526001602052604060002090565b805460ff191690556113d6856000526001602052604060002090565b805461ff0019166101001790555193845216917f6bacc01dbe442496068f7d234edd811f1a5f833243e0aec824f86ab861f3c90d90602090a3600101611269565b60405163203b1cdd60e21b8152600490fd5b508383163314156112b7565b50604036600319011261000e576001600160401b0360043581811161000e57611462903690600401610e7a565b9160243590811161000e5761147b903690600401610e7a565b9161148584611fd7565b9360005b8181106114a85750505061123f9261123a6114a2611768565b82612845565b806114be6114b960019385876119f3565b615c80565b6114c8828961204e565b526114d3818861204e565b5001611489565b5060031960203682011261000e57600435906001600160401b03821161000e576102408260040191833603011261000e5761012435918260021c6001811190341582036117425761155c6003821192600283149687600285116001198601020191600183018602811560011b8601039260038760a00260240135931689611b0b565b6115686064840161175e565b9160051b6101c401359461157b82610bda565b816115c9575050906115b66115bd9460449361159960a4850161175e565b60e48501359160c48601359133916001600160a01b03169061331b565b01356138f1565b60405160018152602090f35b6115d282610bda565b60018203611615575050906115b6611610946044936115f360a4850161175e565b60e48501359160c48601359133916001600160a01b03169061343a565b6115bd565b61162182949394610bda565b15611670575061165b6116109461163a60a4840161175e565b6001600160a01b039094169360e48401359060c4850135903390879061331b565b60446116668461175e565b9101359133613a27565b61167981610bda565b600381036116b6575061165b6116109461169560a4840161175e565b6001600160a01b039094169360e48401359060c4850135903390879061343a565b806116c2600492610bda565b03611711576116f8611610946116d78561175e565b6001600160a01b03909416936044840135906024850135908690339061331b565b60e461170660a4830161175e565b91013591339061398f565b6116f8611610946117218561175e565b6001600160a01b03909416936044840135906024850135908690339061343a565b604051630a61be9f60e41b8152346004820152602490fd5b0390fd5b35610630816101ec565b604051611774816104be565b6000815290565b9061178b90959394929582612a75565b6117a061179b8651865190611aff565b612c51565b91600093845b8751861015611833576117c36117bc878a61204e565b51856149b2565b8051608001516001600160a01b031660208201516117f1906001600160a01b03165b6001600160a01b031690565b6001600160a01b039091160361181057506001809101955b01946117a6565b9561182d8297600193830390611826828a61204e565b528761204e565b50611809565b94509495929190956000945b81518610156118c85761185d88611856888561204e565b5185614aab565b8051608001516001600160a01b03166020820151611883906001600160a01b03166117e5565b6001600160a01b03909116036118a257506001809101955b019461183f565b956118c282976001938851840103906118bb828961204e565b528661204e565b5061189b565b935050939450915080611900575b508051156118ee576118e791612dd5565b9192909190565b60405163d5da9a1b60e01b8152600490fd5b8151038152386118d6565b50634e487b7160e01b600052603260045260246000fd5b90359061015e198136030182121561000e570190565b909161063092811015611951575b60051b810190611922565b61195961190b565b611946565b903590601e198136030182121561000e57018035906001600160401b03821161000e576020019160a082023603831361000e57565b903590601e198136030182121561000e57018035906001600160401b03821161000e576020019160c082023603831361000e57565b60041115610be457565b3561063081610702565b60048210156119e85752565b6119f0610bc3565b52565b9190811015611a16575b60051b81013590603e198136030182121561000e570190565b611a1e61190b565b6119fd565b90604051611a308161042a565b606081935460ff81161515835260ff8160081c16151560208401526001600160781b038160101c16604084015260881c910152565b903590601e198136030182121561000e57018035906001600160401b03821161000e5760200191813603831361000e57565b903590601e198136030182121561000e57018035906001600160401b03821161000e57602001918160061b3603831361000e57565b50634e487b7160e01b600052601160045260246000fd5b6001906001198111611af3570190565b611afb611acc565b0190565b81198111611af3570190565b959190611b16613a9f565b611b2a610140880135610120890135613ca9565b50611b33615d9e565b611b5a611b4e611b476102008a018a611a97565b9050611ae3565b6101e089013590615d6c565b7f00000000000000000000000000000000000000000000000000000000000000006080528160a0526060602460c037604060646101203760e06080908120610160526001610264359081016102a060059290921b918201526102c081019384526024906102e00137610160928460a0528560c052600060e05260005b839461020435821015611c335790604060a0600193602090818560061b6102840161010037838560061b6102840161012037019660e0608020885201968888528960c08201526101008360061b6102840191013701939293611bd6565b5090929350969590966001610204350160051b610160206060525b8361026435821015611c815790604060a060019301958787528860c08201526101008360061b6102840191013701611c4e565b505093509490506102089391507f00000000000000000000000000000000000000000000000000000000000000006080528260a052606060c460c03760206101046101203760c0608020600052602060002060e05260016102643560051b610200015261022092836102643560051b0152606060c46102406102643560051b0137611e2c610fbf60843593611d288560018060a01b03166000526002602052604060002090565b547f00000000000000000000000000000000000000000000000000000000000000006080526040608460a03760605161010052846101205260a0610144610140376101e0526101809485608020956102643560051b0190868252336101a06102643560051b015260806101c06102643560051b01526101206101e06102643560051b01527f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f3160a4359260a061026435026101e00190a36000606052611e2360608201611e1e611df68261175e565b96611e036080860161175e565b6001600160a01b03989091908916906101608701358b6141ed565b61175e565b95810190611a65565b921690611f1b916102089382600052600160205282611e94610f6e604060002060405190611e598261042a565b5460ff81161515825260ff8160081c16151560208301526001600160781b038160101c16604083015260881c6060820152610f678185615b8b565b611f30575b611eb39250610fe491506000526001602052604060002090565b611ed5611eca826000526001602052604060002090565b805461ff0019169055565b611f0b611eec826000526001602052604060002090565b805470ffffffffffffffffffffffffffffff0000191662010000179055565b6000526001602052604060002090565b80546001600160881b0316600160881b179055565b611f3992613d94565b388082611e99565b60405190611f4e82610452565b60405160808361016083016001600160401b03811184821017611fca575b6040526000808452806020850152606093846040820152848082015281848201528160a08201528160c08201528160e08201528161010082015281610120820152816101408201528252806020830152604082015282808201520152565b611fd2610413565b611f6c565b90611fe182610541565b611fee60405191826104d9565b8281528092611fff601f1991610541565b019060005b82811061201057505050565b60209061201b611f41565b82828501015201612004565b602090805115612035570190565b611afb61190b565b604090805160011015612035570190565b6020918151811015612063575b60051b010190565b61206b61190b565b61205b565b91909161207b613c8b565b60026000556120898161217d565b90936040519461209886610488565b6001865260005b6020808210156120c157906020916120b5611f41565b90828a0101520161209f565b505090919361211393956120f3612142986120f893835115612151575b60208401526120ec83612027565b5082614fd1565b612027565b51516101208101519094906001600160a01b03169185612665565b80516001600160a01b03165b60208201519092906001600160a01b031660606040840151930151933392613bc3565b61214c6001600055565b600190565b61215961190b565b6120de565b8060001904821181151516612171570290565b612179611acc565b0290565b805191612196610f6e60a085015160c086015190613ca9565b612488576121bd6121b160208401516001600160781b031690565b6001600160781b031690565b926121d56121b160408501516001600160781b031690565b938481118015612480575b61246e5784811080612456575b612444576121fa826141b4565b9161223560e08201516080830151612211816119c8565b83516001600160a01b031660208501519091906001600160a01b031692878a614636565b61224c610f58846000526001602052604060002090565b9461225a610f6e8786615b1e565b612434578361226c610f6e8851151590565b612410575b5050506122a26121b160606122936121b160408901516001600160781b031690565b9601516001600160781b031690565b9485156123b9576001810361238157505083925b836122c18683611aff565b11612377575b84612342612372926122e6610fe4866000526001602052604060002090565b6122fd611eca866000526001602052604060002090565b6001600160781b03928391011661231e856000526001602052604060002090565b9062010000600160881b0382549160101b169062010000600160881b031916179055565b8416612358836000526001602052604060002090565b906001600160881b0382549181199060881b169116179055565b929190565b80840394506122c7565b939094848103612392575b506122b6565b6123ac816123a6876123b29599989961215e565b9661215e565b9561215e565b923861238c565b935093506123d4610fe4826000526001602052604060002090565b6123eb611eca826000526001602052604060002090565b6123726001600160781b0361234281871661231e856000526001602052604060002090565b915161242c92906060906001600160a01b031692015191613d94565b388083612271565b5050509150915090600090600090565b60405163a11b63ff60e01b8152600490fd5b5060016080830151612467816119c8565b16156121ed565b604051632d02959960e11b8152600490fd5b5080156121e0565b600092508291508190565b90918151926124ae610f6e60a086015160c087015190613ca9565b612561576124c96121b160208501516001600160781b031690565b6124e06121b160408601516001600160781b031690565b948582118015612559575b61246e5785821080612541575b61244457612235612508826141b4565b9360e0830151608084015161251c816119c8565b84516001600160a01b0316602086015190929088906001600160a01b0316948b614714565b5060016080820151612552816119c8565b16156124f8565b5081156124eb565b50600092508291508190565b9091815192612588610f6e60a086015160c087015190613cda565b612561576125a36121b160208501516001600160781b031690565b6125ba6121b160408601516001600160781b031690565b94858211801561261f575b61246e5785821080612607575b612444576125e2612508826141b4565b6125f9610f58846000526001602052604060002090565b9461225a610f6e8786615bc4565b5060016080820151612618816119c8565b16156125d2565b5081156125c5565b60018110612637575b6000190190565b61263f611acc565b612630565b81811061264f570390565b612657611acc565b0390565b5161063081610bda565b91909493929460c08301519360a09161268e61268684870197885190612644565b965142612644565b956126998782612644565b349460005b6040808a0151805183101561274757898e92886126d98f94896126c2898d9361204e565b5196606088019687519560808a01968751906158a7565b80935233905282516126ea81610bda565b6126f381610bda565b1561271c575b50508a51600193926127169290916001600160a01b031690612f8e565b0161269e565b90925089839a929a11612737575003968c90816127166126f9565b51631a783b8d60e01b8152600490fd5b5050509397909192949596995060005b6060808c015180518310156127f45790898861279088888f9661277b898b9261204e565b519687019586519560808901968751906158e7565b80925288830151905281516127a481610bda565b6127ad81610bda565b156127c9575b50600192916127c3913390612f8e565b01612757565b90988093925081116127e25790910396899060016127b3565b604051631a783b8d60e01b8152600490fd5b50505050505050509293505050806128095750565b6102089033613085565b9061281d82610541565b61282a60405191826104d9565b828152809261283b601f1991610541565b0190602036910137565b9061284e613a9f565b81519161285a83612813565b91600090818452815b8581106128e757506128759083614fd1565b8381106128825750505050565b8061288f6001928561204e565b51156128e2576128dc6128a2828561204e565b51516128ae838761204e565b5181519091906001600160a01b031660208201516001600160a01b0316906060604084015193015193613aef565b01612875565b6128dc565b6128f1818561204e565b516128fc8682612493565b926001929192938486018a5260c082519360a09485810151928391015103914203808303918d8c8915612a5d57508a6129349161204e565b5284516040015188828d825b6129e5575b5050505060608095510151888c905b61296d575b505050505050505050506001905b01612863565b81518110156129e05789818a8a8a8a6129c38b8b8b61298d8a9b8d61204e565b519560808701986129a08a5188836152af565b918801968751908b5182146000146129d0575050508086525b8089528551615276565b9052015190520190612954565b6129d9926152af565b86526129b9565b612959565b878b88888751851015612a545786956060612a3994612a04888c61204e565b51906080820190612a1782518a836152af565b938493019889519083518214600014612a44575050508188525b528551615241565b905201839082612940565b612a4d926152af565b8852612a31565b50505050612945565b98505050505050506001949350602091500152612967565b90612a7e613a9f565b815191612a8a83612813565b91600090818452815b858110612afd5750612aa59083614fd1565b838110612ab25750505050565b80612abf6001928561204e565b5115612af857612af2612ad2828561204e565b5151612ade838761204e565b5181519091906001600160a01b031661211f565b01612aa5565b612af2565b612b07818561204e565b51612b12868261256d565b926001929192938486018a5260c082519360a09485810151928391015103914203808303918d8c8915612be857508a612b4a9161204e565b5284516040015188828d825b612bb5575b5050505060608095510151888c905b612b83575b505050505050505050506001905b01612a93565b8151811015612bb05789818a8a8a8a612ba38b8b8b61298d8a9b8d61204e565b9052015190520190612b6a565b612b6f565b878b88888751851015612bdf5786956060612bd494612a04888c61204e565b905201839082612b56565b50505050612b5b565b98505050505050506001949350602091500152612b7d565b60405190612c0d82610452565b60006080838281528260208201528260408201528260608201520152565b60405190612c38826104a3565b6000604083612c45612c00565b81528260208201520152565b90612c5b82610541565b612c6860405191826104d9565b8281528092612c79601f1991610541565b019060005b828110612c8a57505050565b602090612c95612c2b565b82828501015201612c7e565b60408136031261000e5760408051916001600160401b0391830182811184821017612d02575b604052803582811161000e57612ce09036908301610ac1565b8352602081013591821161000e57612cfa91369101610ac1565b602082015290565b612d0a610413565b612cc7565b929192612d1b84612c51565b9160009081955b808710612d4f575050612d3d93945080612d44575b50612dd5565b9291509190565b825103825238612d37565b9091612d64612d5f8884866119f3565b612ca1565b612d76815160208093015190876147f7565b8051608001519181015190916001600160a01b0390811691612d9891166117e5565b6001600160a01b0390911603612db957506001809101965b01959190612d22565b96612dcf8298600193830390611826828a61204e565b50612db0565b908151612de181612813565b926000905b828210612ed757505050612df9906153ee565b349360005b8351811015612e8757612e11818561204e565b518051908151612e2081610bda565b612e2981610bda565b15612e69575b602081015160019392612e63929091612e5d906040906001600160a01b03169201516001600160a01b031690565b91612f8e565b01612dfe565b9691906060810190838251116127e257905190920396909190612e2f565b50909260005b8451811015612eb25780612eac612ea66001938861204e565b5161364b565b01612e8d565b5090919380612ec7575b506123726001600055565b612ed19033613085565b38612ebc565b91949093612ee5858461204e565b5193612efe6121b160208701516001600160781b031690565b15612f7f57612f16612f10878461204e565b60019052565b606080955101519660005b8851811015612f6c5786612f35828b61204e565b51015180612f465750600101612f21565b6040516314bea84160e31b8152600481018a905260248101929092526044820152606490fd5b50939296509350936001905b0190612de6565b93509360019095929195612f78565b91908251612f9b81610bda565b612fa481610bda565b612fc75750506080810151606090910151610208916001600160a01b0316613085565b60018351612fd481610bda565b612fdd81610bda565b0361300c57602083015160808401516060909401516102089490926001600160a01b03918216929091166130f6565b6002835161301981610bda565b61302281610bda565b036130565760208301516080840151604085015160609095015161020895909390926001600160a01b03928316921661331b565b60208301516080840151604085015160609095015161020895909390926001600160a01b03928316921661343a565b9061308f81615d85565b600080808084865af1156130a1575050565b604492506130ad615cef565b60405163470c7c1d60e01b81526001600160a01b0390921660048301526024820152fd5b9081602091031261000e5751801515810361000e5790565b506040513d6000823e3d90fd5b909361310184615d85565b6001600160a01b039081168061311d5750509261020893613256565b9193929160010361321b57604051630aed65f560e11b81526001600160a01b0385811660048301528681166024830152831660448201526064810184905290602090829060849082906000907f0000000000000000000000000000000000000000000000000000000000000000165af190811561320e575b6000916131e0575b50156131a95750505050565b604051639889192360e01b81526001600160a01b039384166004820152938316602485015290911660448301526064820152608490fd5b613201915060203d8111613207575b6131f981836104d9565b8101906130d1565b3861319d565b503d6131ef565b6132166130e9565b613195565b60405162461bcd60e51b8152602060048201526013602482015272139bdd081e595d081a5b5c1b195b595b9d1959606a1b6044820152606490fd5b9092604051926000946323b872dd60e01b865280600452816024528260445260208660648180885af1803d15601f3d1160018a51141617163d15158116156132a7575b505050505050604052606052565b80863b1515166132995787959650156132ce57632f8aeb3960e11b85526004869052602485fd5b156132ee5760a494639889192360e01b8552600452602452604452606452fd5b3d6133125760a49463f486bc8760e01b855260045260245260445281606452608452fd5b833d81803e3d90fd5b92909493919360018303613428576001600160a01b0316806133bc5750823b156133a757604051936000956323b872dd60e01b8752806004528160245282604452868060648180895af115613377575050505050604052606052565b869495503d61339e5760a49563f486bc8760e01b8652600452602452604452606452608452fd5b843d81803e3d90fd5b82632f8aeb3960e11b60005260045260246000fd5b600190959193959492941460001461321b576040516323b872dd60e01b60208201526001600160a01b038083166024830152831660448201526064810184905261020895906134239061341c81608481015b03601f1981018352826104d9565b828461376f565b613cfe565b60405163efcc00b160e01b8152600490fd5b909492919261344885615d85565b6001600160a01b0316806134ec5750803b156134d857604051936080519260a05194600097637921219560e11b89528060045281602452826044528360645260a06084528860a452888060c48180895af1156134b157505050505060805260a052604052606052565b889495503d61339e5760a49563f486bc8760e01b8652600452602452604452606452608452fd5b632f8aeb3960e11b60005260045260246000fd5b90949192919060010361321b57604051637921219560e11b60208201526001600160a01b03808316602483015283166044820152606481018490526084810185905260a060a4820152600060c482015261020895906134239061341c8160e4810161340e565b6060519081815260208091019160809160005b828110613573575050505090565b835185529381019392810192600101613565565b926135b690602095926135c49460018060a01b038092168752168686015260a0604086015260a0850190610c8e565b908382036060850152610c8e565b906080818303910152600081520190565b3d15613600573d906135e6826107f9565b916135f460405193846104d9565b82523d6000602084013e565b606090565b6001600160a01b0391821681529181166020830152909116604082015260a06060820181905261063093919261363d91840190610c8e565b916080818403910152610c8e565b60a081015181516020830151604084015160608501516080909501516001600160a01b03938416959284169490939182169116806136f657506000806040516020810190631759616b60e11b82526136ad8161340e8989898d60248601613587565b519082895af16136bb6135d5565b505b156136cf575050505061020890613d5a565b61175a9395506136dd615cef565b6040516357e222f160e11b815295869560048701613605565b60010361321b57604051631759616b60e11b602082015261372c906137258161340e8787878b60248601613587565b868661376f565b6136bd565b9081602091031261000e5751610630816101ec565b6001600160a01b0390911681526000602082015260606040820181905261063092910190610148565b60405163c455279160e01b81526001600160a01b03918216600482015260209392909184836024817f000000000000000000000000000000000000000000000000000000000000000085165afa9283156138c6575b6000936138a7575b50604051635c60da1b60e01b81529085826004818785165afa91821561389a575b60009261386b575b50807f000000000000000000000000000000000000000000000000000000000000000016911603613859576000809493613849829561340e604051938492830196633f801f9160e01b885260248401613746565b51925af16138556135d5565b5090565b60405163dcd488e360e01b8152600490fd5b61388c919250863d8811613893575b61388481836104d9565b810190613731565b90386137f5565b503d61387a565b6138a26130e9565b6137ed565b6138bf919350853d87116138935761388481836104d9565b91386137cc565b6138ce6130e9565b6137c4565b91908110156138e4575b60061b0190565b6138ec61190b565b6138dd565b60009291345b61020082016139068184611a97565b905086101561394e578561391d6139239285611a97565b906138d3565b908135908082116127e2576139458261394060206001960161175e565b613085565b039401936138f7565b509293508282116127e257816139406060613969930161175e565b80821161397d575b50506102086001600055565b613988910333613085565b3880613971565b9493929190946101a0840135936139a5856101ec565b60005b61020082016139b78184611a97565b9050821015613a1257906139ff876139d58361391d60019688611a97565b97602089358281809410613a05575b039901356139f1816101ec565b858060a01b031687896130f6565b016139a8565b613a0d611acc565b6139e4565b505050613a209495916130f6565b6001600055565b919492936101c081013593613a3b856101ec565b60005b6102008301613a4d8185611a97565b9050821015613a905790613a8a87613a6b8361391d60019689611a97565b602081013590613a7a826101ec565b3590858060a01b0316898d6130f6565b01613a3e565b505095613a20959391506130f6565b613aa7613c8b565b6002600055565b90815180825260208080930193019160005b828110613ace575050505090565b909192938260a082613ae36001948951610bec565b01950193929101613ac0565b91939290936040805193608091828601918652602090600082880152838188015285518093528160a088019601936000915b848310613b785750505050848403606086015250506001600160a01b039081169416927f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f3192918291613b739190613aae565b0390a3565b90919293949684836001928a518051613b9081610bda565b8252848060a01b038482015116848301528581015186830152606080910151908201520198019301919094939294613b21565b929094939160409182519460809182870191875260018060a01b0394856020921682890152838189015286518093528160a089019701936000915b848310613c47575050505050508282859493613b7393867f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31989603606087015216971695613aae565b90919293949784836001928b518051613c5f81610bda565b8252808401518c1684830152858101518683015260609081015190820152019901959493019190613bfe565b600160005403613c9757565b604051637fa8a98760e01b8152600490fd5b4210908115613ccf575b50613cbd57600190565b6040516337bf561360e11b8152600490fd5b905042101538613cb3565b4210908115613cf3575b50613cee57600190565b600090565b905042101538613ce4565b949392909415613d15575050505061020890613d5a565b60a49550613d21615cef565b60405163f486bc8760e01b81526001600160a01b0395861660048201529185166024830152909316604484015260648301526084820152fd5b3d1580613d8b575b613d695750565b604051632f8aeb3960e11b81526001600160a01b039091166004820152602490fd5b50803b15613d62565b6001600160a01b0392909183831690338214613ee857613dd290613db6613fa9565b61190160f01b6000526002526022526042600020906000602252565b90825194604095868114600014613e7e5750602084810151878601516000919060ff81901c601b0190613e2f906001600160ff1b03165b8b519384938a859094939260ff6060936080840197845216602083015260408201520152565b838052039060015afa15613e71575b6000511680613e58578551638baa579f60e01b8152600490fd5b90919293945003613e6857505050565b61020892613eef565b613e796130e9565b613e3e565b604103613eda57602084015186850151606086015160001a90601b82141580613ecf575b613eb55791600091613e2f602094613e09565b8851630f801e8560e11b815260ff83166004820152602490fd5b50601c821415613ea2565b505090916102089350613eef565b5050505050565b613f29610f6e91613f37613f3c9495604051938491630b135d3f60e11b988960208501526024840152604060448401526064830190610148565b03601f1981018452836104d9565b613f93565b613f7957600060203d14613f6e575b6001600160e01b03191603613f5c57565b604051632057875960e21b8152600490fd5b602081803e51613f4b565b613f81615cef565b604051634f7fb80d60e01b8152600490fd5b6000918291602082519201905afa6138556135d5565b467f000000000000000000000000000000000000000000000000000000000000000003613ff4577f000000000000000000000000000000000000000000000000000000000000000090565b60405160208101907f000000000000000000000000000000000000000000000000000000000000000082527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a081526140848161046d565b51902090565b91909161014081018051917f0000000000000000000000000000000000000000000000000000000000000000604051604083018051928351926020809501906000915b868684106141915750505050506040519160051b8220917f00000000000000000000000000000000000000000000000000000000000000009093606086019481865101906000915b8a831061416d5750505050508560051b6040512093601f1901978851907f00000000000000000000000000000000000000000000000000000000000000008a5282519383528451958552865261018089209852525252565b8380600192601f1981510180519089815260e0812087525201920192019190614115565b80600192601f1981510180519088815260c08120875252019201920191906140cd565b610630906141cd60608201515161014083015190615d6c565b80516001600160a01b03166000908152600260205260409020549061408a565b92916001906004811015614290575b118061427d575b8061426a575b614214575b50505050565b6040516303874c7760e21b6020820152602481018490523360448201526001600160a01b03909216606483015260848201526142619261425c9190613f378260a48101613f29565b615ab1565b3880808061420e565b50336001600160a01b0383161415614209565b50336001600160a01b0385161415614203565b614298610bc3565b6141fc565b90815180825260208080930193019160005b8281106142bd575050505090565b909192938260a0600192875180516142d481610bda565b82528084015185841b8690031684830152604080820151908301526060808201519083015260809081015190820152019501939291016142af565b90815180825260208080930193019160005b82811061432f575050505090565b909192938260c06001928751805161434681610bda565b8252848060a01b038085830151168584015260408083015190840152606080830151908401526080808301519084015260a0809201511690820152019501910192919092614321565b9060048210156119e85752565b9192610630936144db92845260018060a01b0316602084015260806040840152805160a060808501526101206143dc818601835160018060a01b03169052565b60208201516001600160a01b0316610140868101919091526144296144116040850151610160808a015261028089019061429d565b606085015188820361011f19016101808a015261430f565b9261443d60808201516101a089019061438f565b60a08101516101c088015260c08101516101e088015260e081015161020088015261010080820151610220890152928101516001600160a01b0316610240880152015161026086015260208301516001600160781b031660a086015260408301516001600160781b031660c086015260806144ca606085015193607f1994858983030160e08a0152610148565b930151918584030190850152610148565b906060818303910152613552565b92610630949261462892855260018060a01b0316602085015260806040850152805160a06080860152610120614529818701835160018060a01b03169052565b60208201516001600160a01b03166101408781019190915261457661455e6040850151610160808b01526102808a019061429d565b606085015189820361011f19016101808b015261430f565b9261458a60808201516101a08a019061438f565b60a08101516101c089015260c08101516101e089015260e0810151610200890152610100808201516102208a0152928101516001600160a01b0316610240890152015161026087015260208301516001600160781b031660a087015260408301516001600160781b031660c08701526080614617606085015193607f1994858a83030160e08b0152610148565b930151918684030190860152610148565b916060818403910152610c8e565b94909392600190614646816119c8565b1180614701575b806146ee575b61465e575050505050565b6146b894608081015151156000146146c257506040516303874c7760e21b6020820152602481018590523360448201526001600160a01b039093166064840152608483019190915261425c9190613f378260a48101613f29565b3880808080613ee8565b604051632bb1c66d60e21b602082015261425c94509250613f37908390613f299033886024850161439c565b50336001600160a01b0384161415614653565b50336001600160a01b038216141561464d565b95919493600190614724816119c8565b11806147e4575b806147d1575b61473e575b505050505050565b61479995608081015151156000146147a45750506040516303874c7760e21b6020820152602481018590523360448201526001600160a01b039093166064840152608483019190915261425c9190613f378260a48101613f29565b388080808080614736565b604051632bb1c66d60e21b602082015261425c95509350613f37918491613f2991903389602486016144e9565b50336001600160a01b0385161415614731565b50336001600160a01b038316141561472b565b9190614801612c2b565b508051158015614996575b6149845761481a8284615921565b926148258282614b4a565b93614830855161265b565b81519061483c82610bda565b61484582610bda565b61484e81610bda565b1480159061494b575b8015614938575b61492657846148e293608093610630966060809481928288019586518484510151106000146148f857506148c2926148b56148ac61489d602094612027565b5194838a519151015190612644565b9684519061204e565b515101519101519061204e565b510152818751015181525b5186519091015201516001600160a01b031690565b82516001600160a01b0390911660809190910152565b602091506148b56148ac61491e95614911604094612027565b5195510151895190612644565b5101526148cd565b6040516309cfb45560e01b8152600490fd5b506040855101516040820151141561485e565b508451602001516001600160a01b03166020820151614972906001600160a01b03166117e5565b6001600160a01b039091161415614857565b604051634c74edb760e11b8152600490fd5b5081511561480c565b60021115610be457565b6119f082610bda565b906149bb612c2b565b50805115614a9257600091825b8251811015614a8b576149db818461204e565b51518251811015614a79576121b160206149f8614a07938661204e565b5101516001600160781b031690565b614a13576001016149c8565b6001019250905b8215614a3257614a2c61063093612627565b91614cd1565b505050614a3d61051a565b6000815260006020820152600060408201526000606082015260006080820152614a65610527565b908152600060208201526000604082015290565b604051631a50ca5560e11b8152600490fd5b5090614a1a565b60405163375c24c160e01b815260006004820152602490fd5b91614ab4612c2b565b50815115614b3157600092835b8351811015614b2957614ad4818561204e565b51518251811015614a79576121b160206149f8614af1938661204e565b614afd57600101614ac1565b600101935090915b8315614b1d57614b1761063094612627565b91614e14565b50505050614a3d61051a565b509091614b05565b60405163375c24c160e01b815260016004820152602490fd5b90614b53612c2b565b92602082015192602084519401519360208083518310159260051b8401015151916040830151908151881015179660051b0101519260006060885195805187526020810151602088015260408101516040880152018051956080339101525261012082519260208901938452015192604088019384528751956001975b8151891081151615614cc1575060208860051b82010151976020895199015183518a1015998a614caf5760209060051b850101516020810151614c19575b505060010197614bd0565b90979199505196604088015190815181101580614c8557506001929160209160051b01015190606082015101976000606083015260208a01516020830151148a5183511416908851610120820151149088519051141616906040808b0151910151141615989038614c0e565b9996505050955050509450606091505b0152614c9d57565b604051637fda727960e01b8152600490fd5b50505050509493905060609150614c95565b9693505050945060609150614c95565b92919092614cdd612c2b565b9360208360051b82010151602081519101519460208085518410159360051b8601015151926040840151908151891015179760051b0101519360006060895196805188526020810151602089015260408101516040890152018051966080339101525261012083519360208a0194855201519360408901948552600189519701975b8151891081151615614cc1575060208860051b82010151976020895199015183518a1015998a614caf5760209060051b850101516020810151614da8575b505060010197614d5f565b90979199505196604088015190815181101580614c8557506001929160209160051b01015190606082015101976000606083015260208a01516020830151148a5183511416908851610120820151149088519051141616906040808b0151910151141615989038614d9d565b9291614e1e612c2b565b50614e27612c00565b9380519060208360051b8501015193602085519501519383861095861596614e7a575b505050505050614c9d5760405191614e61836104a3565b82523360208301526001600160a01b0316604082015290565b606091929394959897965060209060051b850101515101518051881097881598614ea8575b97959697614e4a565b60206001939260a09260051b01015180518952602081015160208a0152604081015160408a0152600060608201805160608c0152520151608088015201955b8151871015614fc5575060208660051b820101519560208751970151848810159788614fb85760209060051b850101516020810151614f2c575b505060010195614ee7565b516060015180519298509181101580614faa57509060209160051b010151600060608201805160608901510160608901525260408601516040820151146020870151602083015114168651825114169060a060808801519101511416159586614f96573880614f21565b5050505090915b9190388080808080614e9f565b959697505050505050614f9d565b5050505050509091614f9d565b93949550505050614f9d565b919060005b815181101561515557614fe9818361204e565b5180519085518210156151435760209161500a6121b1846149f8848b61204e565b1561513857615019908761204e565b51519160409283830151918301516150308161499f565b6150398161499f565b6150da5783018051518210156150c95790615054915161204e565b5191600383519361506485610bda565b849061507b848201916004835198148503906149a9565b606085015190525b11156150b9575090600192918161509e575b50505b01614fd6565b6150b2916080606083015192015191615d00565b3880615095565b51634a75b57b60e11b8152600490fd5b8351635fd9fc6760e11b8152600490fd5b92906060809401805151821015615127576003916150f8915161204e565b519384519461510686610bda565b859161511d858301926004845199148603906149a9565b8501519052615083565b82516330446bef60e11b8152600490fd5b505050600190615098565b6040516321a561b160e21b8152600490fd5b50509060005b815181101561523d5761516e818361204e565b516151866121b160208301516001600160781b031690565b156152345760608082510151519060005b8281106151ff5750505060408082510151519160005b8381106151c257505050506001905b0161515b565b6151e26151dc6151d683868651015161204e565b5161265b565b60031090565b6151ee576001016151ad565b825163a6cfc67360e01b8152600490fd5b6152136151dc6151d683858851015161204e565b61521f57600101615197565b60405160016202297360e61b03198152600490fd5b506001906151bc565b5050565b93929093848103615253575050505090565b9161526661526c9261527295969461215e565b9261215e565b90611aff565b0490565b93929093848103615288575050505090565b9161526c61529e6152aa9361527296979561215e565b9160001987019461215e565b611aff565b92919281811461523d57816152c4828661215e565b0493096152cd57565b60405163c63cf08960e01b8152600490fd5b906152e982610541565b6040906152f8825191826104d9565b8381528093615309601f1991610541565b019160005b83811061531b5750505050565b60209082516153298161046d565b6000815282600081830152600085830152606080808401526080830152600060a083015282860101520161530e565b6040519061536582610488565b6001825260203681840137565b6040519061537f826104a3565b600282526040366020840137565b9061539782610541565b60406153a5815192836104d9565b83825281936153b6601f1991610541565b0191600091825b8481106153cb575050505050565b60209082516153d981610488565b858152826060818301528286010152016153bd565b90815191600192838111156156ad57600061540882612813565b918582815b61565d575b50821115615650576154238261538d565b9061542d84612027565b51926154398487615c17565b615441615358565b9461544b86612027565b5261545584612027565b5152602094848661546586612027565b510152889489805b848110615556575050505083146155485761548790612813565b91615490615372565b9360005b8281106154be57505050610ed49495506154b76154b084612027565b519361203d565b51936156b8565b80826154cb8b938761204e565b51015180519060028210156154e3575b505001615494565b6154f66154ef8a61203d565b5160010190565b6154ff8a61203d565b528161550a8a612027565b51016155158a612027565b528360005b8381106155285750506154db565b81850161553f615538838661204e565b518c61204e565b5201849061551a565b505050509150610630611768565b615560818561204e565b5161556b818c615c17565b90600084815b8c81106155ba575b50501561558b575b5050018a9061546d565b61559485612027565b5261559f898961204e565b515282896155b0848b019a8a61204e565b5101523880615581565b6155c4818d61204e565b515185146155d457018590615571565b9150508b6155e2828c61204e565b510151908c825191846155f6898501612813565b948960005b8681106156255750505061561361561a93948661204e565b528c61204e565b510152838438615579565b8281939597965061563792945061204e565b51615642828861204e565b52018f9293918987926155fb565b5050509150610630611768565b85518110156156a85780600361567e61567785948a61204e565b515161265b565b61568781610bda565b14615694575b018161540d565b806156a2838701968861204e565b5261568d565b615412565b509150610630611768565b949390949291926156cc8151938403612c51565b936156d6836152df565b966156e2600094612813565b91845b8681106156f757505050505050509190565b615701818361204e565b51958a61570e838861204e565b51978061573c57505090615734826001809491019861572d828d61204e565b528a61204e565b505b016156e5565b9197600193926157cc91906080906157b190600019016001600160a01b0380615776615768848a61204e565b51516001600160a01b031690565b16156157d2575b50615788818c61204e565b5193888501615797838e61204e565b52604081510151906060916157b987846157b1878d61204e565b51015161204e565b52510151956157c787615d85565b61204e565b52615736565b61588b6020806157e2858f61204e565b51015151875182810151838a0151918901516001600160a01b0391821696928216938a939092615873928d92911661586361582561581f87612813565b96612813565b6040948501519098906001600160a01b031699615852615843610534565b6001600160a01b03909e168e52565b6001600160a01b03909116908c0152565b166001600160a01b031690880152565b60608601528401526001600160a01b031660a0830152565b615895828861204e565b526158a0818761204e565b503861577d565b959192939490948587146000146158c55750505061063093506152af565b929194846158db610630986158e19497866152af565b936152af565b90615241565b959192939490948587146000146159055750505061063093506152af565b929194846158db6106309861591b9497866152af565b90615276565b91909161592c612c00565b8151602080860151805191015192958282108015959193919290615956575b5050505050614c9d57565b60609192939496955060209060051b840101515101518051861095861596615981575b95949561594b565b9060209160051b0101519182518752602083015191602088019283526040840151916040890192835260a06060860195600087519760608d019889525201519560808a019687526001985b81518a1015615aa2575060208960051b820101519860208a519a0151848b10159a8b615a925760209060051b850101516020810151615a11575b5050600101986159cc565b51606001518051929b509181101580615a8157509060209160051b010151600060608201805189510189525284516040820151148651602083015114168b51825114169060a089519101511416159889615a6c573880615a06565b5050505050505050905b903880808080615979565b999a50505050505050505050615a76565b5050505050505050505090615a76565b97985050505050505050615a76565b15615afe57600060203d14615af3575b6001600160e01b031916633c78b38960e21b01615adb5750565b60249060405190633ed4053f60e21b82526004820152fd5b602081803e51615ac1565b602490615b09615cef565b60405190633ed4053f60e21b82526004820152fd5b906020810151615b72576001600160781b03806040830151169182615b47575b50505050600190565b60600151161115615b5a57808080615b3e565b602490604051906310fda3e160e01b82526004820152fd5b604051630694555d60e21b815260048101839052602490fd5b906020810151615b7257604001516001600160781b0316615bac5750600190565b6024906040519063ee9e0e6360e01b82526004820152fd5b906000906020810151615c0e576001600160781b03806040830151169182615bf1575b5050505050600190565b60600151161115615c0457808080615be7565b615b5a5750600090565b50905050600090565b90615c219161204e565b518051602080820151818401516080909301516040948501516001600160a01b039081169093528216601c5290821660085260601b6bffffffffffffffffffffffff191690821c6bffffffffffffffffffffffff161760009081522090565b615c88611f41565b50615cd2615ca4615c998380611922565b926020810190611a65565b615cbb60405194615cb486610452565b3690610717565b845260016020850152600160408501523691610823565b6060820152604051615ce3816104be565b60008152608082015290565b3d615cf657565b3d6000803e3d6000fd5b92909192906000915b8451831015615d4f57615d1c838661204e565b5190818111615d3b5760005260205260016040600020925b0191615d09565b906000526020526001604060002092615d34565b9150925003615d5a57565b6040516309bde33960e01b8152600490fd5b10615d7357565b604051632335530b60e11b8152600490fd5b15615d8c57565b60405163246cf94560e21b8152600490fd5b6102643560061b6102600161024435146102406102243514602060043514161615615dc557565b6040516339f3e3fd60e01b8152600490fdfea2646970667358221220c658fb668e86f75879bb958d34689da654cd9a6d4e3dd60b8cdf2e0eae9d213264736f6c634300080d0033",
  "devdoc": {
    "author": "0age",
    "custom:coauthor": "d1ll0ntransmissions11",
    "custom:version": "rc-1",
    "errors": {
      "BadContractSignature()": [
        {
          "details": "Revert with an error when an EIP-1271 call to an account fails."
        }
      ],
      "BadFraction()": [
        {
          "details": "Revert with an error when supplying a fraction with a value of zero      for the numerator or denominator, or one where the numerator exceeds      the denominator."
        }
      ],
      "BadReturnValueFromERC20OnTransfer(address,address,address,uint256)": [
        {
          "details": "Revert with an error when an ERC20 token transfer returns a falsey      value.",
          "params": {
            "amount": "The amount for the attempted ERC20 transfer.",
            "from": "The source of the attempted ERC20 transfer.",
            "to": "The recipient of the attempted ERC20 transfer.",
            "token": "The token for which the ERC20 transfer was attempted."
          }
        }
      ],
      "BadSignatureV(uint8)": [
        {
          "details": "Revert with an error when a signature that does not contain a v      value of 27 or 28 has been supplied.",
          "params": {
            "v": "The invalid v value."
          }
        }
      ],
      "ConsiderationCriteriaResolverOutOfRange()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order with a consideration item that has not been supplied."
        }
      ],
      "ConsiderationNotMet(uint256,uint256,uint256)": [
        {
          "details": "Revert with an error if a consideration amount has not been fully      zeroed out after applying all fulfillments.",
          "params": {
            "considerationIndex": "The index of the consideration item on the                           order.",
            "orderIndex": "The index of the order with the consideration                           item with a shortfall.",
            "shortfallAmount": "The unfulfilled consideration amount."
          }
        }
      ],
      "CriteriaNotEnabledForItem()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order with an item that does not expect a criteria to be      resolved."
        }
      ],
      "ERC1155BatchTransferGenericFailure(address,address,address,uint256[],uint256[])": [
        {
          "details": "Revert with an error when a batch ERC1155 token transfer reverts.",
          "params": {
            "amounts": "The amounts for the attempted transfer.",
            "from": "The source of the attempted transfer.",
            "identifiers": "The identifiers for the attempted transfer.",
            "to": "The recipient of the attempted transfer.",
            "token": "The token for which the transfer was attempted."
          }
        }
      ],
      "EtherTransferGenericFailure(address,uint256)": [
        {
          "details": "Revert with an error when an ether transfer reverts."
        }
      ],
      "FulfilledOrderIndexOutOfRange()": [
        {
          "details": "Revert with an error when a fulfillment is provided with an index      that references an order or item that has not been supplied."
        }
      ],
      "InexactFraction()": [
        {
          "details": "Revert with an error when attempting to apply a fraction as part of      a partial fill that does not divide the target amount cleanly."
        }
      ],
      "InsufficientEtherSupplied()": [
        {
          "details": "Revert with an error when insufficient ether is supplied as part of      msg.value when fulfilling orders."
        }
      ],
      "InvalidBasicOrderParameterEncoding()": [
        {
          "details": "Revert with an error when attempting to fill a basic order using      calldata not produced by default ABI encoding."
        }
      ],
      "InvalidCanceller()": [
        {
          "details": "Revert with an error when attempting to cancel an order as a caller      other than the indicated offerer or zone."
        }
      ],
      "InvalidERC721TransferAmount()": [
        {
          "details": "Revert with an error when an ERC721 transfer with amount other than      one is attempted."
        }
      ],
      "InvalidFulfillmentComponentData()": [
        {
          "details": "Revert with an error when an order or item index are out of range      or a fulfillment component does not match the type, token,      identifier, or conduit preference of the initial consideration item."
        }
      ],
      "InvalidMsgValue(uint256)": [
        {
          "details": "Revert with an error when a caller attempts to supply callvalue to a      non-payable basic order route or does not supply any callvalue to a      payable basic order route."
        }
      ],
      "InvalidProof()": [
        {
          "details": "Revert with an error when providing a criteria resolver that      contains an invalid proof with respect to the given item and      chosen identifier."
        }
      ],
      "InvalidProxyImplementation()": [
        {
          "details": "Revert with an error when the implementation of the respective      legacy user proxy does not match the expected proxy implementation."
        }
      ],
      "InvalidRestrictedOrder(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill an order that specifies      a restricted submitter as its order type when not submitted by      either the offerrer or the order's zone or approved as valid by the      zone in question via a staticcall to `isValidOrder`.",
          "params": {
            "orderHash": "The order hash for the invalid restricted order."
          }
        }
      ],
      "InvalidSignature()": [
        {
          "details": "Revert with an error when a signer cannot be recovered from the      supplied signature."
        }
      ],
      "InvalidSigner()": [
        {
          "details": "Revert with an error when the signer recovered by the supplied      signature does not match the offerer or an allowed EIP-1271 signer      as specified by the offerer in the event they are a contract."
        }
      ],
      "InvalidTime()": [
        {
          "details": "Revert with an error when attempting to fill an order outside the      specified start time and end time ."
        }
      ],
      "MismatchedFulfillmentOfferAndConsiderationComponents()": [
        {
          "details": "Revert with an error when the initial offer item named by a      fulfillment component does not match the type, token, identifier,      or conduit preference of the initial consideration item."
        }
      ],
      "MissingFulfillmentComponentOnAggregation(uint8)": [
        {
          "details": "Revert with an error when a fulfillment is provided as part of an      call to fulfill available orders that does not declare at least one      component."
        }
      ],
      "MissingItemAmount()": [
        {
          "details": "Revert with an error when attempting to fulfill an order where an      item has an amount of zero."
        }
      ],
      "MissingOriginalConsiderationItems()": [
        {
          "details": "Revert with an error when an order is supplied for fulfillment with      a consideration array that is shorter than the original array."
        }
      ],
      "NoContract(address)": [
        {
          "details": "Revert with an error when an account being called as an assumed      contract does not have code and returns no data.",
          "params": {
            "account": "The account that should contain code."
          }
        }
      ],
      "NoReentrantCalls()": [
        {
          "details": "Revert with an error when a caller attempts to reenter a protected      function."
        }
      ],
      "NoSpecifiedOrdersAvailable()": [
        {
          "details": "Revert with an error when attempting to fulfill any number of      available orders when none are fulfillable."
        }
      ],
      "OfferAndConsiderationRequiredOnFulfillment()": [
        {
          "details": "Revert with an error when a fulfillment is provided that does not      declare at least one offer component and at least one consideration      component."
        }
      ],
      "OfferCriteriaResolverOutOfRange()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order with an offer item that has not been supplied."
        }
      ],
      "OrderAlreadyFilled(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill an order that has      already been fully filled.",
          "params": {
            "orderHash": "The order hash on which a fill was attempted."
          }
        }
      ],
      "OrderCriteriaResolverOutOfRange()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order that has not been supplied."
        }
      ],
      "OrderIsCancelled(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill an order that has been      cancelled.",
          "params": {
            "orderHash": "The hash of the cancelled order."
          }
        }
      ],
      "OrderPartiallyFilled(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill a basic order that has      been partially filled.",
          "params": {
            "orderHash": "The hash of the partially used order."
          }
        }
      ],
      "PartialFillsNotEnabledForOrder()": [
        {
          "details": "Revert with an error when a partial fill is attempted on an order      that does not specify partial fill support in its order type."
        }
      ],
      "TokenTransferGenericFailure(address,address,address,uint256,uint256)": [
        {
          "details": "Revert with an error when an ERC20, ERC721, or ERC1155 token      transfer reverts.",
          "params": {
            "amount": "The amount for the attempted transfer.",
            "from": "The source of the attempted transfer.",
            "identifier": "The identifier for the attempted transfer.",
            "to": "The recipient of the attempted transfer.",
            "token": "The token for which the transfer was attempted."
          }
        }
      ],
      "UnresolvedConsiderationCriteria()": [
        {
          "details": "Revert with an error if a consideration item still has unresolved      criteria after applying all criteria resolvers."
        }
      ],
      "UnresolvedOfferCriteria()": [
        {
          "details": "Revert with an error if an offer item still has unresolved criteria      after applying all criteria resolvers."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "DOMAIN_SEPARATOR()": {
        "returns": {
          "_0": "The domain separator."
        }
      },
      "cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256)[])": {
        "params": {
          "orders": "The orders to cancel."
        },
        "returns": {
          "_0": "A boolean indicating whether the supplied orders were         successfully cancelled."
        }
      },
      "constructor": {
        "params": {
          "legacyProxyRegistry": "A proxy registry that stores per-user                                    proxies that may optionally be used to                                    transfer approved ERC721+1155 tokens.",
          "legacyTokenTransferProxy": "A shared proxy contract that may                                    optionally be used to transfer                                    approved ERC20 tokens.",
          "requiredProxyImplementation": "The implementation that must be set on                                    each proxy in order to utilize it."
        }
      },
      "fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],address)": {
        "params": {
          "advancedOrder": "The order to fulfill along with the fraction of                          the order to attempt to fill. Note that both the                          offerer and the fulfiller must first approve                          this contract (or their proxy if indicated by                          the order) to transfer any relevant tokens on                          their behalf and that contracts must implement                          `onERC1155Received` in order to receive ERC1155                          tokens as consideration. Also note that all                          offer and consideration components must have no                          remainder after multiplication of the respective                          amount with the supplied fraction in order for                          the partial fill to be considered valid.",
          "criteriaResolvers": "An array where each element contains a reference                          to a specific offer or consideration, a token                          identifier, and a proof that the supplied token                          identifier is contained in the merkle root held                          by the item in question's criteria element. Note                          that an empty criteria indicates that any                          (transferrable) token identifier on the token in                          question is valid and that no associated proof                          needs to be supplied.",
          "fulfillerConduit": "An address indicating what conduit, if any, to                          source the fulfiller's token approvals from. The                          null address signifies that no conduit should be                          used (and direct approvals set on Consideration)                          and `address(1)` signifies to utilize the legacy                          user proxy for the fulfiller."
        },
        "returns": {
          "_0": "A boolean indicating whether the order has been fulfilled."
        }
      },
      "fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],address)": {
        "params": {
          "advancedOrders": "The orders to fulfill along with the                                  fraction of those orders to attempt to                                  fill. Note that both the offerer and the                                  fulfiller must first approve this                                  contract (or their proxy if indicated by                                  the order) to transfer any relevant                                  tokens on their behalf and that                                  contracts must implement                                  `onERC1155Received` in order to receive                                  ERC1155 tokens as consideration. Also                                  note that all offer and consideration                                  components must have no remainder after                                  multiplication of the respective amount                                  with the supplied fraction for an                                  order's partial fill amount to be                                  considered valid.",
          "considerationFulfillments": "An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.",
          "criteriaResolvers": "An array where each element contains a                                  reference to a specific offer or                                  consideration, a token identifier, and a                                  proof that the supplied token identifier                                  is contained in the merkle root held by                                  the item in question's criteria element.                                  Note that an empty criteria indicates                                  that any (transferrable) token                                  identifier on the token in question is                                  valid and that no associated proof needs                                  to be supplied.",
          "fulfillerConduit": "An address indicating what conduit, if                                  any, to source the fulfiller's token                                  approvals from. The null address                                  signifies that no conduit should be used                                  (with direct token approvals set on                                  Consideration) and `address(1)`                                  signifies to utilize the legacy user                                  proxy for the fulfiller.",
          "offerFulfillments": "An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions."
        },
        "returns": {
          "availableOrders": "   An array of booleans indicating if each order                            with an index corresponding to the index of                            the returned boolean was fulfillable or not.",
          "batchExecutions": "   An array of elements indicating the sequence                            of batch transfers performed as part of                            matching the given orders.",
          "standardExecutions": "An array of elements indicating the sequence                            of non-batch transfers performed as part of                            matching the given orders."
        }
      },
      "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,address,address,uint256,(uint256,address)[],bytes))": {
        "params": {
          "parameters": "Additional information on the fulfilled order. Note                   that the offerer and the fulfiller must first approve                   this contract (or their chosen conduit if indicated)                   before any tokens can be transferred. Also note that                   contract recipients of ERC1155 consideration items must                   implement `onERC1155Received` in order to receive those                   items."
        },
        "returns": {
          "_0": "A boolean indicating whether the order has been fulfilled."
        }
      },
      "fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes),address)": {
        "params": {
          "fulfillerConduit": "An address indicating what conduit, if any, to                         source the fulfiller's token approvals from. The                         null address signifies that no conduit should be                         used (and direct approvals set on Consideration)                         and `address(1)` signifies to utilize the legacy                         user proxy for the fulfiller.",
          "order": "The order to fulfill. Note that both the offerer                         and the fulfiller must first approve this                         contract (or the supplied conduit if indicated)                         to transfer any relevant tokens on their behalf                         and that contracts must implement                         `onERC1155Received` in order to receive ERC1155                         tokens as consideration."
        },
        "returns": {
          "_0": "A boolean indicating whether the order has been fulfilled."
        }
      },
      "getNonce(address)": {
        "params": {
          "offerer": "The offerer in question."
        },
        "returns": {
          "_0": "The current nonce."
        }
      },
      "getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256))": {
        "params": {
          "order": "The components of the order."
        },
        "returns": {
          "_0": "The order hash."
        }
      },
      "getOrderStatus(bytes32)": {
        "params": {
          "orderHash": "The order hash in question."
        },
        "returns": {
          "isCancelled": "A boolean indicating whether the order in question                     has been cancelled.",
          "isValidated": "A boolean indicating whether the order in question                     has been validated (i.e. previously approved or                     partially filled).",
          "totalFilled": "The total portion of the order that has been filled                     (i.e. the \"numerator\").",
          "totalSize": "  The total size of the order that is either filled or                     unfilled (i.e. the \"denominator\")."
        }
      },
      "incrementNonce()": {
        "returns": {
          "newNonce": "The new nonce."
        }
      },
      "matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "params": {
          "advancedOrders": "The advanced orders to match. Note that both the                          offerer and fulfiller on each order must first                          approve this contract (or their proxy if                          indicated by the order) to transfer any relevant                          tokens on their behalf and each consideration                          recipient must implement `onERC1155Received` in                          order toreceive ERC1155 tokens. Also note that                          the offer and consideration components for each                          order must have no remainder after multiplying                          the respective amount with the supplied fraction                          in order for the group of partial fills to be                          considered valid.",
          "criteriaResolvers": "An array where each element contains a reference                          to a specific order as well as that order's                          offer or consideration, a token identifier, and                          a proof that the supplied token identifier is                          contained in the order's merkle root. Note that                          an empty root indicates that any (transferrable)                          token identifier is valid and that no associated                          proof needs to be supplied.",
          "fulfillments": "An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid."
        },
        "returns": {
          "batchExecutions": "   An array of elements indicating the sequence                            of batch transfers performed as part of                            matching the given orders.",
          "standardExecutions": "An array of elements indicating the sequence                            of non-batch transfers performed as part of                            matching the given orders."
        }
      },
      "matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "params": {
          "fulfillments": "An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.",
          "orders": "The orders to match. Note that both the offerer                          and fulfiller on each order must first approve                          this contract (or their proxy if indicated by                          the order) to transfer any relevant tokens on                          their behalf and each consideration recipient                          must implement `onERC1155Received` in order to                          receive ERC1155 tokens."
        },
        "returns": {
          "batchExecutions": "   An array of elements indicating the sequence                            of batch transfers performed as part of                            matching the given orders.",
          "standardExecutions": "An array of elements indicating the sequence                            of non-batch transfers performed as part of                            matching the given orders."
        }
      },
      "name()": {
        "returns": {
          "_0": "The name of this contract."
        }
      },
      "validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[])": {
        "params": {
          "orders": "The orders to validate."
        },
        "returns": {
          "_0": "A boolean indicating whether the supplied orders were         successfully validated."
        }
      },
      "version()": {
        "returns": {
          "_0": "The version of this contract."
        }
      }
    },
    "title": "Consideration",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "DOMAIN_SEPARATOR()": {
        "notice": "Retrieve the domain separator, used for signing and verifying signed orders via EIP-712."
      },
      "cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256)[])": {
        "notice": "Cancel an arbitrary number of orders. Note that only the offerer or the zone of a given order may cancel it."
      },
      "constructor": {
        "notice": "Derive and set hashes, reference chainId, and associated domain         separator during deployment."
      },
      "fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],address)": {
        "notice": "Fill an order, fully or partially, with an arbitrary number of         items for offer and consideration alongside criteria resolvers         containing specific token identifiers and associated proofs."
      },
      "fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],address)": {
        "notice": "Attempt to fill a group of orders, fully or partially, with an         arbitrary number of items for offer and consideration per order         alongside criteria resolvers containing specific token         identifiers and associated proofs. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail."
      },
      "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,address,address,uint256,(uint256,address)[],bytes))": {
        "notice": "Fulfill an order offering an ERC20, ERC721, or ERC1155 item by         supplying Ether (or other native tokens), ERC20 tokens, an ERC721         item, or an ERC1155 item as consideration. Six permutations are         supported: Native token to ERC721, Native token to ERC1155, ERC20         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to         ERC20 (with native tokens supplied as msg.value). For an order to         be eligible for fulfillment via this method, it must contain a         single offer item (though that item may have a greater amount if         the item is not an ERC721). An arbitrary number of \"additional         recipients\" may also be supplied which will each receive native         tokens or ERC20 items from the fulfiller as consideration. Refer         to the documentation for a more comprehensive summary of how to         utilize with this method and what orders are compatible with it."
      },
      "fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes),address)": {
        "notice": "Fulfill an order with an arbitrary number of items for offer and         consideration. Note that this function does not support         criteria-based orders or partial filling of orders (though         filling the remainder of a partially-filled order is supported)."
      },
      "getNonce(address)": {
        "notice": "Retrieve the current nonce for a given offerer."
      },
      "getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256))": {
        "notice": "Retrieve the order hash for a given order."
      },
      "getOrderStatus(bytes32)": {
        "notice": "Retrieve the status of a given order by hash, including whether         the order has been cancelled or validated and the fraction of the         order that has been filled."
      },
      "incrementNonce()": {
        "notice": "Cancel all orders from a given offerer with a given zone in bulk         by incrementing a nonce. Note that only the offerer may increment         the nonce."
      },
      "matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "notice": "Match an arbitrary number of full or partial orders, each with an         arbitrary number of items for offer and consideration, supplying         criteria resolvers containing specific token identifiers and         associated proofs as well as fulfillments allocating offer         components to consideration components."
      },
      "matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "notice": "Match an arbitrary number of orders, each with an arbitrary         number of items for offer and consideration along with a set of         fulfillments allocating offer components to consideration         components. Note that this function does not support         criteria-based or partial filling of orders (though filling the         remainder of a partially-filled order is supported)."
      },
      "name()": {
        "notice": "Retrieve the name of this contract."
      },
      "validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,address,uint256),bytes)[])": {
        "notice": "Validate an arbitrary number of orders, thereby registering them         as valid and allowing the fulfiller to skip verification. Note         that anyone can validate a signed order but only the offerer can         validate an order without supplying a signature."
      },
      "version()": {
        "notice": "Retrieve the version of this contract."
      }
    },
    "notice": "Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.         It minimizes external calls to the greatest extent possible and         provides lightweight methods for common routes as well as more         flexible methods for composing advanced orders or groups of orders.         Each order contains an arbitrary number of items that may be spent         (the \"offer\") along with an arbitrary number of items that must be         received back by the indicated recipients (the \"consideration\").",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3282,
        "contract": "contracts/Consideration.sol:Consideration",
        "label": "_reentrancyGuard",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 3287,
        "contract": "contracts/Consideration.sol:Consideration",
        "label": "_orderStatus",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(OrderStatus)8932_storage)"
      },
      {
        "astId": 3291,
        "contract": "contracts/Consideration.sol:Consideration",
        "label": "_nonces",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_struct(OrderStatus)8932_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct OrderStatus)",
        "numberOfBytes": "32",
        "value": "t_struct(OrderStatus)8932_storage"
      },
      "t_struct(OrderStatus)8932_storage": {
        "encoding": "inplace",
        "label": "struct OrderStatus",
        "members": [
          {
            "astId": 8925,
            "contract": "contracts/Consideration.sol:Consideration",
            "label": "isValidated",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 8927,
            "contract": "contracts/Consideration.sol:Consideration",
            "label": "isCancelled",
            "offset": 1,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 8929,
            "contract": "contracts/Consideration.sol:Consideration",
            "label": "numerator",
            "offset": 2,
            "slot": "0",
            "type": "t_uint120"
          },
          {
            "astId": 8931,
            "contract": "contracts/Consideration.sol:Consideration",
            "label": "denominator",
            "offset": 17,
            "slot": "0",
            "type": "t_uint120"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint120": {
        "encoding": "inplace",
        "label": "uint120",
        "numberOfBytes": "15"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}