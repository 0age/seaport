// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "seaport-sol/SeaportSol.sol";

import {
    AdvancedOrder,
    MOATHelpers,
    Structure,
    Family
} from "./MOATHelpers.sol";
import { BaseOrderTest } from "../BaseOrderTest.sol";

struct FuzzParams {
    uint256 seed;
}

struct TestContext {
    /**
     * @dev An array of AdvancedOrders
     */
    AdvancedOrder[] orders;
    /**
     * @dev A Seaport interface, either the reference or optimized version.
     */
    SeaportInterface seaport;
    /**
     * @dev A caller address. If this is nonzero, the MOATEngine will prank this
     *      address before calling exec.
     */
    address caller;
    /**
     * @dev A struct containing fuzzed params generated by the Foundry fuzzer.
     *      Right now these params include only a uint256 seed, which we could
     *      potentially use to generate other random data.
     */
    FuzzParams fuzzParams;
    /**
     * @dev An array of function selectors for "checks". The MOATEngine will
     *      call these functions after calling exec to make assertions about
     *      the resulting test state.
     */
    bytes4[] checks;
    /**
     * @dev Additional data we might need to fulfill an order. This is basically the
     *      superset of all the non-order args to SeaportInterface functions, like
     *      conduit key, criteria resolvers, and fulfillments.
     */
    uint256 counter;
    bytes32 fulfillerConduitKey;
    CriteriaResolver[] criteriaResolvers;
    address recipient;
}

/**
 * @notice Builder library for TestContext.
 */
library TestContextLib {
    using AdvancedOrderLib for AdvancedOrder;
    using AdvancedOrderLib for AdvancedOrder[];

    /**
     * @dev Create an empty TestContext.
     *
     * @custom:return emptyContext the empty TestContext
     */
    function empty() internal pure returns (TestContext memory) {
        return
            TestContext({
                orders: new AdvancedOrder[](0),
                seaport: SeaportInterface(address(0)),
                caller: address(0),
                fuzzParams: FuzzParams({ seed: 0 }),
                checks: new bytes4[](0),
                counter: 0,
                fulfillerConduitKey: bytes32(0),
                criteriaResolvers: new CriteriaResolver[](0),
                recipient: address(0)
            });
    }

    /**
     * @dev Create a TestContext from the given partial arguments.
     *
     * @param orders the AdvancedOrder[] to set
     * @param seaport the SeaportInterface to set
     * @param caller the caller address to set
     * @param fuzzParams the fuzzParams struct to set
     * @custom:return _context the TestContext
     */
    function from(
        AdvancedOrder[] memory orders,
        SeaportInterface seaport,
        address caller,
        FuzzParams memory fuzzParams
    ) internal pure returns (TestContext memory) {
        return
            TestContext({
                orders: orders,
                seaport: seaport,
                caller: caller,
                fuzzParams: fuzzParams,
                checks: new bytes4[](0),
                counter: 0,
                fulfillerConduitKey: bytes32(0),
                criteriaResolvers: new CriteriaResolver[](0),
                recipient: address(0)
            });
    }

    /**
     * @dev Sets the orders on a TestContext
     *
     * @param context the TestContext to set the orders of
     * @param orders the AdvancedOrder[] to set
     *
     * @return _context the TestContext with the orders set
     */
    function withOrders(
        TestContext memory context,
        AdvancedOrder[] memory orders
    ) internal pure returns (TestContext memory) {
        context.orders = orders.copy();
        return context;
    }

    /**
     * @dev Sets the SeaportInterface on a TestContext
     *
     * @param context the TestContext to set the SeaportInterface of
     * @param seaport the SeaportInterface to set
     *
     * @return _context the TestContext with the SeaportInterface set
     */
    function withSeaport(
        TestContext memory context,
        SeaportInterface seaport
    ) internal pure returns (TestContext memory) {
        context.seaport = seaport;
        return context;
    }

    /**
     * @dev Sets the caller on a TestContext
     *
     * @param context the TestContext to set the caller of
     * @param caller the caller address to set
     *
     * @return _context the TestContext with the caller set
     */
    function withCaller(
        TestContext memory context,
        address caller
    ) internal pure returns (TestContext memory) {
        context.caller = caller;
        return context;
    }

    /**
     * @dev Sets the fuzzParams on a TestContext
     *
     * @param context the TestContext to set the fuzzParams of
     * @param fuzzParams the fuzzParams struct to set
     *
     * @return _context the TestContext with the fuzzParams set
     */
    function withFuzzParams(
        TestContext memory context,
        FuzzParams memory fuzzParams
    ) internal pure returns (TestContext memory) {
        context.fuzzParams = _copyFuzzParams(fuzzParams);
        return context;
    }

    /**
     * @dev Sets the checks on a TestContext
     *
     * @param context the TestContext to set the checks of
     * @param checks the checks array to set
     *
     * @return _context the TestContext with the checks set
     */
    function withChecks(
        TestContext memory context,
        bytes4[] memory checks
    ) internal pure returns (TestContext memory) {
        context.checks = _copyBytes4(checks);
        return context;
    }

    /**
     * @dev Sets the counter on a TestContext
     *
     * @param context the TestContext to set the counter of
     * @param counter the counter value to set
     *
     * @return _context the TestContext with the counter set
     */
    function withCounter(
        TestContext memory context,
        uint256 counter
    ) internal pure returns (TestContext memory) {
        context.counter = counter;
        return context;
    }

    /**
     * @dev Sets the fulfillerConduitKey on a TestContext
     *
     * @param context the TestContext to set the fulfillerConduitKey of
     * @param fulfillerConduitKey the fulfillerConduitKey value to set
     *
     * @return _context the TestContext with the fulfillerConduitKey set
     */
    function withFulfillerConduitKey(
        TestContext memory context,
        bytes32 fulfillerConduitKey
    ) internal pure returns (TestContext memory) {
        context.fulfillerConduitKey = fulfillerConduitKey;
        return context;
    }

    /**
     * @dev Sets the criteriaResolvers on a TestContext
     *
     * @param context the TestContext to set the criteriaResolvers of
     * @param criteriaResolvers the criteriaResolvers array to set
     *
     * @return _context the TestContext with the criteriaResolvers set
     */
    function withCriteriaResolvers(
        TestContext memory context,
        CriteriaResolver[] memory criteriaResolvers
    ) internal pure returns (TestContext memory) {
        context.criteriaResolvers = _copyCriteriaResolvers(criteriaResolvers);
        return context;
    }

    /**
     * @dev Sets the recipient on a TestContext
     *
     * @param context the TestContext to set the recipient of
     * @param recipient the recipient value to set
     *
     * @return _context the TestContext with the recipient set
     */
    function withRecipient(
        TestContext memory context,
        address recipient
    ) internal pure returns (TestContext memory) {
        context.recipient = recipient;
        return context;
    }

    function _copyBytes4(
        bytes4[] memory selectors
    ) private pure returns (bytes4[] memory) {
        bytes4[] memory copy = new bytes4[](selectors.length);
        for (uint256 i = 0; i < selectors.length; i++) {
            copy[i] = selectors[i];
        }
        return copy;
    }

    function _copyCriteriaResolvers(
        CriteriaResolver[] memory criteriaResolvers
    ) private pure returns (CriteriaResolver[] memory) {
        CriteriaResolver[] memory copy = new CriteriaResolver[](
            criteriaResolvers.length
        );
        for (uint256 i = 0; i < criteriaResolvers.length; i++) {
            copy[i] = criteriaResolvers[i];
        }
        return copy;
    }

    function _copyFuzzParams(
        FuzzParams memory params
    ) private pure returns (FuzzParams memory) {
        return FuzzParams({ seed: params.seed });
    }
}

/**
 * @notice Stateless helpers for MOATEngine.
 */
library MOATEngineLib {
    using OrderComponentsLib for OrderComponents;
    using OrderParametersLib for OrderParameters;
    using OrderLib for Order;
    using AdvancedOrderLib for AdvancedOrder;
    using MOATHelpers for AdvancedOrder;
    using MOATHelpers for AdvancedOrder[];

    /**
     * @dev Select an available "action," i.e. "which Seaport function to call,"
     *      based on the orders in a given TestContext. Selects a random action
     *      using the context's fuzzParams.seed when multiple actions are
     *      available for the given order config.
     *
     * @param context A MOAT test context.
     * @return bytes4 selector of a SeaportInterface function.
     */
    function action(TestContext memory context) internal pure returns (bytes4) {
        bytes4[] memory _actions = actions(context);
        return _actions[context.fuzzParams.seed % _actions.length];
    }

    /**
     * @dev Get an array of all possible "actions," i.e. "which Seaport
     *      functions can we call," based on the orders in a given TestContext.
     *
     * @param context A MOAT test context.
     * @return bytes4[] of SeaportInterface function selectors.
     */
    function actions(
        TestContext memory context
    ) internal pure returns (bytes4[] memory) {
        Family family = context.orders.getFamily();

        if (family == Family.SINGLE) {
            AdvancedOrder memory order = context.orders[0];
            Structure structure = order.getStructure();
            if (structure == Structure.STANDARD) {
                bytes4[] memory selectors = new bytes4[](2);
                selectors[0] = context.seaport.fulfillOrder.selector;
                selectors[1] = context.seaport.fulfillAdvancedOrder.selector;
                return selectors;
            }
            if (structure == Structure.ADVANCED) {
                bytes4[] memory selectors = new bytes4[](1);
                selectors[0] = context.seaport.fulfillAdvancedOrder.selector;
                return selectors;
            }
        }

        if (family == Family.COMBINED) {
            bytes4[] memory selectors = new bytes4[](6);
            selectors[0] = context.seaport.fulfillAvailableOrders.selector;
            selectors[1] = context
                .seaport
                .fulfillAvailableAdvancedOrders
                .selector;
            selectors[2] = context.seaport.matchOrders.selector;
            selectors[3] = context.seaport.matchAdvancedOrders.selector;
            selectors[4] = context.seaport.cancel.selector;
            selectors[5] = context.seaport.validate.selector;
            return selectors;
        }
        revert("MOATEngine: Actions not found");
    }
}

/**
 * @notice Base test contract for MOATEngine. MOAT tests should inherit this.
 *         Includes the setup and helper functions from BaseOrderTest.
 *
 *         Engine lifecycle:
 *           - generate a TestContext. This struct includes:
 *           - exec(context)
 *           - checkAll(context)
 */
contract MOATEngine is BaseOrderTest {
    using OrderComponentsLib for OrderComponents;
    using OrderParametersLib for OrderParameters;
    using OrderLib for Order;
    using AdvancedOrderLib for AdvancedOrder;
    using MOATHelpers for AdvancedOrder;
    using MOATHelpers for AdvancedOrder[];
    using MOATEngineLib for TestContext;

    /**
     * @dev Call an available Seaport function based on the orders in the given
     *      TestContext. MOATEngine will deduce which actions are available
     *      for the given orders and call a Seaport function at random using the
     *      context's fuzzParams.seed.
     *
     *      If a caller address is provided in the context, exec will prank the
     *      address before executing the selected action.
     *
     *      Note: not all Seaport actions are implemented here yet.
     *
     * @param context A MOAT test context.
     */
    function exec(TestContext memory context) internal {
        if (context.caller != address(0)) vm.startPrank(context.caller);
        bytes4 _action = context.action();
        if (_action == context.seaport.fulfillOrder.selector) {
            AdvancedOrder memory order = context.orders[0];

            context.seaport.fulfillOrder(
                order.toOrder(),
                context.fulfillerConduitKey
            );
        } else if (_action == context.seaport.fulfillAdvancedOrder.selector) {
            AdvancedOrder memory order = context.orders[0];

            context.seaport.fulfillAdvancedOrder(
                order,
                context.criteriaResolvers,
                context.fulfillerConduitKey,
                context.recipient
            );
        } else if (_action == context.seaport.cancel.selector) {
            AdvancedOrder[] memory orders = context.orders;
            OrderComponents[] memory orderComponents = new OrderComponents[](
                orders.length
            );

            for (uint256 i; i < orders.length; ++i) {
                AdvancedOrder memory order = orders[i];
                orderComponents[i] = order
                    .toOrder()
                    .parameters
                    .toOrderComponents(context.counter);
            }

            context.seaport.cancel(orderComponents);
        } else if (_action == context.seaport.validate.selector) {
            AdvancedOrder[] memory advancedOrders = context.orders;
            Order[] memory orders = new Order[](advancedOrders.length);

            for (uint256 i; i < advancedOrders.length; ++i) {
                orders[i] = advancedOrders[i].toOrder();
            }

            context.seaport.validate(orders);
        } else {
            revert("MOATEngine: Action not implemented");
        }
        if (context.caller != address(0)) vm.stopPrank();
    }

    /**
     * @dev Perform a "check," i.e. a post-execution assertion we want to
     *      validate. Checks should be public functions that accept a
     *      TestContext as their only argument. Checks have access to the
     *      post-execution TestContext and can use it to make test assertions.
     *
     *      Since we delegatecall ourself, checks must be public functions on
     *      this contract. It's a good idea to prefix them with "check_" as a
     *      naming convention, although it doesn't actually matter.
     *
     *      The idea here is that we can add checks for different scenarios to
     *      the MOATEngine by adding them via abstract contracts.
     *
     * @param context A MOAT test context.
     * @param selector bytes4 selector of the check function to call.
     */
    function check(TestContext memory context, bytes4 selector) internal {
        (bool success, bytes memory result) = address(this).delegatecall(
            abi.encodeWithSelector(selector, context)
        );
        if (!success) {
            if (result.length == 0) revert();
            assembly {
                revert(add(0x20, result), mload(result))
            }
        }
    }

    /**
     * @dev Perform all checks registered in the context.checks array.
     *
     *      We can add checks to the TestContext at any point in the context
     *      lifecycle, to be called after exec in the test lifecycle.
     *
     *      This is not set up yet, but the idea here is that we can add checks
     *      at order generation time, based on the characteristics of the orders
     *      we generate.
     *
     * @param context A MOAT test context.
     */
    function checkAll(TestContext memory context) internal {
        for (uint256 i; i < context.checks.length; ++i) {
            bytes4 selector = context.checks[i];
            check(context, selector);
        }
    }
}
